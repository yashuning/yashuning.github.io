<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>hexo - Next 主题添加搜索功能</title>
      <link href="/2018/06/29/hexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/"/>
      <url>/2018/06/29/hexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<p>Next 主题要是 <code>5.1.0</code> 版本的</p><h3 id="使用-LocalSearch-搜索功能"><a href="#使用-LocalSearch-搜索功能" class="headerlink" title="使用 LocalSearch 搜索功能"></a>使用 LocalSearch 搜索功能</h3><h4 id="安装相关插件"><a href="#安装相关插件" class="headerlink" title="安装相关插件"></a>安装相关插件</h4><p>安装搜索插件： <code>hexo-generator-searchdb</code></p><p>在博客根目录下执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><h4 id="配置博客"><a href="#配置博客" class="headerlink" title="配置博客"></a>配置博客</h4><p>安装完成，编辑博客配置文件：<code>_config.yml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><h4 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h4><p>Next 主题自带搜索设置，编辑主题配置文件：<code>_config.yml</code></p><p>找到文件中 Local search 的相关配置，设为 <code>true</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line">local_search:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>hexo 重新部署</p>]]></content>
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> Next-搜索 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo - Next 主题添加评论功能</title>
      <link href="/2018/06/29/hexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/"/>
      <url>/2018/06/29/hexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<p>Hexo 的 Next 主题继承了多种评论系统，我在这里介绍两种个人觉得不错的评论系统：Valine 和 gitment</p><h3 id="Valine-评论系统"><a href="#Valine-评论系统" class="headerlink" title="Valine 评论系统"></a>Valine 评论系统</h3><p>使用 Valine 评论系统，这款系统不需要登录便可以登录，没有后端，Next 主题最新已经支持安装</p><ul><li>基于 Leancloud 的系统</li><li>支持 MarkDown 语法</li><li>无后端实现，快速高效</li></ul><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><h5 id="注册-LeanCloud"><a href="#注册-LeanCloud" class="headerlink" title="注册 LeanCloud"></a>注册 LeanCloud</h5><p>因为 Valine 是基于 LeanCloud 系统的，所以先在 LeanCloud 中注册账号</p><p><a href="https://leancloud.cn/dashboard/login.html#/signin" target="_blank" rel="noopener">LeanCloud官网登录入口</a></p><p>注册登陆后，访问控制台，创建应用，选择开发版，创建好之后就生成了 <code>App ID</code> 和 <code>App Key</code></p><h5 id="设置-Next-主题"><a href="#设置-Next-主题" class="headerlink" title="设置 Next 主题"></a>设置 Next 主题</h5><p>在主题的配置文件中，修改关于 valine 的配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Valine.</span></span><br><span class="line"><span class="comment"># You can get your appid and appkey from https://leancloud.cn</span></span><br><span class="line"><span class="comment"># more info please open https://valine.js.org</span></span><br><span class="line">valine:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span> <span class="comment"># 是否开启</span></span><br><span class="line">  appid:   <span class="comment"># 上一步获取的 App ID</span></span><br><span class="line">  appkey:  <span class="comment"># 上一步获取的 App Key</span></span><br><span class="line">  notify: <span class="literal">false</span> <span class="comment"># 新留言是否需要通知 https://github.com/xCss/Valine/wiki</span></span><br><span class="line">  verify: <span class="literal">false</span> <span class="comment"># 是否需要验证，验证比较反人类建议false关闭</span></span><br><span class="line">  placeholder: 请在此输入您的留言 <span class="comment"># 默认留言框内的文字</span></span><br><span class="line">  avatar: mm <span class="comment"># 默认头像</span></span><br><span class="line">  guest_info: nick,mail <span class="comment"># 默认留言框的头部需要访问者输入的信息</span></span><br><span class="line">  pageSize: 10 <span class="comment"># pagination size #默认单页的留言条数</span></span><br></pre></td></tr></table></figure><p>重新部署</p><h4 id="评论管理"><a href="#评论管理" class="headerlink" title="评论管理"></a>评论管理</h4><p>如果想要管理评论，进入 leancloud 官网，找到 <code>控制台</code>-&gt;<code>存储</code>-&gt;<code>commet</code> 中进行管理</p><h3 id="Gitment-评论系统"><a href="#Gitment-评论系统" class="headerlink" title="Gitment 评论系统"></a>Gitment 评论系统</h3><p>gitment，它是基于 github 开发的，是依靠于 <code>GitHub Issues</code> 的评论系统，Next 主题最新已经支持安装</p><p>前提：更新 Next 主题（5.1.2 主题）</p><h4 id="注册OAuth-application"><a href="#注册OAuth-application" class="headerlink" title="注册OAuth application"></a>注册OAuth application</h4><ol><li><p>在 github 中进行注册，进入 <a href="https://github.com/settings/profile" target="_blank" rel="noopener">https://github.com/settings/profile</a></p></li><li><p>点击左侧 Developer settings</p></li><li><p>Register a new application</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Application name:#应用名称</span><br><span class="line">Homepage URL：  #网站URL(填自己的博客主页地址)</span><br><span class="line">Application description#描述</span><br><span class="line">Authorization callback URL:#网站URL(填自己的博客主页地址)</span><br></pre></td></tr></table></figure></li></ol><ol><li>注册完成之后，会得到：<code>Client ID</code> 和 <code>Client Secret</code></li></ol><h4 id="新建存放博客评论仓库"><a href="#新建存放博客评论仓库" class="headerlink" title="新建存放博客评论仓库"></a>新建存放博客评论仓库</h4><p>可以在 github 中建一个项目，专门用来存储你的博客评论</p><h4 id="配置-next-主题文件"><a href="#配置-next-主题文件" class="headerlink" title="配置 next 主题文件"></a>配置 next 主题文件</h4><p>编辑主题配置文件：themes\next\ _config.yml，找到有关 gitment 的设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gitment:   </span><br><span class="line">  <span class="built_in">enable</span>:  <span class="literal">true</span></span><br><span class="line">  mint: <span class="literal">true</span>  </span><br><span class="line">  count: <span class="literal">true</span> </span><br><span class="line">  lazy: <span class="literal">false</span>  <span class="comment">#评论懒加载，如果true，则默认不展示评论，点击按钮查看评论</span></span><br><span class="line">  cleanly: <span class="literal">false</span>  </span><br><span class="line">  language: </span><br><span class="line">  github_user: <span class="comment">#github名称</span></span><br><span class="line">  github_repo: BlogComments<span class="comment">#上一步新建存放评论的仓库名</span></span><br><span class="line">  client_id: b8bad0exxxx<span class="comment">#上面注册 OAuth Application 的 Client ID</span></span><br><span class="line">  client_secret: bcee560xxxxxx<span class="comment">#上面注册 OAuth Application 申请的 Client Secret</span></span><br><span class="line">  proxy_gateway: </span><br><span class="line">  redirect_protocol: <span class="comment"># Protocol of redirect_uri with force_redirect_protocol when mint</span></span><br></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>在设置完成之后，hexo 重新部署</p><p>每篇文章都要点击初始化评论按钮</p><h4 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h4><p>评论显示在新建存放评论的仓库中的 <code>issue</code> 中</p><h3 id="关闭某个页面的评论"><a href="#关闭某个页面的评论" class="headerlink" title="关闭某个页面的评论"></a>关闭某个页面的评论</h3><p>在页面的 <code>Front-matter</code> 中添加 <code>comments</code> 字段，设为 <code>false</code></p><p>比如标签页不想要评论，则在标签页面中做以下设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2015-12-16 17:05:24</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"tags"</span></span><br><span class="line">comments: <span class="literal">false</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> Next-评论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo - 分类或标签单词开头大写出现404</title>
      <link href="/2018/06/26/hexo-%E5%88%86%E7%B1%BB%E6%88%96%E6%A0%87%E7%AD%BE%E5%8D%95%E8%AF%8D%E5%BC%80%E5%A4%B4%E5%A4%A7%E5%86%99%E5%87%BA%E7%8E%B0404/"/>
      <url>/2018/06/26/hexo-%E5%88%86%E7%B1%BB%E6%88%96%E6%A0%87%E7%AD%BE%E5%8D%95%E8%AF%8D%E5%BC%80%E5%A4%B4%E5%A4%A7%E5%86%99%E5%87%BA%E7%8E%B0404/</url>
      <content type="html"><![CDATA[<h3 id="404"><a href="#404" class="headerlink" title="404"></a>404</h3><p>突然发现博客中，部分分类打不开，点击出现404，在标签中查看，也是小部分标签点击404，但是在所有文章中该分类下的文章都能打开，后来发现这些404的标签或分类名都是后来修改过的，原先的名称开头是大写名称</p><p>将大写字母改成小写，hexo 部署正确，但是博客上还是不正确出现404</p><p>网上查了许多资料，才发现，git中设置了大小写不敏感</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>修改 git 设置不忽略大小写</p><p>进入博客文件夹，进入 git 目录：.deploy_git ，修改 .git 文件中的配置文件 config，将ignorecase=true 改为 ignorecase=false</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim . deploy_git/.git/config</span><br><span class="line"><span class="comment"># ignorecase = true</span></span><br><span class="line">ignorecase = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>重写清空部署项目</p><p>如果还没有解决，清空部署到 github 上的文件，重新发布：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> .deploy_git</span><br><span class="line">git rm -rf *</span><br><span class="line">git commit -m <span class="string">'clean all file'</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>进入博客文件夹，用 hexo 重新生成部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 404 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习（十五）内部类</title>
      <link href="/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>将一个类定义在另一个类的内部，这个类就是内部类</p><p>内部类在外部类中的位置不同，使用也有所不同</p><p>位置：  </p><ol><li>成员内部类：在外部类的成员位置处，与成员变量、方法位置并列</li><li>局部内部类：在外部类的成员方法中定义，类似局部变量</li></ol><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><ul><li>成员内部类可以直接访问外部类的成员，包括私有成员</li><li>外部类访问成员内部类成员，必须创建成员内部类对象</li></ul><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num=<span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"num="</span>+num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Outer.Inner o = <span class="keyword">new</span> Outer().new Inner();</span><br><span class="line">o.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>一般的类是不能用 static 修饰的，但是内部类可以用 static 修饰，因为内部类可以看成是外部类的一个成员，而类的成员可以是静态成员</p><h5 id="静态内部类案例"><a href="#静态内部类案例" class="headerlink" title="静态内部类案例"></a>静态内部类案例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> numStatic=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//错误，静态内部类不能调用外部非静态成员，只能调用静态成员</span></span><br><span class="line"><span class="comment">//System.out.println("show() - num="+num);</span></span><br><span class="line">System.out.println(<span class="string">"show() - numStatic="</span>+numStatic);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"showStatic() - numStatic="</span>+numStatic);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Outer.Inner inner = <span class="keyword">new</span> Outer.Inner();</span><br><span class="line">inner.show();</span><br><span class="line">inner.showStatic();</span><br><span class="line"><span class="comment">//static 方法：showStatic() 的另一种调用方式，直接调用</span></span><br><span class="line">Outer.Inner.showStatic();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h4><h5 id="通过外部类调用成员内部类方法"><a href="#通过外部类调用成员内部类方法" class="headerlink" title="通过外部类调用成员内部类方法"></a>通过外部类调用成员内部类方法</h5><ul><li>非静态内部类：外部类.内部类 对象名 = new 外部类().new 内部类();</li><li>静态内部类<ul><li>调用静态方法：外部类.内部类.静态方法()；</li><li>调用非静态方法：外部类.内部类 对象名 = new 外部类.内部类(); 对象名.方法()；</li></ul></li></ul><h5 id="在内部类中访问变量"><a href="#在内部类中访问变量" class="headerlink" title="在内部类中访问变量"></a>在内部类中访问变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Outer.Inner inner = <span class="keyword">new</span> Outer().new Inner();</span><br><span class="line">inner.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> numStatic=<span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line">System.out.println(<span class="string">"调用内部类方法的局部变量："</span>+num);</span><br><span class="line">System.out.println(<span class="string">"调用内部类的成员变量："</span>+<span class="keyword">this</span>.num);</span><br><span class="line">System.out.println(<span class="string">"调用外部类的成员变量方式1："</span>+<span class="keyword">new</span> Outer().num);</span><br><span class="line">System.out.println(<span class="string">"调用外部类的成员变量方式2："</span>+Outer.<span class="keyword">this</span>.num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在这个例子中，访问外部类的成员变量方式2中，只有在内部类是非静态时才可以使用，如果是静态，则不能调用</p><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><ul><li>可以直接访问外部类的成员；</li><li>在局部方法内，创建内部类对象，用对象调用内部类的方法</li><li>局部内部类只能访问被 final 修饰的局部变量<ul><li>原因：因为局部变量是随着方法的调用而调用，调用完毕就销毁，而创建的内部类对象在堆内存中不会立即被销毁，此时还是要保留内部类的方法，所以方法调用的变量也要一直保存，所以需要使用关键字 final 使得变量成为常量，数值一直保留不被销毁</li></ul></li></ul><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类，就是一个类的简化写法</p><p>前提：存在一个类或接口，这个类可以是具体类或抽象类</p><p>格式：new 类名/接口名(){重写方法}</p><p>本质：匿名内部类，就是继承了已经存在的一个类或实现了已经存在的一个接口的匿名对象(new了一个没有名字的对象)，</p><h4 id="匿名内部类调用"><a href="#匿名内部类调用" class="headerlink" title="匿名内部类调用"></a>匿名内部类调用</h4><p>匿名方法实现的接口中单个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Inter() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"show 匿名内部类..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Outer o = <span class="keyword">new</span> Outer();</span><br><span class="line">o.method();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名方法实现的接口中有多个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Inter i = <span class="keyword">new</span> Inter() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"show 匿名内部类..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"show2 匿名内部类..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">i.show();</span><br><span class="line">i.show2();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Outer o = <span class="keyword">new</span> Outer();</span><br><span class="line">o.method();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类注意事项"><a href="#匿名内部类注意事项" class="headerlink" title="匿名内部类注意事项"></a>匿名内部类注意事项</h4><ul><li>匿名内部类不能有构造方法</li><li>匿名内部类不能定义任何静态成员、方法和类</li><li>只能创建匿名内部类的一个实例</li><li>匿名内部类也属于局部内部类</li></ul><h4 id="考题"><a href="#考题" class="headerlink" title="考题"></a>考题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span> </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Inter <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Inter() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Hello World!!!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Outer.method().show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 内部类 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习（十四）抽象类与接口</title>
      <link href="/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/"/>
      <url>/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>java中，对象都是用类表示的，但是有的类却不能表示描述对象；比如，动物，这个本身不是一个具体的事物，猫是动物，狗也是动物，所以动物不是对象，他是抽象的，那动物在java中怎么表示，这时候就用到抽象类了</p><p>我们可以将动物定义为抽象的，将所有是动物的行为给一个声明，而不给出具体实现，这时动物类就可以被定义为一个抽象类</p><p>java中，将不是具体的对象定义为抽象类，不是具体功能的方法定义成抽象方法</p><h4 id="抽象类定义"><a href="#抽象类定义" class="headerlink" title="抽象类定义"></a>抽象类定义</h4><p>使用关键字 abstract 定义抽象类和抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">methodDemo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类是特殊的类，一般是为了被继承，只声明方法，不实现，方法的具体实现由子类实现</p><h4 id="抽象类特点"><a href="#抽象类特点" class="headerlink" title="抽象类特点"></a>抽象类特点</h4><ul><li>抽象类和抽象方法必须被 abstract 修饰</li><li>抽象类中可以有抽象方法和非抽象方法，但是如果一个类中有抽象方法，这个类必须定义为抽象类</li><li>自己不能被实例化，不能创建对象，但是可以通过多态方式用子类实例化</li><li>抽象类中有构造方法，但是不能用于实例化，是为了子类访问父类数据的初始化</li><li>抽象方法只声明，没有实现，没有方法体；只能由子类重写实现</li><li>抽象的子类<ul><li>如果不想重写抽象类的抽象方法，将子类定义为抽象类</li><li>子类是一个普通的类，必须重写抽象类的所有抽象方法</li></ul></li><li>抽象方法中的构造方法和 static 类方法不能声明为抽象方法</li></ul><p>抽象类的方法，抽象方法，是要求子类必须做的事情，非抽象方法，是提高代码复用性，子类可以使用也可以不使用</p><h4 id="抽象类的注意事项"><a href="#抽象类的注意事项" class="headerlink" title="抽象类的注意事项"></a>抽象类的注意事项</h4><p>abstract 不能和关键字 private、final、static组合</p><ul><li>被 private和final 修饰的方法，不能被子类重写，但是被 abstract 修饰的方法必须被子类重写，会冲突</li><li>被 static 修饰的方法，能被类直接调用，但是 abstract 修饰的方法只是声明，而没有实现，不能调用执行</li></ul><h4 id="抽象类例子"><a href="#抽象类例子" class="headerlink" title="抽象类例子"></a>抽象类例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Animal aDog = <span class="keyword">new</span> Dog(<span class="string">"狗狗"</span>,<span class="number">1</span>);</span><br><span class="line">aDog.eat();</span><br><span class="line">Animal aCat = <span class="keyword">new</span> Cat(<span class="string">"猫猫"</span>,<span class="number">1</span>);</span><br><span class="line">aCat.eat();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name,age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"狗吃骨头"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name,age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"猫吃鱼"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>抽象类，是将不是具体的事物定义为抽象类，但是有共有的特性，比如动物，都有吃，叫等行为，而后天形成的一些行为，有的动物有，有的动物没有，这时用到接口</p><p>接口是所有抽象方法的集合</p><h4 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h4><p>使用关键字 interface 定义，代替类关键字 class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceName</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>接口是抽象类的扩展但不是抽象类；从定义方式可以看出，接口没有关键字 class，说明接口并不是一个类</p><h4 id="接口的特点"><a href="#接口的特点" class="headerlink" title="接口的特点"></a>接口的特点</h4><ul><li>接口访问权限默认 public ，如果显示指为 private 或 protected</li><li>接口中的成员变量会被默认指定为 “public static final”，所以接口中的方法都是常量</li><li>接口中的所有方法都是抽象的，必须是声明，不能有实现的方法</li><li>接口不能被实例化，也没有构造方法</li><li>接口的实现类使用 implements 关键字实现接口，并且必须实现接口中的所有方法</li></ul><h4 id="类和接口的关系"><a href="#类和接口的关系" class="headerlink" title="类和接口的关系"></a>类和接口的关系</h4><p>类与类：单继承，多层继承<br>类与接口：类实现接口，可以多实现<br>接口和接口：可以单继承，也可以多继承</p>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 抽象类 </tag>
            
            <tag> 接口 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习（十三）三大特性之 - 多态</title>
      <link href="/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B-%E5%A4%9A%E6%80%81/"/>
      <url>/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B-%E5%A4%9A%E6%80%81/</url>
      <content type="html"><![CDATA[<p>多态，是同一个对象，在不同时刻表现不同的行为</p><p>多态的前提：</p><ul><li>存在继承</li><li>子类重写父类方法</li><li>父类引用指向子类对象：父 f = new 子();（向上转型）</li></ul><h3 id="多态的使用"><a href="#多态的使用" class="headerlink" title="多态的使用"></a>多态的使用</h3><h4 id="多态实例"><a href="#多态实例" class="headerlink" title="多态实例"></a>多态实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"show Fu"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"static Fu"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fuMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"fu method"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> num2 = <span class="number">200</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"show zi"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ziMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"zi method"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"static zi"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Fu fu = <span class="keyword">new</span> Zi();</span><br><span class="line">System.out.println(fu.num);</span><br><span class="line"><span class="comment">//System.out.println(fu.num2);//编译不通过</span></span><br><span class="line"><span class="comment">//fu.ziMethod();//编译不通过，</span></span><br><span class="line">fu.fuMethod();</span><br><span class="line">fu.showMethod();</span><br><span class="line">fu.staticMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">fu method</span><br><span class="line">show zi</span><br><span class="line">static Fu</span><br></pre></td></tr></table></figure><p>在上面的程序中，使用多态，fu 加载变量num时，先查看父类中是否有这个变量，发现有 num ，则调用；调用子类特有变量 num2 和 ziMethod() 方法，因为 fu 是向上转型的，转到父类后查看没有变量 num2 和 ziMethod()，则编译不通过；加载父类特有的方法 fuMethod() 时，在子类中找不到，向上转型到父类中，查看有次方法，便调用父类的方法 fuMethod()；加载子类重写父类的方法时，在子类中找到重写后的方法 showMethod()，则直接调用</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>指向子类的父类引用变量，向上转型，所以只能调用父类中有的变量和方法，对于父类不存在子类中特有的方法，则不能访问调用；对于子类没有而父类中有的变量和方法，可以访问调用；如果子类中重写了父类中的方法，那么调用的是子类中重写后的方法</p><p>多态访问成员特点：</p><ul><li>构造方法：创建子类对象时访问父类构造方法，对父类数据进行初始化</li><li>成员变量：编译看左边，运行看左边</li><li>成员方法：编译看左边，运行看右边</li><li>静态方法：编译看左边，运行看左边</li></ul><h3 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h3><ul><li>提高了代码的维护性</li><li>提高了代码的扩展性</li></ul><h3 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h3><p>只能使用父类的成员，而不能使用子类的特有功能</p><p>解决：向下转型，将父类的引用强制转换为子类的引用</p><p>Fu fu = new Fu();<br>Zi zi = (Zi)fu;</p><h3 id="java-多态经典案例"><a href="#java-多态经典案例" class="headerlink" title="java 多态经典案例"></a>java 多态经典案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(D obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"A and D"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(A obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"A and A"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(B obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"B and B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(A obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"B and A"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a1 = <span class="keyword">new</span> A();</span><br><span class="line">        A a2 = <span class="keyword">new</span> B();</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        D d = <span class="keyword">new</span> D();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"1--"</span> + a1.show(b));</span><br><span class="line">        System.out.println(<span class="string">"2--"</span> + a1.show(c));</span><br><span class="line">        System.out.println(<span class="string">"3--"</span> + a1.show(d));</span><br><span class="line">        System.out.println(<span class="string">"4--"</span> + a2.show(b));</span><br><span class="line">        System.out.println(<span class="string">"5--"</span> + a2.show(c));</span><br><span class="line">        System.out.println(<span class="string">"6--"</span> + a2.show(d));</span><br><span class="line">        System.out.println(<span class="string">"7--"</span> + b.show(b));</span><br><span class="line">        System.out.println(<span class="string">"8--"</span> + b.show(c));</span><br><span class="line">        System.out.println(<span class="string">"9--"</span> + b.show(d));      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1--A and A</span><br><span class="line">2--A and A</span><br><span class="line">3--A and D</span><br><span class="line">4--B and A</span><br><span class="line">5--B and A</span><br><span class="line">6--A and D</span><br><span class="line">7--B and B</span><br><span class="line">8--B and B</span><br><span class="line">9--A and D</span><br></pre></td></tr></table></figure><p>在以上程序中，</p><h4 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h4><h5 id="4的结果分析："><a href="#4的结果分析：" class="headerlink" title="4的结果分析："></a>4的结果分析：</h5><p>很多人以为会输出的是 “B and B”，调用的是B中找show(B)方法！  </p><p>为什么没有直接在B中找show(B)方法调用呢，因为调用方法，首先看是谁调用的，a2的类型是A，而不是B，所以在查找方法时，先进入A类查找，而B中的方法 show(B)，是B类中特有的方法，所以不会调用</p><ol><li>a2是A的引用，但是指向的是B类型</li><li>a2调用方法 show(b)，方法参数是B类型</li><li>查看引用类型A是否有父类，没有父类，然后在引用类型A中看是否有此方法</li><li>A中没有参数为B类型的方法，然后找是否有参数为B的父类的方法</li><li>B有父类A，找到方法 show(A)</li><li>然后查看a2的指向类型B中是否重写过该方法</li><li>在B中找到重写A的方法show(A)，所以最后调用的是B中的方法，输出 “B and A ”</li></ol><h5 id="5的结果分析："><a href="#5的结果分析：" class="headerlink" title="5的结果分析："></a>5的结果分析：</h5><ol><li>a2是A的引用，但是指向的是B类型</li><li>a2调用方法 show(c)，方法参数是C类型；</li><li>查看引用类型A是否有父类，没有父类，然后在引用类型A中看是否有此方法</li><li>A中没有参数为C类型的方法，然后找是否有参数为C的父类的方法</li><li>C有父类B，没有参数为B类型的方法；B有父类A，有参数为A类型的方法</li><li>然后查看a2的指向类型B中是否重写过该方法</li><li>在B中找到重写A的方法show(A)，所以最后调用的是B中的方法，输出 “B and A ”</li></ol><h5 id="修改程序"><a href="#修改程序" class="headerlink" title="修改程序"></a>修改程序</h5><h6 id="修改1"><a href="#修改1" class="headerlink" title="修改1"></a>修改1</h6><p>如果在上面的程序中加上A的父类：Fu ，添加方法show(C obj)；其余不变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(C obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"Fu and C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，5的结果会跟之前有所不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5--Fu and C</span><br></pre></td></tr></table></figure><ol><li>a2 是 A 的引用，但是指向的是B类型</li><li>a2 调用方法 show(c)，方法参数是C类型；</li><li>在引用类型A中，查找方法 show(C) 是否存在；</li><li>找不到方法 show(C)，查看引用类型A是否有父类</li><li>有父类Fu，然后在用用类型A的父类Fu中看是否有此方法</li><li>Fu 中有参数为 C 的方法 show(C)</li><li>然后查看指向类型 B 中是否有重写后的方法</li><li>B中没有重写方法 show(C)，最终调用 Fu 类中的方法 show(C)：输出 “ Fu and C ”</li></ol><h6 id="修改2"><a href="#修改2" class="headerlink" title="修改2"></a>修改2</h6><p>如果在上面的程序中加上A的父类：Fu ，添加方法show(C obj)；其余不变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(C obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"Fu and C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(C obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"A and C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，5的结果会跟之前又有所不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5--A and C</span><br></pre></td></tr></table></figure><ol><li>a2 是 A 的引用，但是指向的是B类型</li><li>a2 调用方法 show(c)，方法参数是C类型；</li><li>在引用类型A中，查找方法 show(C) 是否存在；</li><li>找到方法 show(C)，然后查找A的子类：指向类型 B 中是否有重写 show(C) 的方法</li><li>B中没有重写方法 show(C)，调用 A 类中的方法 show(C)：输出 “ A and C ”</li></ol><h6 id="修改3"><a href="#修改3" class="headerlink" title="修改3"></a>修改3</h6><p>如果在B中重写方法 show(C)，那么结果又会不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(C obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">"B and C"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出 “ B and C ” ！！！</p><p>在之前的分析中，5中查看 B 中是否有重写后的方法，之前的程序中B中不存在重写方法，现在B中加上重写方法 show(C)，所以最终调用的是指向类型 B 的重写方法</p><h4 id="可以得出："><a href="#可以得出：" class="headerlink" title="可以得出："></a>可以得出：</h4><p>在多态中，父类对象作为引用变量，子类对象作为被引用对象类型时，引用变量调用的方法必须是父类（引用对象）中定义过的方法，不能调用父类中没有而子类中有的方法！！！</p><p>调用的情况有以下几种：</p><ul><li>被调用方法仅在父类中被定义，而子类中没有被定义，那么调用的方法是父类中的方法</li><li>被调用方法在父类中被定义，在子类中被重写，那么调用的是子类中重写后的方法</li></ul><h4 id="多态调用顺序"><a href="#多态调用顺序" class="headerlink" title="多态调用顺序"></a>多态调用顺序</h4><p>前提：</p><ul><li>被引用变量类型继承引用变量类型</li><li>先看引用变量类型和被引用对象类型（指向类型）</li><li>调用方法必须是引用变量类型对象中存在的方法</li></ul><p>调用顺序：</p><p>this-&gt;引用类型，zi-&gt;被引用类型</p><p>this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)</p><p>在查找方法时，按这四个顺序查找，当某个查找到之后，还要进入被引用类型 zi 中查看是否有重写方法</p><ol><li>进入 this 查找 show(O)<ul><li>有，进入被引用类型  zi 中，查找是否存在重写方法 show(O)<ul><li>有，调用 zi 的重写后的方法 show(O)，结束</li><li>没有，调用 this 中的方法  this.show(O)，结束</li></ul></li><li>没有，执行步骤2</li></ul></li><li>查找 this 是否有父类 super<ul><li>有，进入 super 中 查找是否存在方法 super.show(O)<ul><li>有，进入被引用类型 zi 中，查找是否存在重写方法 show(O)<ul><li>有，调用 zi 的重写后的方法 show(O)，结束</li><li>没有，调用 super 中的方法 super.show(O)，结束</li></ul></li><li>没有，执行步骤3</li></ul></li><li>没有，执行步骤3</li></ul></li><li>查找 this 中是否有 this.show((super)O)，（方法参数是调用方法参数的父类的方法）<ul><li>有，进入被引用类型  zi 中，查找是否存在重写方法 show((super)O)<ul><li>有，调用 zi 的重写后的方法 show((super)O)，结束</li><li>没有，调用 this 中的方法  this.show((super)O)，结束</li></ul></li><li>没有，执行步骤4，（如果是从2到3，那么不会出现这种情况）</li></ul></li><li>查找 this 中是否有 super.show((super)O)<ul><li>有，进入被引用类型  zi 中，查找是否存在重写方法 show((super)O)<ul><li>有，调用 zi 的重写后的方法 show((super)O)，结束</li><li>没有，调用 super 中的方法  super.show((super)O)，结束</li></ul></li></ul></li></ol>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 多态 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习（十二）重写和重载</title>
      <link href="/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD/"/>
      <url>/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD/</url>
      <content type="html"><![CDATA[<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>重写，是子类有父类的情况下，用于子类对父类的方法进行重写</p><p>重写是子类对父类的非私有方法重新编写方法内容，方法的返回值和形参都与父类的方法相同</p><p>如果在重写过程中，还需要引用父类中的方法功能，可以使用 super 引用父类方法</p><h4 id="重写规则"><a href="#重写规则" class="headerlink" title="重写规则"></a>重写规则</h4><p>@override，重写，也就是覆盖</p><ul><li>重写方法的方法名和方法参数列表必须与被重写的方法完全相同</li><li>访问修饰符的访问权限必须大于被重写方法的访问修饰符权限，但是不能是 private</li><li>重写方法的返回值必须与被重写方法返回值相同</li><li>重写方法若是抛出异常，那么异常必须是与被重写方法抛出的异常一致或是异常的子类</li><li>声明为final的方法不能被重写；声明为static的方法不能被重写，但是能够被再次声明</li></ul><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>重载是指同一个类或子类对父类的都可以</p><p>重载，指两个方法的方法名称相同，但是方法参数列表不同</p><h4 id="重载规则"><a href="#重载规则" class="headerlink" title="重载规则"></a>重载规则</h4><p>overload，一般是用于同一个类中</p><ul><li>重载的方法的方法名称必须相同，而参数列表不能相同</li><li>不同的参数列表，可以是参数的个数不同，参数的类型不同，或参数的顺序不同</li><li>方法的返回值没有要求，可以相同，也可以不同</li><li>方法的访问修饰符可以不同，也可以相同</li><li>方法抛出的异常也可以不同</li></ul><h3 id="重写和重载的区别"><a href="#重写和重载的区别" class="headerlink" title="重写和重载的区别"></a>重写和重载的区别</h3><table><thead><tr><th>区别</th><th>重载</th><th>重写</th></tr></thead><tbody><tr><td>参数列表</td><td>必须不同</td><td>都可以</td></tr><tr><td>返回值</td><td>都可以</td><td>必须相同</td></tr><tr><td>异常</td><td>都可以</td><td>必须相同或是子类</td></tr><tr><td>访问修饰符</td><td>都可以</td><td>必须相同或是权限更大</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 重写 </tag>
            
            <tag> 重载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习（十一）三大特性之 - 继承</title>
      <link href="/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B-%E7%BB%A7%E6%89%BF/"/>
      <url>/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B-%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>java 是面向对象的，对象与对象之间有时会有很多相同的行为以及部分不同的行为，如果两个不同的对象，要有相同的行为，写两个类会出现代码的复用，所以出现了继承</p><p>继承，是子与父的关系，子类继承父类，所以子类可以拥有父类下的成员和方法，具有跟父类相同的行为，而且子类还可以拥有属于自己独特的行为</p><p>继承可以实现代码的复用，使得子类将父类作为基础，在父类拥有的基础上添加新的功能</p><h4 id="继承格式"><a href="#继承格式" class="headerlink" title="继承格式"></a>继承格式</h4><p>使用 extends 关键字进行对类的继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 父类</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父类，又称基类或超类；子类，可以称为派生类</p><h4 id="使用继承的情况"><a href="#使用继承的情况" class="headerlink" title="使用继承的情况"></a>使用继承的情况</h4><p>继承并不是随意使用的，一般情况下，只有子类需要父类的所有方法，才进行继承</p><p>子类对父类是“是”的关系，需要继承，如果是“像”的关系，不需要继承；在父类中不需要考虑子类的特殊性，只需要写一些通用的方法</p><p>如：中国人是人，name中国人可以继承人；大卡车像汽车，都有轮胎，但是大卡车不是汽车，所以不能继承</p><p>对于继承，可以将多个类的共有方法和属性抽取出来，定义成父类，让这些类继承，然后再各自实现自己的新成员和独有行为方法</p><h4 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h4><ul><li>子类拥有父类除 private 之外的所有属性、方法；不能继承父类的构造方法，默认调用无参构造方法，或使用super显式调用</li><li>只能单继承：一个子类只能继承一个父类</li><li>可以多重继承：可以多个类同时继承一个父类</li><li>子类中可以用自己的独特方式实现父类的方法，并且实现自己的属性和方法，对父类进行扩展</li></ul><h3 id="继承的两种方式"><a href="#继承的两种方式" class="headerlink" title="继承的两种方式"></a>继承的两种方式</h3><p>子类继承父类，在子类中会有两种方式使得子类与分类不同</p><ol><li>子类中添加新的成员变量或成员方法</li><li>覆盖重写父类的方法</li></ol><h4 id="添加新的成员"><a href="#添加新的成员" class="headerlink" title="添加新的成员"></a>添加新的成员</h4><p>如果父类中没有子类需要的方法，那么子类中可以添加自己的成员变量或成员方法</p><h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h4><p>如果父类中方法的功能不能满足子类，那子类可以覆盖父类的方法，重写方法的功能，这也叫重写；</p><p>方法名称和方法参数必须相同，使用 @Override 注解；</p><p>如果在子类重写父类的方法中，还想要调用父类的这个方法，可以使用 super 调用</p><p>覆盖父类的方法，方法名、方法参数和父类中的方法必须一致</p><h4 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h4><p>在子类中调用方法：在子类中查找是否有该方法，有-直接执行子类方法；没有-进入父类查找方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodShow</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"methodShow father"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodFather</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"methodFather"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodShow</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"methodShow son"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodSon</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"methodSon"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        son.methodShow();</span><br><span class="line">        son.methodSon();</span><br><span class="line">        son.methodFather();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">methodShow son</span><br><span class="line">methodSon</span><br><span class="line">methodFather</span><br></pre></td></tr></table></figure><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>子类除了不能继承父类的 private 方法，还有构造器也不能继承，</p><p>虽然不能继承，但是子类必须调用父类的构造器：</p><ul><li>父类和子类中都没有构造器或者有无参构造器：子类会默认调用父类无参构造器，程序运行系统自动调用</li><li>父类中没有无参构造器，只有有参构造器：<ul><li>给父类添加无参构造方法</li><li>子类在构造器中用 super(参数) 显示调用父类有参构造器</li></ul></li></ul><h3 id="子类继承父类后初始化的顺序"><a href="#子类继承父类后初始化的顺序" class="headerlink" title="子类继承父类后初始化的顺序"></a>子类继承父类后初始化的顺序</h3><p>在子类继承父类后，在子类初始化之前，必须进行父类的初始化</p><p>类的初始化过程：静态代码块-&gt;构造代码块-&gt;构造方法</p><p>存在子类和父类：</p><p>父类static -&gt; 子类static -&gt; 父类构造代码块、成员变量 -&gt; 父类构造器 -&gt; 子类构造代码块、成员变量-&gt;子类构造器</p><ol><li>加载子类，发现子类继承父类</li><li>进入父类，初始化父类的 static 部分</li><li>然后进入子类，初始化子类的 static 部分</li><li>执行 new 子类时，会先 new 父类，初始化父类的成员变量，然后调用父类构造器</li><li>接着调用子类自身的构造器</li></ol><h4 id="eg1"><a href="#eg1" class="headerlink" title="eg1"></a>eg1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"fu 静态代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"fu 构造代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Fu</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"fu 构造器"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"zi 静态代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"zi 构造代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Zi</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"zi 构造器"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Zi();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fu 静态代码块</span><br><span class="line">zi 静态代码块</span><br><span class="line">fu 构造代码块</span><br><span class="line">fu 构造器</span><br><span class="line">zi 构造代码块</span><br><span class="line">zi 构造器</span><br></pre></td></tr></table></figure><ol><li>先进入 TestDemo，运行 main() </li><li>加载 Zi 类，Zi 类继承了 Fu 类，所以先初始化 Fu 类，初始化静态代码块；</li><li>加载子类，初始化静态代码块</li><li>进入子类构造器，默认先调用父类构造器，去 Fu 中初始化创建对象</li><li>进入 Fu 初始化构造代码，然后 new Fu，调用 Fu 构造器</li><li>回到子类，初始化子类 Zi 的构造代码块，然后执行 Zi 的构造器</li></ol><h4 id="eg2"><a href="#eg2" class="headerlink" title="eg2"></a>eg2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">Animal animalP = <span class="keyword">new</span> Animal(<span class="string">"person and animal"</span>);</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"person static"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"person constructor"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Student();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">Animal animalS = <span class="keyword">new</span> Animal(<span class="string">"cat"</span>);</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"student static1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"student constructor"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"student static2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"animal 构造代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"animal:"</span>+s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"animal static"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">person static</span><br><span class="line">student static1</span><br><span class="line">student static2</span><br><span class="line">animal static</span><br><span class="line">animal:person and animal</span><br><span class="line">person constructor</span><br><span class="line">animal:cat</span><br><span class="line">student 构造代码块</span><br><span class="line">student constructor</span><br></pre></td></tr></table></figure><p>在上面的程序中，初始化顺序是这样的：</p><ol><li><p>先加载 Person 类，初始化 Person 的 static 部分：“person static”</p></li><li><p>运行 main() 方法，运行子类 Student ，初始化 static 部分，按照static 在程序的先后顺序：“student static1，student static2”</p></li><li><p>进行 new Student()，但是有父类 Person 存在，所以默认先调用父类 Person 无参构造器：new Person()，在 new 之前，初始化 Person 的成员变量：animalP</p></li><li><p>初始化 animalP：进入 Animal 初始化 static：animal static；调用 new Animal(“person and animal”)：“animal:person and animal”</p></li><li><p>接着父类 Person 成员变量初始化完成后，调用父类无参构造器：person constructor</p></li><li><p>父类 new 完成，回到子类 Student：初始化子类成员变量：animalS，此时 Animal 已经加载过，所以 static 部分不再执行，然后直接调用 new Animal(“cat”)：“animal:cat”</p></li><li><p>Student 初始化完成，调用子类无参构造器：“student constructor”</p></li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>记住，</p><p>在调用之前，加载类时最先初始化父类、子类中的 static 代码块！！！</p><p>在子类中无论显式使用 super() 还是系统默认调用 super() 调用父类构造方法，都会先进入父类初始化父类的构造代码块和成员变量，然后再调用父类构造器！调用完成之后，在子类中同样是先初始化子类中的构造代码块和成员变量</p>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习（十）static 关键字</title>
      <link href="/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%EF%BC%89static-%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%EF%BC%89static-%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      <content type="html"><![CDATA[<p>static关键字是静态修饰符</p><h3 id="static-的含义"><a href="#static-的含义" class="headerlink" title="static 的含义"></a>static 的含义</h3><p>java中，jvm加载一个类，会动态的给类分配内存空间，根据变量、方法的特性决定内存空间的周期以及销毁时间等  </p><p>通常static表示静态，不是动态，所以在java中，一个类在程序进行编译时分配内存时，如果类中存在 static ，那么 jvm 会给 static 修饰的内容分配一块空间，这块内存空间会随着类一直存在，并且在程序运行期间，所有类的所有实例都可以访问这块内存空间，直到类运行结束，才会释放，</p><h3 id="static-用法"><a href="#static-用法" class="headerlink" title="static 用法"></a>static 用法</h3><p>在要修饰的成员变量或方法上直接使用 static 关键字进行修饰</p><p>被static吸烟室的成员，再累中可以直接通过类名进行访问：类名.成员</p><h4 id="static-变量"><a href="#static-变量" class="headerlink" title="static 变量"></a>static 变量</h4><p>static修饰变量叫做静态变量</p><p>一般类的普通变量，也叫实例变量，jvm 在编译类时，会根据实例来产生实例变量分配内存，如果一个类中有一个实例变量，但是这个类被实例化了两次，那么这两个实例使用类中的实例变量，jvm 会产生两个实例变量的内存空间；</p><p>一个静态变量，在 jvm 开始加载类时会进行初始化，这时会加载静态变量并为这个变量分配唯一一个内存空间，在类中的所有实例都共享这一个空间，使用时通过类名.访问；因为静态变量是唯一的内存空间，所以只要类的一个实例修改这个变量，那么以后其他实例访问这个静态变量，结果都是之前修改过的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChinaPerson</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String nation = <span class="string">"China"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">personInfo</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">System.out.println(name+<span class="string">" 是"</span>+ ChinaPerson.nation);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">ChinaPerson cp1 = <span class="keyword">new</span> ChinaPerson();</span><br><span class="line">cp1.personInfo(<span class="string">"张三"</span>);</span><br><span class="line">ChinaPerson cp2 = <span class="keyword">new</span> ChinaPerson();</span><br><span class="line">cp2.personInfo(<span class="string">"李四"</span>);</span><br><span class="line">cp2.nation = <span class="string">"英国"</span>;</span><br><span class="line">ChinaPerson cp3 = <span class="keyword">new</span> ChinaPerson();</span><br><span class="line">cp3.personInfo(<span class="string">"王五"</span>);</span><br><span class="line">ChinaPerson cp4 = <span class="keyword">new</span> ChinaPerson();</span><br><span class="line">cp4.personInfo(<span class="string">"孙悟空"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">张三 是China人</span><br><span class="line">李四 是China人</span><br><span class="line">王五 是英国人</span><br><span class="line">孙悟空 是英国人</span><br></pre></td></tr></table></figure><p>在以上程序中，nation 变量被 static 修饰，所以程序在编译时 jvm 会给 nation 变量分配一个内存空间  ChinaPerson 的所有的实例都共享这个变量的空间；cp2 在访问过 nation 变量后，修改值为“英国”，在之后 cp3 和 cp4 再进行访问 nation 时，还是同样的一个空间，但是值已经被修改，所以这两个实例拿到的变量值是“英国”</p><h4 id="static-方法"><a href="#static-方法" class="headerlink" title="static 方法"></a>static 方法</h4><p>static 修饰的方法，通过类名.调用，  </p><p>每一个类的实例都可以进行共享调用，不针对某个实例，所以静态方法中不能使用关键字this、super等；记住：this指得是对象，随着对象的创建而创建；static是随着类加载二加载，是唯一的</p><p>静态方法只能访问类的静态成员变量和静态成员方法；但是非静态方法能访问所有静态非静态的变量和方法  </p><p>比如，类的 main 方法，就不能直接通过类名访问静态的成员变量，因为 main() 是 static 的</p><h4 id="static-代码块"><a href="#static-代码块" class="headerlink" title="static 代码块"></a>static 代码块</h4><p>被static 修饰的一段{}包括起来的代码块，再类中独立存在，不能放在方法体内</p><p>jvm加载类的时候回首先加载执行这些独立的代码块，如果类中存在多个静态代码块，那么会按照代码块存在类中的先后顺序进行加载</p><h3 id="static-代码块和-static-方法的区别"><a href="#static-代码块和-static-方法的区别" class="headerlink" title="static 代码块和 static 方法的区别"></a>static 代码块和 static 方法的区别</h3><ul><li>static 代码块<ul><li>代码块在 jvm 加载类时便会初始化并且执行代码块语句</li></ul></li><li>static 方法<ul><li>方法时在 jvm 加载类时初始化加载，但是不执行，只有在被调用时才会执行语句；</li><li>调用不需要类实例化对象，可以直接使用类名进行调用</li></ul></li></ul><h3 id="static-变量和普通成员变量"><a href="#static-变量和普通成员变量" class="headerlink" title="static 变量和普通成员变量"></a>static 变量和普通成员变量</h3><ul><li>static 变量<ul><li>加载：类加载时初始化并创建内存空间，在类从创建到完成过程中只有一个内存空间</li><li>内存：类的所有实例都会共享一个static变量空间，他属于类、</li><li>生命周期：静态变量的生命周期跟类相同，随着类的创建而创建，随着类的销毁而销毁</li><li>调用：通过类名直接调用，也可以通过类的实例对象调用</li></ul></li><li>普通成员变量<ul><li>加载：类加载后，类的实例化对象调用时才会创建内存空间</li><li>内存：有几个类的实例调用变量，变量就会有几个内存空间，普通变量是被实例私有，是属于实例对象</li><li>生命周期：成员变量是随着对象创建而创建，随着对象的销毁而消失</li><li>调用：只能通过类的实例对象调用</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> static 关键字 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习（九）构造方法</title>
      <link href="/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
      <url>/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="什么是构造方法"><a href="#什么是构造方法" class="headerlink" title="什么是构造方法"></a>什么是构造方法</h3><p>构造方法：是类中的一个特殊方法  </p><ul><li>方法名与类名相同</li><li>没有返回值，void也没有</li><li>可以有访问修饰符，但是非访问修饰符不能修饰，如static、final等</li><li>构造方法不能被子类继承重写</li></ul><h3 id="构造方法的作用"><a href="#构造方法的作用" class="headerlink" title="构造方法的作用"></a>构造方法的作用</h3><h4 id="进行初始化"><a href="#进行初始化" class="headerlink" title="进行初始化"></a>进行初始化</h4><p>对对象进行初始化，实例化对象，给对象赋值  </p><p>通常我们要使用一个对象，就要将对象实例化：用new实例化对象，这个 new 就是在调用构造器来创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> studentId;</span><br><span class="line"><span class="comment">//无参构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age,<span class="keyword">int</span> studentId)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span> name = name;</span><br><span class="line"><span class="keyword">this</span> age = age;</span><br><span class="line"><span class="keyword">this</span> studentId = studentId;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><p>有时候会发现一个类中并没有写构造方法，但是可以进行对象的实例化，如：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Stirng[] args)</span></span>&#123;</span><br><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为如果类中没有指定构造方法，那么系统会默认给类添加无参的public修饰的构造方法，方法体为空，但是如果用户自己定义了构造方法，系统将不会再提供空构造方法</p><h3 id="构造器调用构造器"><a href="#构造器调用构造器" class="headerlink" title="构造器调用构造器"></a>构造器调用构造器</h3><p>在一个类中有多个构造方法时，可以进行构造方法调用其他构造方法，使用this关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> String s;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"this is s : "</span>+s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="string">"tom"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="string">"tom"</span>);</span><br><span class="line"><span class="keyword">this</span>();<span class="comment">//错误</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同一个构造方法中不能多次使用this调用构造方法，只允许调用一次，而且必须放在方法的第一行</p>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 构造方法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习（八）this、super关键字</title>
      <link href="/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AB%EF%BC%89this%E3%80%81super%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AB%EF%BC%89this%E3%80%81super%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      <content type="html"><![CDATA[<h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h3><p>this 关键字，代表当前对象，也就是指向对象本身的指针</p><h3 id="this-的用法"><a href="#this-的用法" class="headerlink" title="this 的用法"></a>this 的用法</h3><h4 id="区分成员变量和方法变量"><a href="#区分成员变量和方法变量" class="headerlink" title="区分成员变量和方法变量"></a>区分成员变量和方法变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 setName 中，方法变量 name 和成员变量name名称相同，为区分两个变量，使用 this 关键字引用成员变量；因为 this 关键字代表 Person 对象，修饰的变量 name（this.name）就是 Person 对象的成员变量 name ，另一个 name 采用方法的就近原则，指的是方法参数name  </p><h4 id="调用构造方法"><a href="#调用构造方法" class="headerlink" title="调用构造方法"></a>调用构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(<span class="string">"张三"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在同一个类中，无参构造方法中使用 this 调用另一个有参构造方法</p><h4 id="对类对象的引用"><a href="#对类对象的引用" class="headerlink" title="对类对象的引用"></a>对类对象的引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">psoDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 return this 代表返回当前对象 Person 类  </p><p>注意，如果在匿名内部类中使用，this 代表的是所在匿名类的对象，而不是外部调用类的实例  </p><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisClass</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">thisDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread()&#123;<span class="comment">//匿名类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Hello.<span class="keyword">this</span>.run();<span class="comment">//调用外部类的方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 this 指的是匿名对象，而不是 ThisClass 对象</p><h3 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h3><p>指向当前对象的父类，用super引用直接父类对象的成员；</p><p>super只能调用的是所在类的直接父类，在当前对象最近的父类；不能越过直接的父类调用父类以上的父类中的变量方法</p><h3 id="super用法"><a href="#super用法" class="headerlink" title="super用法"></a>super用法</h3><h4 id="子类构造方法调用父类的构造方法"><a href="#子类构造方法调用父类的构造方法" class="headerlink" title="子类构造方法调用父类的构造方法"></a>子类构造方法调用父类的构造方法</h4><p>super() 方法只能放在子类构造方法的第一行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.print(<span class="string">"This is father"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">(String act)</span></span>&#123;</span><br><span class="line">System.out.print(<span class="string">"father "</span>+ act);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">System.out.print(<span class="string">"This is son"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">(String act)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(act);</span><br><span class="line">System.out.print(<span class="string">"son "</span>+act);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">       Son son = <span class="keyword">new</span> Son(); </span><br><span class="line">       son = <span class="keyword">new</span> Son(<span class="string">"在打游戏..."</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用父类自身对象中同名变量、方法"><a href="#调用父类自身对象中同名变量、方法" class="headerlink" title="调用父类自身对象中同名变量、方法"></a>调用父类自身对象中同名变量、方法</h4><p>如果子类中有变量或者方法和父类的变量或方法重名，那么可以使用super调用父类的变量或方法  </p><p>但是访问父类的成员变量和方法时，注意不能访问父类的私有属性的变量方法！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"father 的age："</span><span class="keyword">super</span>.age);  <span class="comment">//正确</span></span><br><span class="line">        System.out.print(<span class="string">"father 的num："</span>+<span class="keyword">super</span>.num); <span class="comment">//错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序中，Son继承了Father类  </p><p>Son中有跟父类同名成员变量a，同名方法say()</p><ul><li>super.a：调用父类a变量，前提是父类的a变量是公有的  </li><li>super.num：是错误的！因为父类中的num是private，所有子类没有权限访问</li><li>super.say()：调用父类Father的say()方法，而不是子类的say()方法</li></ul><h4 id="调用父类的父类中的方法"><a href="#调用父类的父类中的方法" class="headerlink" title="调用父类的父类中的方法"></a>调用父类的父类中的方法</h4><p>super不能越过直接的父类调用父类以上的父类中的变量方法，但是如果想要访问父类的父类中的方法，在父类继承父类的父类中的成员方法后可以访问 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> numA = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sumNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">num = num+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumA</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>.<span class="keyword">super</span>.sumNum();<span class="comment">//错误</span></span><br><span class="line"><span class="keyword">super</span>.sumNum();<span class="comment">//正确</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="this-和-super-比较"><a href="#this-和-super-比较" class="headerlink" title="this 和 super 比较"></a>this 和 super 比较</h3><ul><li>this 指向当前对象，调用本类的成员变量和方法；super指向父类，调用父类的成员变量和方法</li><li>this和super语句都要放在构造方法中的第一行</li><li>每个子类继承父类之后，在子类的无参构造方法中第一条都会默认隐式调用super()方法调用父类无参构造方法</li><li>this相当于本身对象的一个指针，用来调用当前对象的成员；而super不是指针，只是一个关键字</li></ul>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> this 关键字 </tag>
            
            <tag> super 关键字 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习（七）三大特性之 - 封装</title>
      <link href="/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%83%EF%BC%89%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B-%E5%B0%81%E8%A3%85/"/>
      <url>/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%83%EF%BC%89%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B-%E5%B0%81%E8%A3%85/</url>
      <content type="html"><![CDATA[<h3 id="封装简介"><a href="#封装简介" class="headerlink" title="封装简介"></a>封装简介</h3><p>封装的好处：</p><ol><li>隐藏对象细节，提供公共访问方式</li><li>提高代码复用性，减少耦合</li><li>提高安全性，对对象成员更好地控制</li></ol><h4 id="封装格式"><a href="#封装格式" class="headerlink" title="封装格式"></a>封装格式</h4><p>封装属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> 属性类型 属性名;</span><br></pre></td></tr></table></figure><p>封装方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> 方法返回类型 方法名称（参数）;</span><br></pre></td></tr></table></figure><h4 id="封装例子"><a href="#封装例子" class="headerlink" title="封装例子"></a>封装例子</h4><p>封装把一个对象的属性私有化（private），提供一些公共的（public）方法让外界访问属性 </p><p>可以对设置属性入口做一些限制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(age&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      System.out.println(<span class="string">"设置年龄有误:"</span>+age+<span class="string">"岁不属于人类年龄..."</span>);</span><br><span class="line">      &#125; esle&#123;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">p.setName(<span class="string">"张三"</span>);</span><br><span class="line">p.setAge(-<span class="number">10</span>);</span><br><span class="line">p.setAge(<span class="number">20</span>);</span><br><span class="line">System.out.println(p.getName()+<span class="string">"现在"</span>+p. getAge()+<span class="string">"岁了"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p>设置年龄有误:-10岁不属于人类年龄…<br>张三已经20岁了</p><p>修改成员变量为private，提供 getters 和 setters 方法访问对象属性</p>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 封装 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习（六）java类</title>
      <link href="/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89java%E7%B1%BB/"/>
      <url>/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89java%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p>java是面向对象的语言，类和对象是核心思想  </p><p>声明类需要用关键字class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称</span>&#123;</span><br><span class="line"><span class="comment">//成员变量</span></span><br><span class="line"><span class="comment">//成员方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类中的变量"><a href="#类中的变量" class="headerlink" title="类中的变量"></a>类中的变量</h3><p>一个类的变量包括：成员变量，类变量，局部变量</p><ul><li>成员变量：定义在类中方法外，又称为实例变量</li><li>类变量：定义在类中方法外，必须为static类型</li><li>局部变量：在方法内部</li></ul><p>java中，一个类是体现一个事物的，而成员变量代表的是事物的属性，类的方法是描述事物的行为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> eyeCount;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">(String stdName)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中，学生是类Student，static 修饰的 eyeCount 变量是类变量，学生有姓名的年龄，所以成员变量是name、age，学生有学习的行为，所以对应的方法是study，方法内的变量 stdName 是局部变量</p><h4 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h4><p>类变量，用static关键字声明，所以也称静态变量，必须在类中方法外进行声明定义  </p><p>在创建对象的实例时类变量被创建，对象被销毁时变量被销毁</p><p>静态变量可以通过：ClassName.类变量名称 的方式访问，通常类变量命名为大写字母  </p><p>静态变量在类加载时初始化</p><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p>成员变量，又称为实例变量  </p><p>在创建对象实例时创建类的成员变量，当对象被销毁时被销毁。  </p><p>如果在创建对象实例时，未显式分配值的成员变量在声明期间程序会自动分配一个初始值，成员变量的初始化值取决于成员变量的类型。</p><table><thead><tr><th>元素类型</th><th>初始值</th></tr></thead><tbody><tr><td>byte</td><td>0</td></tr><tr><td>short</td><td>0</td></tr><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0</td></tr><tr><td>float</td><td>0.0</td></tr><tr><td>double</td><td>0.0</td></tr><tr><td>char</td><td>“\u0000”</td></tr><tr><td>boolean</td><td>false</td></tr><tr><td>对象引用</td><td>null</td></tr></tbody></table><p>静态变量，存储在静态存储区，经常与final关键字共同使用；</p><h4 id="方法变量"><a href="#方法变量" class="headerlink" title="方法变量"></a>方法变量</h4><p>方法变量必须在使用之前进行显示初始化，否则编译报错  </p><p>方法变量仅仅在方法的执行期间存在</p><h4 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h4><p>成员变量和局部变量的区别：</p><ul><li>类中的位置：<ul><li>成员变量：在类中，方法外，整个类都可以访问成员变量</li><li>局部变量：在局部范围，如在方法内，方法内的函数、语句等</li></ul></li><li>内存分配位置：<ul><li>成员变量：在堆内存中，类在编译.class文件时放在堆中的方法区</li><li>局部变量：在栈内存中</li></ul></li><li>生命周期：<ul><li>成员变量：随着对象的建立而产生，随着对象的消失而销毁</li><li>局部变量：方法被调用，创建变量；方法调用完毕，空间被销毁</li></ul></li><li>初始化<ul><li>成员变量：有默认初始化值</li><li>局部变量：没有默认初始化值；必须对变量进行定义赋值才能使用</li></ul></li></ul><p>在成员变量和局部变量名称相同时，在方法执行中采用就近原则</p><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p>java中定义类、方法、修饰符等通常会添加访问修饰符，通过访问修饰符来控制对类、变量、方法的访问权限  </p><p>java中支持4种访问修饰符</p><table><thead><tr><th>修饰符</th><th>当前类内部</th><th>同一包内</th><th>同包内、包外子类</th><th>所有类</th></tr></thead><tbody><tr><td>private</td><td>√</td><td></td><td></td><td></td></tr><tr><td>default</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><ul><li>private：只能被自己访问和修改</li><li>default（默认没有修饰符）：同一包中的类可以访问，声明时没有加修饰符，认为是friendly</li><li>protected：自身，子类及同一个包中类可以访问</li><li>public：可以被所有其他类所访问</li></ul>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习（五）java内存分析</title>
      <link href="/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89java%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/"/>
      <url>/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89java%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h3 id="java内存分配"><a href="#java内存分配" class="headerlink" title="java内存分配"></a>java内存分配</h3><p>java程序是在jvm上运行的，所以java程序的内存分配是由jvm进行分配管理的</p><p>java程序在运行时会分配以下几个区域：</p><ul><li>程序计数器：又叫寄存器</li><li>栈：保存局部变量</li><li>堆：存放动态产生的数据，如new出来的对象</li><li>方法区：存储被jvm加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</li><li>常量池：存放常量；存在于方法区（在堆中）</li><li>代码段：存放源程序代码</li><li>数据段：存放static修饰的静态成员</li></ul><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>JVM支持多个线程同时运行，当每一个新线程被创建时，它都将得到它自己的PC寄存器（程序计数器）。  计数器是每个线程独有的一个内存区域  </p><p>线程执行java方法，PC寄存器的值将总是指向下一条将被执行的指令，如果方法是 native 的，程序计数器寄存器的值为空</p><h4 id="栈（stack）"><a href="#栈（stack）" class="headerlink" title="栈（stack）"></a>栈（stack）</h4><h5 id="栈的基本知识"><a href="#栈的基本知识" class="headerlink" title="栈的基本知识"></a>栈的基本知识</h5><p>方法被执行时，会创建一个栈帧。 </p><ul><li>存放内容：局部变量-基本类型的变量（byte、short、int、long、float、double）、对象的引用；操作数栈；帧数据区</li><li>特点：存取速度快；数据的生命周期是方法的运行期间</li><li>在执行方法时，方法所需的局部变量空间已经建立，方法中定义一个变量，java为变量分配内存空间；当变量的作用域消失，java自动释放掉为该变量分配的内存空间</li></ul><h5 id="栈的原理"><a href="#栈的原理" class="headerlink" title="栈的原理"></a>栈的原理</h5><p>栈是以帧为单位保存线程的状态</p><p>运行一个java程序，jvm创建一个线程，并且为这个线程分配一个栈，java程序的执行是对栈进行操作，程序中的方法在执行时会创建一个栈帧，每个方法的运行就是对栈进行入栈到出栈的操作；</p><p>java程序运行，此程序线程激活程序中的方法，jvm就会创建一个栈帧压入此线程的栈中，这个栈帧会存放当前激活方法的参数、方法局部变量等等</p><p><img src="/2018/06/25/javaSE学习（五）java内存分析/栈帧.png" alt="栈帧"></p><h5 id="栈的异常"><a href="#栈的异常" class="headerlink" title="栈的异常"></a>栈的异常</h5><p>创建栈帧时没有内存空间，JVM就会抛出StackOverflowError异常  </p><p>如果栈扩展时无法申请到足够的内存，将抛出OutOfMemoryError异常</p><h4 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h4><h5 id="栈的基本知识-1"><a href="#栈的基本知识-1" class="headerlink" title="栈的基本知识"></a>栈的基本知识</h5><p>堆内存：<br>jvm启动后便会创建一个堆；</p><ul><li>存放内容：java程序运行时创建的类实例和数组等对象实例</li><li>特点：可以在运行时动态的分配内存大小；存取速度慢</li><li>堆内存中出现不再指向的对象，java的垃圾回收器便会定时清理</li><li>堆内存因为空间满了而无法再进行扩展分配内存时，会抛出java.lang.OutOfMemoryError:Java heap space异常</li></ul><h5 id="堆原理"><a href="#堆原理" class="headerlink" title="堆原理"></a>堆原理</h5><p>堆是jvm管理所有内存中最重要的一块，所有线程共享的一块区域，在虚拟机jvm启动时创建  </p><p>堆中存放所有的对象实例，但是对象的引用存在在栈中；</p><h5 id="堆空间的释放"><a href="#堆空间的释放" class="headerlink" title="堆空间的释放"></a>堆空间的释放</h5><p>jvm对栈中存放的变量，当程序方法运行结束，jvm会自动释放这些变量的内存空间；而对于堆中创建的对象内存空间，在对象不再被使用时，jvm不会自动释放，而是由垃圾收集器进行回收</p><blockquote><p>java垃圾回收器：垃圾收集器基本上都是采用分代收集算法，所以java堆分为新生代和老生代</p></blockquote><p>堆是垃圾收集器主要管理的一部分区域，又称为GC堆</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区是被java所有线程共享的内存区域，用于存储已被jvm加载的类信息、常量、静态变量、即时编译器编译后的.class文件中的数据。</p><p>方法区无法申请到内存时，将抛出OutOfMemoryError异常</p><h5 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h5><p>常量池是方法区的一部分</p><p>jvm会为每一个编译后的类创建一个常量池；类编译class文件时，还会生成各种直接常量（基本类型变量、string）和其他类型、方法等符号引用，这部分数据会被存放在常量池中  </p><p>常量池具有动态性，编译时产生常量池，将.class文件的数据存放进去，在运行期间也可以将新常量放入，如string类的intern()方法可以做到；所以常量池又称为运行时常量池</p><h3 id="对象内存分析"><a href="#对象内存分析" class="headerlink" title="对象内存分析"></a>对象内存分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">String brand;</span><br><span class="line">String color;</span><br><span class="line"> <span class="keyword">int</span> price;</span><br><span class="line">Phone(String brand,String color,<span class="keyword">int</span> price)&#123;</span><br><span class="line"><span class="keyword">this</span>.brand = brand;</span><br><span class="line"><span class="keyword">this</span>.color = color;</span><br><span class="line"><span class="keyword">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String name)</span></span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String name)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneAct</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Phone p = <span class="keyword">new</span> Phone(<span class="string">"三星"</span>,<span class="string">"银色"</span>,<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line">p.call(<span class="string">"爸爸"</span>);</span><br><span class="line">p.sendMessage(<span class="string">"妈妈"</span>);</span><br><span class="line">Phone p2 = <span class="keyword">new</span> Phone(<span class="string">"苹果"</span>,<span class="string">"金色"</span>,<span class="number">6000</span>);  </span><br><span class="line">p.claa(“朋友”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是内存分析图</p><p><img src="/2018/06/25/javaSE学习（五）java内存分析/对象内存图.png" alt="对象内存图"></p>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 内存分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习（四）数组</title>
      <link href="/2018/05/28/javaSE%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E6%95%B0%E7%BB%84/"/>
      <url>/2018/05/28/javaSE%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<h3 id="数组介绍"><a href="#数组介绍" class="headerlink" title="数组介绍"></a>数组介绍</h3><p>数组是存储固定大小的同一种数据类型的多个元素的集合；  </p><p>可以存放基本数据类型，也可以存放引用数据类型</p><h4 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h4><h5 id="数组声明"><a href="#数组声明" class="headerlink" title="数组声明"></a>数组声明</h5><ul><li>数据类型[] 数组名：int[] a;</li><li>数据类型 数组名[]：int a[];</li></ul><h5 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h5><p>初始化：给系统开辟内存空间，并且给数组元素赋值</p><ul><li>动态初始化：指定数组长度，系统给数组分配初始值</li><li>静态初始化：指定数组中的元素初始值，长度由系统定义</li></ul><p>格式：  </p><p>数据类型[] 数组名 = new 数据类型[数组长度];<br>或<br>数据类型[] 数组名 = {value1,value2,value3…};</p><p>用new操作符创建数组</p><p>可以先声明，后定义；也可以声明定义一起</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明并且定义</span></span><br><span class="line"><span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//先声明数组变量arr2，后创建数组赋值给声明的arr2</span></span><br><span class="line"><span class="keyword">double</span>[] arr2;</span><br><span class="line">arr2 = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>数组的动态初始化和静态初始化  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态初始化</span></span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>；</span><br><span class="line"><span class="comment">//静态初始化（两种写法）</span></span><br><span class="line"><span class="keyword">int</span>[] b1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>&#125;；</span><br><span class="line"><span class="keyword">int</span>[] b2 = &#123;<span class="number">4</span>,<span class="number">5</span>&#125;；</span><br><span class="line"><span class="comment">//注意，不能动态和静态同时进行，如：</span></span><br><span class="line"><span class="comment">//int[] arr = new int[2]&#123;4,5&#125;；  写法错误！！！</span></span><br></pre></td></tr></table></figure><h4 id="获取数组元素"><a href="#获取数组元素" class="headerlink" title="获取数组元素"></a>获取数组元素</h4><p>访问数组元素是通过数组的索引访问的  </p><p>数组的每个元素有唯一的索引，从数组的第一个元素起，索引从0开始标识，一直到数组长度-1</p><p>访问数组方式：数组变量名[索引]</p><h3 id="数组内存分配"><a href="#数组内存分配" class="headerlink" title="数组内存分配"></a>数组内存分配</h3><h4 id="数组定义内存分析"><a href="#数组定义内存分析" class="headerlink" title="数组定义内存分析"></a>数组定义内存分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> 数组内存分析如下： </span><br><span class="line"></span><br><span class="line">![数组内存](javaSE学习（四）数组/数组内存.png) </span><br><span class="line"></span><br><span class="line">对于分配内存：局部变量和变量名称放在栈中，<span class="keyword">new</span>的对象放在堆中  </span><br><span class="line"></span><br><span class="line">堆分配内存时，对每一个<span class="keyword">new</span>出来的对象都有一个地址，对象都会有默认值，如<span class="keyword">int</span>的默认值是<span class="number">0</span>，引用类型的默认值是<span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">栈中的变量在使用完之后会立即销毁；堆中的对象在使用完成之后就会成为垃圾，在java的垃圾回收器空闲时进行回收</span><br><span class="line"></span><br><span class="line">#### 数组之间赋值内存分析</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">arr1[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">arr1[<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line">arr1[<span class="number">2</span>] = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">arr2[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">arr2[<span class="number">1</span>] = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">int</span>[] arr3 = arr1;</span><br><span class="line">arr3[<span class="number">0</span>] = <span class="number">101</span>;</span><br><span class="line">arr3[<span class="number">3</span>] = <span class="number">301</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">arr1:[101，20，301]</span></span><br><span class="line"><span class="comment">arr2:[100，200]</span></span><br><span class="line"><span class="comment">arr3:[101，20，301]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>new 数组内存分析如下：</p><p><img src="/2018/05/28/javaSE学习（四）数组/数组赋值内存.png" alt="数组赋值内存"></p><p>分析：将数组arr1赋值给数组arr3，实际上是将arr1数组在堆中的对象地址赋值给arr3，所以arr3数组指向的地址是arr1的数组地址，于是arr3数组给数组元素赋值，改变的是堆中创建的0x001地址元素，所以最后arr3操作的是arr1创建的对象</p><h3 id="数组常见异常"><a href="#数组常见异常" class="headerlink" title="数组常见异常"></a>数组常见异常</h3><h4 id="越界异常"><a href="#越界异常" class="headerlink" title="越界异常"></a>越界异常</h4><p>数组下标越界异常：java.lang.IndexOutOfBoundsException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a = arr[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的程序中，编译不报错，但在运行时会报java.lang.IndexOutOfBoundsException异常  </p><p>原因：数组arr共有3个元素，元素下标分别为：0，1，2；但是变量a访问的是arr[3]，arr数组并没有下标为3的元素，超出了数组的范围，所以会报下标越界异常</p><h4 id="空指针异常"><a href="#空指针异常" class="headerlink" title="空指针异常"></a>空指针异常</h4><p>空指针异常：java.lang.NullPointerException  </p><p>调用了未经初始化的对象或者是不存在的对象 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">arr = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> a = arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序会发生java.lang.NullPointerException </p><p>原因：在第二句中程序将数组arr赋值为null，原先数组指向堆内存的数组{1,2,3}，现在arr指向null了，此时再通过数组下标访问数组，会报错  </p><h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><h4 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr=&#123;<span class="number">5</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">34</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">//遍历数组中所有元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">System.out.print(arr[i] + <span class="string">","</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">//计算数组中最大值</span></span><br><span class="line"><span class="keyword">int</span> maxNum = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&gt;maxNum) maxNum = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"arr数组中最大元素为："</span>+maxNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组最大值"><a href="#数组最大值" class="headerlink" title="数组最大值"></a>数组最大值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxNum</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="comment">//计算数组中最大值</span></span><br><span class="line"><span class="keyword">int</span> maxNum = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&gt;maxNum) maxNum = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组逆序"><a href="#数组逆序" class="headerlink" title="数组逆序"></a>数组逆序</h4><p><code>`</code>java<br>public void reverse(int[] arr){<br>    for(int i=0;i&lt;arr.length/2;i++){<br>        int temp = arr[i];<br>        arr[i] = arr[arr.length-1-x];<br>        arr[arr.length-1-x] = temp;<br>    }<br>}<br>//升级版<br>public void reverse02(int[] arr){<br>    for(int start = 0,end = arr.length-1;start&lt;=end;start++,end–){<br>        int temp = arr[start];<br>        arr[start] = arr[end];<br>        arr[end] = temp;<br>    }<br>}</p>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习（三）方法</title>
      <link href="/2018/05/28/javaSE%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E6%96%B9%E6%B3%95/"/>
      <url>/2018/05/28/javaSE%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h3><h4 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h4><p>方法：完成特定功能的语句的集合</p><p>方法命名规则：名称第一个字母小写</p><h5 id="方法语法格式："><a href="#方法语法格式：" class="headerlink" title="方法语法格式："></a>方法语法格式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...)&#123;</span><br><span class="line">方法体语句;</span><br><span class="line">return 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修饰符：</li><li>返回值类型：这个方法执行完成返回的结果值的类型</li><li>方法名：</li><li>参数类型：方法被调用时，将值传给参数；参数可以有，也可没有</li><li>方法体：具体包含实现方法功能的语句</li><li>return：结束方法，将结果值返回</li></ul><h5 id="方法举例："><a href="#方法举例：" class="headerlink" title="方法举例："></a>方法举例：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c = a+b;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h4><p>方法执行特点：不调用，不执行  </p><p>方法的两种调用：根据方法是否有返回值</p><p>有返回值：调用方法返回什么类型的值，就用什么类型的数据接收<br>无返回值：可以直接调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionStudyDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">int</span> b = <span class="number">6</span>;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      有返回值调用，通过赋值方式调用</span></span><br><span class="line"><span class="comment">      sum方法结果</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">int</span> c = sum(a, b);</span><br><span class="line">      System.out.println(<span class="string">"Minimum Value = "</span> + c);</span><br><span class="line">      <span class="comment">//无返回值调用</span></span><br><span class="line">      maxNumFunction(a, b);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> a+b;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maxNumFunction</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(a&gt;b) System.out.println(<span class="string">"max number is "</span> + a);</span><br><span class="line">   <span class="keyword">else</span> System.out.println(<span class="string">"max number is "</span> + b);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><h4 id="什么是方法的重载"><a href="#什么是方法的重载" class="headerlink" title="什么是方法的重载"></a>什么是方法的重载</h4><p>方法的重载，是在同一个类中，定义的方法名称相同，但是参数不同，返回类型可以相同也可以不同  </p><p>每个重载的方法，参数类表必须不同，与返回值无关！  </p><p>重载是一种语言规则，在编译期间检查重载的正确性，通过判断参数列表的不同区别方法  </p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dmeo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"int int:"</span> + compareMethod(<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">System.out.println(<span class="string">"double double:"</span> + compareMethod(<span class="number">1.2</span>,<span class="number">1.2</span>));</span><br><span class="line">System.out.println(<span class="string">"byte byte:"</span> + compareMethod(<span class="number">2.1</span>,<span class="number">2.1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareMethod</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a==b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareMethod</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a==b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareMethod</span><span class="params">(<span class="keyword">byte</span> a, <span class="keyword">byte</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a==b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习（一）基本知识</title>
      <link href="/2018/05/28/javaSE%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/05/28/javaSE%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><img src="/2018/05/28/javaSE学习（一）基本知识/数据类型.png" alt="数据类型"></p><p>数据类型分为：</p><ul><li>基本数据类型</li><li>引用数据类型</li></ul><h4 id="基本数据类型：4类8种"><a href="#基本数据类型：4类8种" class="headerlink" title="基本数据类型：4类8种"></a>基本数据类型：4类8种</h4><table><br>    <tr><th>类型</th><th>种类</th><th>字节</th><th>范围</th></tr><br>    <tr><td rowspan="4">整型</td><td>byte</td><td>1</td><td>-128~127</td></tr><br>    <tr><td>short</td><td>2</td><td>-128~127</td></tr><br>    <tr><td>int</td><td>4</td><td>-128~127</td></tr><br>    <tr><td>long</td><td>8</td><td>-128~127</td></tr><br>    <tr><td rowspan="2">浮点型</td><td>float</td><td>4</td><td>有效位数6~7位</td></tr><br>    <tr><td>double</td><td>8</td><td>有效位数为15位</td></tr><br>    <tr><td rowspan="1">字符型</td><td>char</td><td>1</td><td>\u0000到\Uffff</td></tr><br>    <tr><td rowspan="1">布尔型</td><td>boolean</td><td>1</td><td></td></tr><br></table><ul><li>整数默认int类型,浮点数默认double.  </li><li>长整型必须加L或l后缀，如long a =  10000000L；</li><li>float类型加后缀F或f，如1.5F；没有后缀默认double</li><li>char类型用单引号括起来</li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h4><h4 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h4><p>java中变量必须用赋值语句对变量进行显式初始化<br>可以在声明变量时进行赋值，也可以之后赋值，但是必须在使用之前，如果一个变量没有被赋值，那这个变量不能被使用  </p><h4 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在同一行进行多个变量的定义和初始化，不建议</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>;<span class="keyword">int</span> b;<span class="keyword">int</span> c;</span><br><span class="line"><span class="comment">//一行定义一个变量</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>用关键字声明常量<br>常量只能被赋值一次，在赋值之后不能再进行更改<br>习惯上常量命名风格是全部大写  </p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="运算符介绍"><a href="#运算符介绍" class="headerlink" title="运算符介绍"></a>运算符介绍</h4><p>运算符分为：算术运算符、赋值运算符、比较运算符、逻辑运算符、位运算符，三目运算符</p><h5 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h5><p>+、-、*、/、%、++、–</p><p>整数在进行/运算时，结果是整数；如果要得到浮点类型结果，需要将其中一个数据转换为浮点数类型</p><h6 id="运算符-1"><a href="#运算符-1" class="headerlink" title="+运算符"></a>+运算符</h6><p>用法：</p><ul><li>数值加法运算</li><li>正号</li><li>字符串连接符</li></ul><h6 id="、–自增自减运算符："><a href="#、–自增自减运算符：" class="headerlink" title="++、–自增自减运算符："></a>++、–自增自减运算符：</h6><ul><li>i++：先进行表达式运算，再自增</li><li>++i：先自增再进行表达式运算</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>；</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> x = i++;</span><br><span class="line"><span class="keyword">int</span> y = ++j；</span><br><span class="line">System.out.println(<span class="string">"i = "</span>+i+<span class="string">"   j="</span>+j);<span class="comment">//i=2   j=2</span></span><br><span class="line">System.out.println(<span class="string">"x = "</span>+x+<span class="string">"   y="</span>+y);<span class="comment">//x=1   j=2</span></span><br></pre></td></tr></table></figure><p>上面的例子可以看出，无论是i++还是++j，对i和j本身的值无关，都是+1后的结果；但是符号的位置对赋值运算的结果会有影响，例子中x和y的值完全不同</p><p>单独进行自增、自减运算：运算符位置对进行自增自减运算的无区别  </p><p>参与表达式运算：</p><ul><li>在操作数之前，先进行自增运算，再参与其他表达式运算</li><li>在操作数之后，先进行其他表达式运算，再自增运算</li></ul><h5 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h5><p>==,!=,&gt;,&gt;=,&lt;,&lt;=</p><p>运算结果都为boolean</p><h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><h5 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h5><h5 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h5><p>格式：表达式?表达式1:表达式2  </p><p>表达式结果是boolean类型；表达式计算结果为true，执行表达式1返回结果；false执行表达式2返回结果；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> z = (x&gt;y)?x:y;</span><br><span class="line">System.out.println(<span class="string">"z="</span>+z);<span class="comment">//z=5</span></span><br></pre></td></tr></table></figure><h4 id="运算符级别"><a href="#运算符级别" class="headerlink" title="运算符级别"></a>运算符级别</h4><p>运算符的优先级如下：</p><table><br>    <tr><th>运算符优先级</th><th>运算符</th><th>结合性</th></tr><br>    <tr><td>1</td><td>()[].</td><td>从左到右</td></tr><br>    <tr><td>2</td><td>! +(正) -(负) ~ ++ –</td><td>从左到右</td></tr><br>    <tr><td>3</td><td><em> / %</em></td><td>从左到右</td></tr><br>    <tr><td>4</td><td>+(加) -(减)</td><td>从左到右</td></tr><br>    <tr><td>5</td><td>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</td><td>从左到右</td></tr><br>    <tr><td>6</td><td>&lt; &lt;= &gt; &gt;= instanceof</td><td>从左到右</td></tr><br>    <tr><td>7</td><td>== !=</td><td>从左到右</td></tr><br>    <tr><td>8</td><td>&amp;(按位与)</td><td>从左到右</td></tr><br>    <tr><td>3</td><td>^</td><td>从左到右</td></tr><br>    <tr><td>4</td><td>|</td><td>从左到右</td></tr><br>    <tr><td>5</td><td>&amp;&amp;</td><td>从左到右</td></tr><br>    <tr><td>6</td><td>||</td><td>从左到右</td></tr><br>    <tr><td>7</td><td>?:</td><td>从右到左</td></tr><br>    <tr><td>8</td><td>= += -= = /= %= &amp;= |= ^=  ~=  &lt;&lt;= &gt;&gt;=   &gt;&gt;&gt;=</td><td>从右到左</td></tr><br></table><h4 id="数值类型转换"><a href="#数值类型转换" class="headerlink" title="数值类型转换"></a>数值类型转换</h4><p>在计算时，参与计算的数据类型一般要一致，如果不一致，则要将数据进行类型的转换  </p><p>boolean不参与数据转换</p><p>数值类型的转换，分为默认转换和强制转换</p><h5 id="默认转换"><a href="#默认转换" class="headerlink" title="默认转换"></a>默认转换</h5><p>默认转换，前提是数据类型从小到大才会默认转换  </p><p>byte、short、char-&gt;int-&gt;long-&gt;float-&gt;double  </p><p>byte、short、char这三种类型之间不进行转换，在参与运算时之间转换为int类型</p><h5 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h5><p>将字节大的转换为字节小的数据类型，需要强制转换  </p><p>转换格式：目标数据类型 目标变量 = (目标数据类型)被转换数据;</p><p>注意: 如果将一个数值从一种字节大的类型强制转换为另一种字节小的类型，并且超出了目标类型的表示范围，目标结果就会被截断成一个完全不同的值。例如:int是300的值强制转换为byte后的实际值为44：(byte)300=44</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//byte c = a + b;这个语句在编译时会报错：损失精度，需要前置转换</span></span><br><span class="line"><span class="keyword">byte</span> c = (<span class="keyword">byte</span>)a + b;</span><br></pre></td></tr></table></figure><p>分析直接定义和强制转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f1 = (<span class="keyword">float</span>)<span class="number">1.2345</span>;</span><br><span class="line"><span class="keyword">float</span> f2 = <span class="number">1.2345F</span>;</span><br></pre></td></tr></table></figure><p>以上两个语句都正确，但是有区别：f1是通过double类型的数据强制转换来的；而f2变量定义的就是一个float类型  </p><p>分析运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1 = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">byte</span> b2 = <span class="number">4</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">byte类型做计算，会自动转换为int类型</span></span><br><span class="line"><span class="comment">需要强转，因为byte 3+byte 4 结果自动转换为int类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">byte</span> b3 = (<span class="keyword">byte</span>)b1 + b2;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3+4=7是一个常量</span></span><br><span class="line"><span class="comment">在运算时将3+4计算出来，然后看这个结果值常量是否在byte范围内，在则不报错，不在会报错</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">byte</span> b4 = <span class="number">3</span> + <span class="number">4</span>;</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>java字符串用String定义，就是Unicode字符序列；字符串是一个对象  </p><p>每个用双引号括起来的字符串都是 String 类，如：String s = “java string”;</p><h4 id="字符串的拼接"><a href="#字符串的拼接" class="headerlink" title="字符串的拼接"></a>字符串的拼接</h4><p>使用+</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">String num = a+<span class="string">"456"</span>;<span class="comment">//num = "123456"</span></span><br></pre></td></tr></table></figure><p>一个字符串与其他类型的变量拼接，都会被转换为字符串</p><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p>从键盘输入数据，让程序读取接收</p><h4 id="读取键盘输入"><a href="#读取键盘输入" class="headerlink" title="读取键盘输入"></a>读取键盘输入</h4><p>控制台输出，标准输出流：System.out.println();  </p><p>读取输入流（键盘输入内容）：System.in；但是程序不能像输入流一样直接输出，读取输入流必须要借助Scanner对象，java5中的java.util.Scanner  </p><p>Scanner in = new Scanner(System.in);  </p><p>通过以上语句创建出Scanner对象，控制台等待用户输入，回车键结束输入；控制台输入的数据传给Scanner对象，用next相关方法获取相关数据  </p><h5 id="Scanner相关方法"><a href="#Scanner相关方法" class="headerlink" title="Scanner相关方法"></a>Scanner相关方法</h5><table><br>    <tr><th>Return</th><th>MethodName</th><th>解释</th></tr><br>    <tr><br>        <td>Pattern</td><td>delimiter()</td><br>        <td>返回 Scanner 当前正在用于匹配分隔符的 Pattern（默认空格）</td><br>    </tr><br>    <tr><br>        <td>void</td><td> useDelimiter()</td><br>        <td>设置 Scanner 使用的匹配分隔符的 Pattern </td><br>    </tr><br>    <tr><br>        <td>String</td><td>next()</td><br>        <td>读取当前扫描位置的下一个单词（默认以空格作为分隔符）</td><br>    </tr><br>    <tr><br>        <td>String</td><td>nextLine()</td><br>        <td>读取当前扫描位置之后的行内容（默认以回车符作为分隔符）</td><br>    </tr><br>    <tr><br>        <td>int</td><td>nextlnt</td><br>        <td>读取当前扫描位置之后的整数（默认以回车符作为分隔符）</td><br>    </tr><br>    <tr><br>        <td>double</td><td>nextDouble</td><br>        <td>读读取并转换下一个表示整数或浮点数的字符序列</td><br>    </tr><br>    <tr><br>        <td>boolean</td><td>hasNext()</td><br>        <td>判断 Scanner 中当前扫描位置后是否还存在行内容，存在返回true<br>        跟next()搭配</td><br>    </tr><br>    <tr><br>        <td>boolean</td><td>hasNextLine()</td><br>        <td>判断 Scanner 中当前扫描位置后是否还存在内容，存在返回 true<br>        跟nextLine()搭配</td><br>    </tr><br></table><h5 id="next和nextLine"><a href="#next和nextLine" class="headerlink" title="next和nextLine"></a>next和nextLine</h5><h6 id="分别测试"><a href="#分别测试" class="headerlink" title="分别测试"></a>分别测试</h6><p>测试next方式和nextLine方式，输入内容：next 123,asdf  </p><p>next方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in); </span><br><span class="line">    System.out.println(<span class="string">"请输入字符串："</span>);</span><br><span class="line">    <span class="keyword">while</span>(sc.hasNext())&#123;</span><br><span class="line">    System.out.println(sc.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">next</span><br><span class="line">123,asdf</span><br></pre></td></tr></table></figure><p>nextLine方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in); </span><br><span class="line">    System.out.println(<span class="string">"请输入字符串："</span>); </span><br><span class="line">    <span class="keyword">while</span>(sc.hasNextLine())&#123;</span><br><span class="line">    System.out.println(sc.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"---输入内容加\n回车符测试---"</span>);</span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(<span class="string">"disf 132,2wq \n a.db cdce/12"</span>); </span><br><span class="line">    <span class="keyword">while</span>(sc.hasNextLine())&#123;</span><br><span class="line">    System.out.println(sc.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">next 123,asdf</span><br><span class="line">---输入内容加\n回车符测试---</span><br><span class="line">disf 132,2wq </span><br><span class="line"> a.db cdce/12</span><br></pre></td></tr></table></figure><p>设置分隔符方式，sc.useDelimiter设置分隔符仅仅对next方式有效，nextLine方式无效，还是以回车符进行分割行内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(<span class="string">"disf 132,2wq a.db cdce/12"</span>); </span><br><span class="line">    sc.useDelimiter(<span class="string">","</span>);</span><br><span class="line">    <span class="keyword">while</span>(sc.hasNext())&#123;</span><br><span class="line">    System.out.println(sc.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">disf 132</span><br><span class="line">2wq a.db cdce/12</span><br></pre></td></tr></table></figure><h6 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h6><p>next()：</p><ul><li>默认空白作为分隔符或者结束符时，对输入有效字符之前遇到的空白，next() 方法会自动去掉；不指定分隔符的情况下 next() 不能得到带有空格的字符串；</li><li>使用 useDelimiter() 指定非空格字符为分隔符时，可以得到带空格的字符串；</li></ul><p>nextLine()：</p><ul><li>默认使用回车符作为分隔符，可以得到带空白的字符串；</li><li>useDelimiter()无效；</li></ul><h5 id="Scanner的关闭"><a href="#Scanner的关闭" class="headerlink" title="Scanner的关闭"></a>Scanner的关闭</h5><p>使用close()方法关闭  </p><p>注意：使用close时，会将 System.in 也关闭；要使用多个 Scanner 时，将这些scanner放在最后一同进行关闭</p>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 基本知识 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mac - mac中Terminal或Iterm2 ssh连接服务器中文乱码</title>
      <link href="/2018/05/24/mac-mac%E4%B8%ADTerminal%E6%88%96Iterm2-ssh%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
      <url>/2018/05/24/mac-mac%E4%B8%ADTerminal%E6%88%96Iterm2-ssh%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
      <content type="html"><![CDATA[<h2 id="mac-mac中Terminal或Iterm2-ssh连接服务器中文乱码"><a href="#mac-mac中Terminal或Iterm2-ssh连接服务器中文乱码" class="headerlink" title="mac - mac中Terminal或Iterm2 ssh连接服务器中文乱码"></a>mac - mac中Terminal或Iterm2 ssh连接服务器中文乱码</h2><p>mac中Terminal或Iterm2 ssh连接服务器中文乱码，大多是由于本地终端编码和服务器编码不一致  </p><h3 id="本地终端中文不乱吗，ssh连接服务器中文乱码"><a href="#本地终端中文不乱吗，ssh连接服务器中文乱码" class="headerlink" title="本地终端中文不乱吗，ssh连接服务器中文乱码"></a>本地终端中文不乱吗，ssh连接服务器中文乱码</h3><p>修改文件：~/.vimrc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936</span><br><span class="line"><span class="built_in">set</span> termencoding=utf-8</span><br><span class="line"><span class="built_in">set</span> encoding=utf-8</span><br></pre></td></tr></table></figure><h3 id="服务器编码和ssh连接后的编码不一致"><a href="#服务器编码和ssh连接后的编码不一致" class="headerlink" title="服务器编码和ssh连接后的编码不一致"></a>服务器编码和ssh连接后的编码不一致</h3><p>mac 使用ssh命令会发送本地语言环境到目标服务器</p><p>解决办法：</p><p>修改配置文件：/etc/ssh/ssh_config（用root权限）</p><p>将内容：SendEnv LANG LC_* 注释</p>]]></content>
      
      <categories>
          
          <category> mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Centos7 - 安装Hadoop集群</title>
      <link href="/2018/05/24/Centos7-%E5%AE%89%E8%A3%85Hadoop%E9%9B%86%E7%BE%A4/"/>
      <url>/2018/05/24/Centos7-%E5%AE%89%E8%A3%85Hadoop%E9%9B%86%E7%BE%A4/</url>
      <content type="html"><![CDATA[<p>在Centos7系统上进行安装，采用hadoop2.7.1</p><h3 id="下载相关软件"><a href="#下载相关软件" class="headerlink" title="下载相关软件"></a>下载相关软件</h3><p>hadoop下载：<br><a href="http://hadoop.apache.org/releases.html" target="_blank" rel="noopener">http://hadoop.apache.org/releases.html</a><br>官网上提供的是hadoop源码包和32位安装包，我的centos7是64位，所以找了一个别人用源码在Centos7上编译好的安装包。也可以自己下载源码编译。</p><p>jdk1.8下载：<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="配置机器"><a href="#配置机器" class="headerlink" title="配置机器"></a>配置机器</h4><p>搭建三个机器为例：node-1、node-2、node-3  </p><ul><li>node-1:\&lt;NameNode>  [ResourceManager]</li><li>node-2:\&lt;DataNode>  \&lt;SecondaryNameNode>  [NodeManager]</li><li>node-3:\&lt;DataNode>  [NodeManager]</li></ul><h5 id="修改机器名称"><a href="#修改机器名称" class="headerlink" title="修改机器名称"></a>修改机器名称</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意，centos7以下版本是直接修改/etc/network文件</span></span><br><span class="line"><span class="comment"># hostnamectl set-hostname &lt;host-name&gt;</span></span><br><span class="line">hostnamectl <span class="built_in">set</span>-hostname node-1</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h5 id="设置主机名映射"><a href="#设置主机名映射" class="headerlink" title="设置主机名映射"></a>设置主机名映射</h5><p>将主机名和ip地址映射起来，在三台机器中都配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">172.16.199.129 node-1</span><br><span class="line">172.16.199.130 node-2</span><br><span class="line">172.16.199.131 node-3</span><br></pre></td></tr></table></figure><h5 id="配置三台机器ssh免密码登录"><a href="#配置三台机器ssh免密码登录" class="headerlink" title="配置三台机器ssh免密码登录"></a>配置三台机器ssh免密码登录</h5><ol><li>在node-1中生成密匙（私匙id_ras、公匙id_rsa.pub）:ssh-keygen -t rsa</li><li>将公匙id_rsa.pub拷贝到要进行ssh登录的机器上：ssh-copy-id -id &lt;机器名称&gt;</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在node-1中：</span></span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">ssh-copy-id node-2</span><br><span class="line">ssh-copy-id node-3</span><br></pre></td></tr></table></figure><h5 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --state<span class="comment">#查看防火墙状态</span></span><br><span class="line">firewall-cmd --reload<span class="comment">#重启firewall</span>systemctl stop firewalld.service<span class="comment">#停止firewall</span>systemctl <span class="built_in">disable</span> firewalld.service<span class="comment">#禁止firewall开机启动</span></span><br></pre></td></tr></table></figure><h4 id="安装jdk1-8"><a href="#安装jdk1-8" class="headerlink" title="安装jdk1.8"></a>安装jdk1.8</h4><p>hadoop是依赖于jdk环境的<br>在hadoop中可以看到有很多jar包，所以hadoop的启动必须有jdk环境<br>配置好jdk环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/program/java/jdk1.8.0_171</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br></pre></td></tr></table></figure><h3 id="安装hadoop"><a href="#安装hadoop" class="headerlink" title="安装hadoop"></a>安装hadoop</h3><p>下载hadoop64位安装包,我下载的是hadoop-2.7.1-cent0s7-64.tar.gz<br>放在三个服务器下，解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压后文件：hadoop-2.7.1</span></span><br><span class="line">tar -zxvf hadoop-2.7.1-cent0s7-64.tar.gz</span><br></pre></td></tr></table></figure><h3 id="hadoop相关配置"><a href="#hadoop相关配置" class="headerlink" title="hadoop相关配置"></a>hadoop相关配置</h3><p>在node-1机器上进行配置</p><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>进入hadoop-2.7.1的配置目录：hadoop-2.7.1/hadoop-2.7.1/etc/hadoop<br>hadoop的配置文件有两种，</p><ul><li>*-default.xml：配置了hadoop的默认配置</li><li>*-site.xml：配置用户自定义的配置选项</li></ul><p>如果用户想自定义一些属性变量配置，就进入*-site.xml配置，配置之后会覆盖默认配置文件的相应配置；如果没有配置其他的配置选项，则会启动*-default.xml的配置</p><h5 id="修改hadoop-env-sh"><a href="#修改hadoop-env-sh" class="headerlink" title="修改hadoop-env.sh"></a>修改hadoop-env.sh</h5><p>修改自己安装的的jdk路径,hadoop启动时加载jdk：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># export JAVA_HOME=$&#123;JAVA_HOME&#125;</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/program/java/jdk1.8.0_171</span><br></pre></td></tr></table></figure><h5 id="修改hadoop核心配置文件：core-site-xml"><a href="#修改hadoop核心配置文件：core-site-xml" class="headerlink" title="修改hadoop核心配置文件：core-site.xml"></a>修改hadoop核心配置文件：core-site.xml</h5><p>在core-site.xml文件的下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定hadoop运行时产生文件的存储目录,可以指定自己熟悉的目录，默认/tmp/hadoop-$&#123;user.name&#125; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/local/program/server/data/hddata<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Abase for other temporary directories.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定hadoop使用的文件系统，HDFS的老大NameNode的地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://node1:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="修改hdfs-site-xml"><a href="#修改hdfs-site-xml" class="headerlink" title="修改hdfs-site.xml"></a>修改hdfs-site.xml</h5><p>DFS namenode存放配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定HDFS副本数量，默认3 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>node-2:50090<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="修改mapred-site-xml"><a href="#修改mapred-site-xml" class="headerlink" title="修改mapred-site.xml"></a>修改mapred-site.xml</h5><p>mapreduce相关配置，job监控地址和端口等配置文件<br>修改文件名称</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv mapred-site.xml.template mapred-site.xml</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定mapred运行时的框架：yarn，默认local --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="修改yarn-site-xml"><a href="#修改yarn-site-xml" class="headerlink" title="修改yarn-site.xml"></a>修改yarn-site.xml</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定yarn（老大）的地址（ResourceManager） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>node-1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- nodemanager上运行的附属服务，指定mapreduce_shuffle才可以运行mapReduce默认 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="修改slaves"><a href="#修改slaves" class="headerlink" title="修改slaves"></a>修改slaves</h5><p>删除文件内容localhost，指定机器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node-1</span><br><span class="line">node-2</span><br><span class="line">node-3</span><br></pre></td></tr></table></figure><h4 id="配置hadoop环境变量"><a href="#配置hadoop环境变量" class="headerlink" title="配置hadoop环境变量"></a>配置hadoop环境变量</h4><p>将环境变量配置到/etc/profile文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HADOOP_HOME=/usr/<span class="built_in">local</span>/program/server/hadoop-2.7.1</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HADOOP_HOME</span>/bin:<span class="variable">$HADOOP_HOME</span>/sbin</span><br></pre></td></tr></table></figure><p>修改文件后重新加载文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h4 id="全部配置"><a href="#全部配置" class="headerlink" title="全部配置"></a>全部配置</h4><p>将以上所有修改发送到另外两台机器上（node-2,node-3）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scp -r /usr/<span class="built_in">local</span>/program/server/hadoop-2.7.1/ root@node-2:/usr/<span class="built_in">local</span>/program/server/</span><br><span class="line">scp -r /usr/<span class="built_in">local</span>/program/server/hadoop-2.7.1/ root@node-3:/usr/<span class="built_in">local</span>/program/server/</span><br><span class="line">scp -r /etc/profile root@node-2:/etc/</span><br><span class="line">scp -r /etc/profile root@node-3:/etc/</span><br></pre></td></tr></table></figure><p>在node-2,node-3两台机器上分别重新加载/etc/profile文件</p><h3 id="hadoop启动"><a href="#hadoop启动" class="headerlink" title="hadoop启动"></a>hadoop启动</h3><p>hadoop启动，必须要启动HDFS和YARN这两个集群<br>首次启动HDFS时，必须对他进行格式化</p><h4 id="dhfs格式化"><a href="#dhfs格式化" class="headerlink" title="dhfs格式化"></a>dhfs格式化</h4><p>在启动hadoop集群之前，首先必须要进行一个初始化操作  </p><p>格式化只能在初始启动之前启动一次，是对文件系统进行一些初始化操作，因为此时hdfs还不存在；在初始化完成之后，集群启动，之后不能再进行初始化  </p><p>格式化是在hdfs集群的namenode上，也就是node-1机器  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs namenode -format <span class="comment">#或 hadoop namenode -format</span></span><br></pre></td></tr></table></figure><p>格式化完成之后，查看格式化过程中的日志，  </p><p><img src="/2018/05/24/Centos7-安装Hadoop集群/hdfs格式化.png" alt="hdfs格式化">  </p><p>可以看到日志中创建了之前在core-site.xml配置中指定的文件目录<br>进入这个目录可以看到目录下生成的文件：(data/hddata/dfs/name/current/下)  </p><p><img src="/2018/05/24/Centos7-安装Hadoop集群/初始化产生的文件.png" width="410" height="175" alt="初始化产生的文件">   </p><p>在VERSION中有一个clusterID，这个值是每一次hdfs初始化时产生的一个值，一旦重新初始化，这个值就会改变</p><h4 id="启动hadoop集群"><a href="#启动hadoop集群" class="headerlink" title="启动hadoop集群"></a>启动hadoop集群</h4><p>在namenode机器上启动（node-1）</p><h5 id="方式一：共同启动所有节点"><a href="#方式一：共同启动所有节点" class="headerlink" title="方式一：共同启动所有节点"></a>方式一：共同启动所有节点</h5><p>使用脚本，分别启动hdfs和yarn<br>前提：配置了hadoop-2.7.1/etc/hadoop/slaves文件和设置集群中机器的ssh免密登录  </p><p>脚本在hadoop-2.7.1/sbin目录下</p><ul><li>hdfs：start-dfs.sh</li><li>yarn：start-yarn.sh</li></ul><h5 id="方式二：单节点启动"><a href="#方式二：单节点启动" class="headerlink" title="方式二：单节点启动"></a>方式二：单节点启动</h5><p>分节点启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hadoop-daemon.sh start namenode</span><br><span class="line">hadoop-daemon.sh start datanode</span><br><span class="line">yarn-daemon.sh start resourcemanager</span><br><span class="line">yarn-daemon.sh start nodemanager</span><br></pre></td></tr></table></figure><h4 id="使用jps查看启动节点"><a href="#使用jps查看启动节点" class="headerlink" title="使用jps查看启动节点"></a>使用jps查看启动节点</h4><p> <img src="/2018/05/24/Centos7-安装Hadoop集群/node-1jps.png" width="240" height="95" alt="node-1jps">  </p><p> <img src="/2018/05/24/Centos7-安装Hadoop集群/node-2jps.png" width="240" height="85" alt="cnode-2jps">  </p><p> <img src="/2018/05/24/Centos7-安装Hadoop集群/node-3jps.png" width="240" height="65" alt="node-3jps">  </p><h3 id="进入页面访问"><a href="#进入页面访问" class="headerlink" title="进入页面访问"></a>进入页面访问</h3><h4 id="NameNode页面"><a href="#NameNode页面" class="headerlink" title="NameNode页面"></a>NameNode页面</h4><p>访问NameNode页面配置，默认端口50070：</p><blockquote><p>http://【你的NameNode所在机器ip】:50070/  </p></blockquote><p><img src="/2018/05/24/Centos7-安装Hadoop集群/namenode页面访问.png" alt="namenode页面访问"></p><h5 id="测试dfs"><a href="#测试dfs" class="headerlink" title="测试dfs"></a>测试dfs</h5><p>在页面中查看文件系统    </p><p><img src="/2018/05/24/Centos7-安装Hadoop集群/页面查看文件系统.png" alt="页面查看文件系统">  </p><p><img src="/2018/05/24/Centos7-安装Hadoop集群/根目录.png" alt="根目录">  </p><p>进入服务器查看:hdfs dfs -ls /  </p><p>没有任何内容  </p><p>在根目录下创建一个文件夹：hello_hadoop  </p><p> <img src="/2018/05/24/Centos7-安装Hadoop集群/cmd创建文件夹.png" width="500" height="95" alt="cmd创建文件夹"> </p><p><img src="/2018/05/24/Centos7-安装Hadoop集群/页面显示文件夹.png" alt="页面显示文件夹">  </p><h4 id="ResourceManager页面"><a href="#ResourceManager页面" class="headerlink" title="ResourceManager页面"></a>ResourceManager页面</h4><p>访问ResourceManager页面配置，默认端口8088：</p><blockquote><p>http://【你的ResourceManager所在机器ip】:8088/  </p></blockquote><p><img src="/2018/05/24/Centos7-安装Hadoop集群/resourcemanager页面访问.png" alt="resourcemanager页面访问"></p><h5 id="用官方示例运行mapreduce程序"><a href="#用官方示例运行mapreduce程序" class="headerlink" title="用官方示例运行mapreduce程序"></a>用官方示例运行mapreduce程序</h5><p>在hadoop集群中任选一台机器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> hadoop-2.7.1/share/hadoop/mapreduce</span><br><span class="line">hadoop jar hadoop-mapreduce-examples-2.7.1.jar pi 20 50  <span class="comment"># 计算圆周率</span></span><br></pre></td></tr></table></figure><p><img src="/2018/05/24/Centos7-安装Hadoop集群/MapReduce运行示例界面.png" alt="MapReduce运行示例界面"></p>]]></content>
      
      <categories>
          
          <category> Centos7 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos7 </tag>
            
            <tag> Hadoop集群 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Centos7 - 修改系统语言</title>
      <link href="/2018/05/24/Centos7-%E4%BF%AE%E6%94%B9%E7%B3%BB%E7%BB%9F%E8%AF%AD%E8%A8%80/"/>
      <url>/2018/05/24/Centos7-%E4%BF%AE%E6%94%B9%E7%B3%BB%E7%BB%9F%E8%AF%AD%E8%A8%80/</url>
      <content type="html"><![CDATA[<h3 id="修改Centos7系统语言"><a href="#修改Centos7系统语言" class="headerlink" title="修改Centos7系统语言"></a>修改Centos7系统语言</h3><p>如：将系统语言改为中文格式</p><h4 id="使用locale命令"><a href="#使用locale命令" class="headerlink" title="使用locale命令"></a>使用locale命令</h4><p>查看当前系统默认采用的字符集：locale 或 echo $LANG</p><h4 id="修改语言"><a href="#修改语言" class="headerlink" title="修改语言"></a>修改语言</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.查看系统中已经有的语言包（查找中文语言包：zh_CN开头的包）</span></span><br><span class="line">locale -a</span><br><span class="line"><span class="comment"># 2.如果没有，则安装中文语言包</span></span><br><span class="line">yum groupinstall Chinese-support</span><br><span class="line"><span class="comment"># 3.安装后再用命令查看安装好中文包，复制语言包名称</span></span><br><span class="line">locale -a</span><br><span class="line"><span class="comment"># 4.修改系统语言，LANG的值是你上一步找到的包名称</span></span><br><span class="line"><span class="comment"># 方式一</span></span><br><span class="line">vim /etc/locale.conf</span><br><span class="line">LANG=zh_CN.*</span><br><span class="line"><span class="comment"># 方式二（Centos新增命令方式）</span></span><br><span class="line">localectl  <span class="built_in">set</span>-locale LANG=zh_CN.*</span><br></pre></td></tr></table></figure><p>注意，在查看中文语言安装包时，必须复制包名称，否则在修改配置文件或执行命令时名称不一致会造成修改失败，网上给的方式中，名称有可能与你的系统中包名称不一致</p><p>英文：以en_US开头的</p><h3 id="Centos6修改方式"><a href="#Centos6修改方式" class="headerlink" title="Centos6修改方式"></a>Centos6修改方式</h3><p>Centos6中是修改配置文件：/etc/sysconfig/i18n</p><h3 id="用iterm2-ssh连接服务器编码不一致"><a href="#用iterm2-ssh连接服务器编码不一致" class="headerlink" title="用iterm2 ssh连接服务器编码不一致"></a>用iterm2 ssh连接服务器编码不一致</h3><p>我遇到一个问题，在虚拟机中Centos7系统是英文状态，但是用iterm2远程ssh连接，用locale查看，变成了中文状态  </p><p>原因：mac 使用ssh命令会发送本地语言环境到目标服务器</p><h4 id="修改服务器端"><a href="#修改服务器端" class="headerlink" title="修改服务器端"></a>修改服务器端</h4><p>解决：在服务器端，修改文件： vim ~/.bashrc，文件末尾加一行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LANG=<span class="string">'en_US.utf8'</span></span><br></pre></td></tr></table></figure><p>但是这种办法不通用，没连接一个服务器都要设置</p><h4 id="修改本地"><a href="#修改本地" class="headerlink" title="修改本地"></a>修改本地</h4><p>修改配置文件：/etc/ssh/ssh_config（用root权限）</p><p>将内容：SendEnv LANG LC_* 注释</p>]]></content>
      
      <categories>
          
          <category> Centos7 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos7 </tag>
            
            <tag> 系统语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Centos7 - 安装jdk8</title>
      <link href="/2018/05/17/Centos7-%E5%AE%89%E8%A3%85jdk8/"/>
      <url>/2018/05/17/Centos7-%E5%AE%89%E8%A3%85jdk8/</url>
      <content type="html"><![CDATA[<h3 id="查看本机jdk"><a href="#查看本机jdk" class="headerlink" title="查看本机jdk"></a>查看本机jdk</h3><p>先查看系统有没有自带的jdk  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep java <span class="comment">#查看内置的JDK</span></span><br><span class="line">rpm -e --nodeps jdk相关名称 <span class="comment">#如果有，进行卸载</span></span><br><span class="line">rpm -qa | grep java <span class="comment">#查看是否卸载干净</span></span><br></pre></td></tr></table></figure><h3 id="下载安装包安装方式"><a href="#下载安装包安装方式" class="headerlink" title="下载安装包安装方式"></a>下载安装包安装方式</h3><h4 id="下载jdk8"><a href="#下载jdk8" class="headerlink" title="下载jdk8"></a>下载jdk8</h4><p>官网下载jdk8<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p><h4 id="放在系统中，解压"><a href="#放在系统中，解压" class="headerlink" title="放在系统中，解压"></a>放在系统中，解压</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压生成的文件夹jdk1.8.0_171</span></span><br><span class="line">tar -zxvf jdk-8u171-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改配置文件</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL下添加</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/program/java/jdk1.8.0_171</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使配置文件生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h4 id="查看是否安装成功"><a href="#查看是否安装成功" class="headerlink" title="查看是否安装成功"></a>查看是否安装成功</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br><span class="line">java</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Centos7 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos7 </tag>
            
            <tag> jdk8 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mac 使用scp或iTerm2+rz、sz上传下载文件</title>
      <link href="/2018/05/16/mac-%E4%BD%BF%E7%94%A8scp%E6%88%96iTerm2-rz%E3%80%81sz%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/"/>
      <url>/2018/05/16/mac-%E4%BD%BF%E7%94%A8scp%E6%88%96iTerm2-rz%E3%80%81sz%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在Windows下可以使用上传下载工具sz与rz，但是mac下一般都是通过scp命令来完成的<br>在有些时候不能使用scp，比如目前公司登录服务器需要经过跳板机，所以可以使用iTerm安装rz、sz进行上传下载</p><h3 id="使用iterm2使用scp命令"><a href="#使用iterm2使用scp命令" class="headerlink" title="使用iterm2使用scp命令"></a>使用iterm2使用scp命令</h3><h4 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h4><h5 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h5><p>scp 【本地文件路径】 【服务器用户名】@【服务器ip】：【服务器文件存放路径】</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp local_folder remote_username@remote_ip:remote_folder</span><br></pre></td></tr></table></figure><h5 id="上传文件夹"><a href="#上传文件夹" class="headerlink" title="上传文件夹"></a>上传文件夹</h5><p>加-r参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r local_folder remote_username@remote_ip:remote_folder</span><br></pre></td></tr></table></figure><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><h5 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h5><p>scp 【服务器用户名】@【服务器地址】：【服务器上存放文件的路径】【本地文件的路径】</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r remote_username@remote_ip:remote_folder local_folder</span><br></pre></td></tr></table></figure><h4 id="scp参数"><a href="#scp参数" class="headerlink" title="scp参数"></a>scp参数</h4><ul><li>-v 详细显示输出,显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题</li><li>-r 递归处理，递归复制整个目录</li><li>-C 使能压缩选项</li><li>-p 保留原文件的修改时间，访问时间和访问权限。</li><li>-P port 选择传输端口</li><li>-4 强行使用 IPV4 地址 .</li><li>-6 强行使用 IPV6 地址 .</li></ul><h3 id="在iterm2中使用rz、sz"><a href="#在iterm2中使用rz、sz" class="headerlink" title="在iterm2中使用rz、sz"></a>在iterm2中使用rz、sz</h3><h4 id="安装brew-install-lrzsz"><a href="#安装brew-install-lrzsz" class="headerlink" title="安装brew install lrzsz"></a>安装brew install lrzsz</h4><h4 id="下载iterm2相关脚本"><a href="#下载iterm2相关脚本" class="headerlink" title="下载iterm2相关脚本"></a>下载iterm2相关脚本</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p>使用wget命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/bin</span><br><span class="line">sudo wget https://raw.github.com/mmastrac/iterm2-zmodem/master/iterm2-send-zmodem.sh</span><br><span class="line">sudo wget https://raw.github.com/mmastrac/iterm2-zmodem/master/iterm2-recv-zmodem.sh</span><br></pre></td></tr></table></figure><h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><p>直接下载脚本，放在/usr/local/bin目录下<br><a href="https://github.com/mmastrac/iterm2-zmodem" target="_blank" rel="noopener">https://github.com/mmastrac/iterm2-zmodem</a>中的两个脚本文件</p><h4 id="给脚本权限"><a href="#给脚本权限" class="headerlink" title="给脚本权限"></a>给脚本权限</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 /usr/<span class="built_in">local</span>/bin/iterm2-*</span><br></pre></td></tr></table></figure><h4 id="配置iTerm2"><a href="#配置iTerm2" class="headerlink" title="配置iTerm2"></a>配置iTerm2</h4><p>如图：<br><img src="/2018/05/16/mac-使用scp或iTerm2-rz、sz上传下载文件/iTerm配置.png" alt="iTerm配置"></p><table><br>    <tr><br>        <th>Regular Expression</th><br>        <th>Action</th><br>        <th>Parameters</th><br>        <th>Instant</th><br>    </tr><br>    <tr><br>        <td>rz waiting to receive.**B0100</td><br>        <td>Run Silent Coprocess</td><br>        <td>/usr/local/bin/iterm2-send-zmodem.sh</td><br>        <td>选中</td><br>    </tr><br>    <tr><br>        <td>**B00000000000000</td><br>        <td>Run Silent Coprocess</td><br>        <td>/usr/local/bin/iterm2-recv-zmodem.sh</td><br>        <td>选中</td><br>    </tr><br></table><h3 id="服务器安装lrzsz工具"><a href="#服务器安装lrzsz工具" class="headerlink" title="服务器安装lrzsz工具"></a>服务器安装lrzsz工具</h3><h3 id="使用rz、sz"><a href="#使用rz、sz" class="headerlink" title="使用rz、sz"></a>使用rz、sz</h3><p>在服务器上，<br>输入命令rz,出现选择本地文件窗口，选择文件后开始上传  </p>]]></content>
      
      <categories>
          
          <category> mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
            <tag> iTerm </tag>
            
            <tag> sz/rz </tag>
            
            <tag> scp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mac - VMware Fusion虚拟机对centos7设置网络</title>
      <link href="/2018/05/16/mac-VMware-Fusion%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9centos7%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C/"/>
      <url>/2018/05/16/mac-VMware-Fusion%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9centos7%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C/</url>
      <content type="html"><![CDATA[<h3 id="虚拟机设置网络模式"><a href="#虚拟机设置网络模式" class="headerlink" title="虚拟机设置网络模式"></a>虚拟机设置网络模式</h3><p>虚拟机采用NAT模式<br><img src="/2018/05/16/mac-VMware-Fusion虚拟机对centos7设置网络/NAT模式.png" width="453" height="300" alt="NAT模式">  </p><h3 id="设置Centos7的网络配置"><a href="#设置Centos7的网络配置" class="headerlink" title="设置Centos7的网络配置"></a>设置Centos7的网络配置</h3><h4 id="查看mac中vmnet8的gateway"><a href="#查看mac中vmnet8的gateway" class="headerlink" title="查看mac中vmnet8的gateway"></a>查看mac中vmnet8的gateway</h4><p>在mac终端中，查看配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /Library/Preferences/VMware Fusion/vmnet8/nat.conf</span><br></pre></td></tr></table></figure><p><img src="/2018/05/16/mac-VMware-Fusion虚拟机对centos7设置网络/gateway地址.png" width="355" height="120" alt="gateway地址"> </p><h4 id="查看虚拟机可分配地址"><a href="#查看虚拟机可分配地址" class="headerlink" title="查看虚拟机可分配地址"></a>查看虚拟机可分配地址</h4><p>在win10中虚拟机的静态ip可以自己直接设置想用的ip，但是在mac的vmware fusion中不可以，vmware fusion会分配一个ip范围让虚拟机使用，你给Centos设置的静态ip必须在这个范围之内  </p><p>进入mac终端查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /Library/Preferences/VMware\ Fusion/vmnet8/dhcpd.conf</span><br></pre></td></tr></table></figure><p><img src="/2018/05/16/mac-VMware-Fusion虚拟机对centos7设置网络/Vmware_ip范围.png" width="461" height="219" alt="Vmware_ip范围"> </p><h4 id="修改Centos7的配置文件"><a href="#修改Centos7的配置文件" class="headerlink" title="修改Centos7的配置文件"></a>修改Centos7的配置文件</h4><p>修改文件：/etc/sysconfig/network-scripts/ifcfg-ens33  </p><p>配置参数如下，文件中有的变量则修改值，没有变量就进行添加：</p><ul><li>BOOTPROTO=static</li><li>IPADDR=上面mac中找到的ip范围中设置一个（我的是172.16.199.129）</li><li>GATEWAY=设置上面mac中看到的gatway地址（172.16.199.2）</li><li>NETMASK=255.255.255.0</li><li>ONBOOT=yes</li><li>DNS1=8.8.8.8（可以在mac中查看网络-&gt;高级中的DNS地址）</li></ul><p><img src="/2018/05/16/mac-VMware-Fusion虚拟机对centos7设置网络/centos设置ip.png" width="411" height="319" alt="centos设置ip"></p><h4 id="重启网卡"><a href="#重启网卡" class="headerlink" title="重启网卡"></a>重启网卡</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在centos中ping主机和百度<br>在mac主机中ping虚拟机<br>都ping通就说明成功了</p>]]></content>
      
      <categories>
          
          <category> Centos7 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos7 </tag>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mac - iterm2+sshpass+shuttle实现ssh部分功能</title>
      <link href="/2018/05/15/mac-iterm2-sshpass-shuttle%E5%AE%9E%E7%8E%B0ssh%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD/"/>
      <url>/2018/05/15/mac-iterm2-sshpass-shuttle%E5%AE%9E%E7%8E%B0ssh%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<h4 id="安装iterm2"><a href="#安装iterm2" class="headerlink" title="安装iterm2"></a>安装iterm2</h4><h4 id="安装sshpass"><a href="#安装sshpass" class="headerlink" title="安装sshpass"></a>安装sshpass</h4><ol><li>下载sshpass源码</li><li>解压，tar -zxvf sshpass-1.06.tar.gz</li><li>进入解压目录，cd sshpass-1.06</li><li>检测当前环境，编译安装：<br>./configure<br>sudo make<br>sudo make install</li><li>检测是否安装成功：sshpass -h</li></ol><h4 id="安装shuttle"><a href="#安装shuttle" class="headerlink" title="安装shuttle"></a>安装shuttle</h4><h5 id="下载shuttle"><a href="#下载shuttle" class="headerlink" title="下载shuttle"></a>下载shuttle</h5><p>下载地址：<a href="https://fitztrev.github.io/shuttle/" target="_blank" rel="noopener">https://fitztrev.github.io/shuttle/</a>  </p><h5 id="配置shuttle"><a href="#配置shuttle" class="headerlink" title="配置shuttle"></a>配置shuttle</h5><p>点开设置-&gt;编辑，会打开.shuttle.json文件  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_comments"</span>: [</span><br><span class="line">    <span class="string">"Valid terminals include: 'Terminal.app' or 'iTerm'"</span>,</span><br><span class="line">    <span class="string">"In the editor value change 'default' to 'nano', 'vi', or another terminal based editor."</span>,</span><br><span class="line">    <span class="string">"Hosts will also be read from your ~/.ssh/config or /etc/ssh_config file, if available"</span>,</span><br><span class="line">    <span class="string">"For more information on how to configure, please see http://fitztrev.github.io/shuttle/"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"editor"</span>: <span class="string">"default"</span>,</span><br><span class="line">  <span class="attr">"launch_at_login"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"terminal"</span>: <span class="string">"iTerm"</span>,</span><br><span class="line">  <span class="attr">"iTerm_version"</span>: <span class="string">"nightly"</span>,</span><br><span class="line">  <span class="attr">"default_theme"</span>: <span class="string">"Homebrew"</span>,</span><br><span class="line">  <span class="attr">"open_in"</span>: <span class="string">"new"</span>,  </span><br><span class="line">  <span class="attr">"show_ssh_config_hosts"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"ssh_config_ignore_hosts"</span>: [  ],</span><br><span class="line">  <span class="attr">"ssh_config_ignore_keywords"</span>: [  ],</span><br><span class="line">  <span class="attr">"hosts"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"cmd"</span>: <span class="string">"cd ~"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"my iterm"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"Company_Project"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"cmd"</span>: <span class="string">"sshpass -p ceshi123 ssh -o StrictHostKeyChecking=no root@127.0.0.1"</span>,</span><br><span class="line">          <span class="attr">"name"</span>: <span class="string">"测试"</span>,</span><br><span class="line">          <span class="attr">"inTerminal"</span>: <span class="string">"tab"</span>,</span><br><span class="line">          <span class="attr">"theme"</span>: <span class="string">"Homebrew"</span>,</span><br><span class="line">          <span class="attr">"title"</span>: <span class="string">"测试"</span></span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"cmd"</span>: <span class="string">"sshpass -p ceshi123 ssh -o StrictHostKeyChecking=no root@127.0.0.1"</span>,</span><br><span class="line">          <span class="attr">"name"</span>: <span class="string">"测试"</span>,</span><br><span class="line">          <span class="attr">"inTerminal"</span>: <span class="string">"tab"</span>,</span><br><span class="line">          <span class="attr">"theme"</span>: <span class="string">"Homebrew"</span>,</span><br><span class="line">          <span class="attr">"title"</span>: <span class="string">"测试"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象中字段含义</p><ul><li>cmd: 需要执行的命令</li><li>name: 菜单名</li><li>inTerminal: 命令执行窗口模式（可选值：new, tab, current）</li><li>theme: 终端主题</li><li>title: 终端显示标题(缺失时使用name作为标题)</li></ul><h5 id="shuttle效果"><a href="#shuttle效果" class="headerlink" title="shuttle效果"></a>shuttle效果</h5><p>以下是效果图   </p><p><img src="/2018/05/15/mac-iterm2-sshpass-shuttle实现ssh部分功能/配置效果.png" width="315" height="155" alt="配置效果"> </p><p>你可以配置你经常登录的服务器，这样可以免去每次登陆输入地址用户名密码了<br>缺点是服务器的用户名密码能被看到  </p>]]></content>
      
      <categories>
          
          <category> mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
            <tag> ssh </tag>
            
            <tag> shuttle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IntelliJ IDEA技巧-添加类注释和方法注释</title>
      <link href="/2018/04/28/IntelliJ-IDEA%E6%8A%80%E5%B7%A7-%E6%B7%BB%E5%8A%A0%E7%B1%BB%E6%B3%A8%E9%87%8A%E5%92%8C%E6%96%B9%E6%B3%95%E6%B3%A8%E9%87%8A/"/>
      <url>/2018/04/28/IntelliJ-IDEA%E6%8A%80%E5%B7%A7-%E6%B7%BB%E5%8A%A0%E7%B1%BB%E6%B3%A8%E9%87%8A%E5%92%8C%E6%96%B9%E6%B3%95%E6%B3%A8%E9%87%8A/</url>
      <content type="html"><![CDATA[<h3 id="添加文件头注释"><a href="#添加文件头注释" class="headerlink" title="添加文件头注释"></a>添加文件头注释</h3><p>打开设置：<br>Editor-&gt;Filr and Code Templates-&gt;Includes-&gt;File Header</p><p><img src="/2018/04/28/IntelliJ-IDEA技巧-添加类注释和方法注释/设置头注释.png" alt="设置头注释"></p><p>这个注释只是你在生成类文件时在类上方的注释<br>右下角是idea中模板中支持的变量</p><p>我的注释模板 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @program: $&#123;PROJECT_NAME&#125;</span><br><span class="line">* @Package $&#123;PACKAGE_NAME&#125;</span><br><span class="line">* @Description: TODO</span><br><span class="line">* @author Miss.Ning</span><br><span class="line">* @date $&#123;DATE&#125; $&#123;TIME&#125;</span><br><span class="line">* @version V1.0</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="添加方法注释"><a href="#添加方法注释" class="headerlink" title="添加方法注释"></a>添加方法注释</h3><p>Editor-&gt;Live Templates<br>可以自己新建一个自己的注释模板   </p><h4 id="新建模板组"><a href="#新建模板组" class="headerlink" title="新建模板组"></a>新建模板组</h4><p>右上角+号，选择Template Group，建一个属于自己的模板组，我的名字是MyComment<br>模板组可以方许多你自己新建的模板 </p><p><img src="/2018/04/28/IntelliJ-IDEA技巧-添加类注释和方法注释/新建注释模板组.png" alt="新建注释模板组"></p><h4 id="新建模板"><a href="#新建模板" class="headerlink" title="新建模板"></a>新建模板</h4><p>选中刚刚新建的组（我的是MyComment），点击右上角+号，选择Live Template  </p><p><img src="/2018/04/28/IntelliJ-IDEA技巧-添加类注释和方法注释/新建注释模板.png" alt="新建注释模板"></p><ol><li>Abbreviation：这里可以起一个名字，相当于生成注释的提示，可以是一个符号，或是一个字母  </li><li>description：描述，可写可不写</li><li>Template：放你的模板 </li><li>点击define，选择EveryWhere</li><li>点击右边的Edit variables</li><li>右边的Expand可以选择你生成注释的快捷键，默认tab键</li></ol><p>生成注释：你设置的Abbreviation快捷键 + Expand设置的快捷键</p><h5 id="填写基本设置"><a href="#填写基本设置" class="headerlink" title="填写基本设置"></a>填写基本设置</h5><p><img src="/2018/04/28/IntelliJ-IDEA技巧-添加类注释和方法注释/新建方法模板.png" alt="新建方法模板"></p><p><img src="/2018/04/28/IntelliJ-IDEA技巧-添加类注释和方法注释/define.png" width="315" height="385" alt="define"> </p><p>在Edit variables中，设置你在注释模板中的参数：</p><p><img src="/2018/04/28/IntelliJ-IDEA技巧-添加类注释和方法注释/变量设置.png" width="415" height="155" alt="变量设置">  </p><h5 id="自定义注释参数显示"><a href="#自定义注释参数显示" class="headerlink" title="自定义注释参数显示"></a>自定义注释参数显示</h5><p>但是idea中的param参数显示的是一个数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> [param1,param2...]</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 测试生成方法注释的参数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Miss.Ning</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2018/04/28 15:50</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodTest</span><span class="params">(<span class="keyword">int</span> param1, String param2...)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用groovyScript脚本写一个生成参数，将多个参数分行显示<br>如果采用以上的自定义参数模板，那么注释模板也要改变  </p><p><img src="/2018/04/28/IntelliJ-IDEA技巧-添加类注释和方法注释/自定义param.png" width="410" height="155" alt="自定义param">  </p><p>将以下内容写到param的expression中即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groovyScript(&quot;def result=&apos;&apos;; def params=\&quot;$&#123;_1&#125;\&quot;.replaceAll(&apos;[\\\\[|\\\\]|\\\\s]&apos;, &apos;&apos;).split(&apos;,&apos;).toList(); for(i = 0; i &lt; params.size(); i++) &#123;result+=&apos; * @param &apos; + params[i] + &apos;\\t&apos; + ((i &lt; params.size() - 1) ? &apos;\\n&apos; : &apos;&apos;)&#125;; return result&quot;, methodParameters())</span><br></pre></td></tr></table></figure><h5 id="生成注释方式以及注释模板"><a href="#生成注释方式以及注释模板" class="headerlink" title="生成注释方式以及注释模板"></a>生成注释方式以及注释模板</h5><p>Abbreviation是你生成注释打的一个提示，如果你写的是a，那么你在写注释时只用打一个a，按tab键即可生成</p><p>1.普通模板（在你的参数设置使用系统自带的返回参数方法时可用），生成方式：你设置的Abbreviation + tab键</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: $description$ </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Param</span>: $params$ </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: $returns$ </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Miss.Ning </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: $date$ $time$ </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>2.设置我在上面提供的自定义参数，生成方式：你设置的Abbreviation + tab键</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * @Description: $description$ </span><br><span class="line">$params$ </span><br><span class="line"> * @return: $returns$ </span><br><span class="line"> * @Author: Miss.Ning</span><br><span class="line"> * @Date: $date$ $time$ </span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>3.我的习惯设置  生成方式：/* + tab键</p><p>我的模板比较特殊，因为我在生成方法注释时习惯先打/*出现注释，所以我将Abbreviation设为<em>，然后生成注释时先打一个/\</em>，按一下tab快捷键，就生成注释了  </p><p>以下是我的注释模板，注意前后空格哦 （注意哈，我的模板开头少了/*，因为我在生成注释时已经打了一个/*了） </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* </span><br><span class="line"> * @Description: $description$ </span><br><span class="line">$params$ </span><br><span class="line"> * @return: $returns$ </span><br><span class="line"> * @Author: Miss.Ning </span><br><span class="line"> * @Date: $date$ $time$ </span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>以下就是我生成的注释，在方法上输入：/* + tab键生成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 测试生成方法注释的参数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>: param1</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>: param2</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>:</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: Miss.Ning</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Date</span>: 2018/04/28 15:50</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodTest</span><span class="params">(<span class="keyword">int</span> param1, String param2...)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> IntelliJ IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IntelliJ IDEA </tag>
            
            <tag> 添加注释 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mac - 打开MacOS-High-Sierra原生的读写NTFS功能</title>
      <link href="/2018/04/09/mac-%E6%89%93%E5%BC%80MacOS-High-Sierra%E5%8E%9F%E7%94%9F%E7%9A%84%E8%AF%BB%E5%86%99NTFS%E5%8A%9F%E8%83%BD/"/>
      <url>/2018/04/09/mac-%E6%89%93%E5%BC%80MacOS-High-Sierra%E5%8E%9F%E7%94%9F%E7%9A%84%E8%AF%BB%E5%86%99NTFS%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<h3 id="mac-NTFS功能"><a href="#mac-NTFS功能" class="headerlink" title="mac NTFS功能"></a>mac NTFS功能</h3><p>mac下不能直接写入的NTFS格式的磁盘，只支持读，一般我们想要写入数据到移动硬盘，要借助专业的NTFS工具，大多数人使用的是Paragon NTFS for MAC，但是这个工具是收费的，破解版都不能使用，而且有人说这个工具有可能会丢失数据<br>如果你想要节省时间愿意为他付费，可以使用Paragon NTFS for MAC来读写，我试用过，但是感觉不太符合我的习惯  </p><p>有人说这个ntfs限制原先是没有的，  </p><blockquote><p>其实最早在OSX 10.5的时候，OSX其实原生就支持直接写入NTFS的盘的，后来由于微软的限制，把这个功能给屏蔽了，我们可以通过命令行手动打开这个选项。  </p></blockquote><p>网上很多大神分享的方法是通过终端使用命令打开，试过之后发现真的可以  </p><p><strong>注意：执行以下过程之前必须插入你的NTFS驱动器。</strong></p><h3 id="确定你的驱动器名称"><a href="#确定你的驱动器名称" class="headerlink" title="确定你的驱动器名称"></a>确定你的驱动器名称</h3><p>方式一：在Finder中查看你的驱动器名称  </p><p><img src="/2018/04/09/mac-打开MacOS-High-Sierra原生的读写NTFS功能/Finder_name.png" alt="驱动器名称"></p><p>方式二：使用命令行，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diskutil list</span><br></pre></td></tr></table></figure><p><img src="/2018/04/09/mac-打开MacOS-High-Sierra原生的读写NTFS功能/volume_name.png" width="420" height="215" alt="命令行驱动器名称">    </p><p>我的名称是nys<br>注意：驱动器名称最好不要有空格    </p><h3 id="使用命令打开NTFS读写权限"><a href="#使用命令打开NTFS读写权限" class="headerlink" title="使用命令打开NTFS读写权限"></a>使用命令打开NTFS读写权限</h3><p>启动终端，执行如下命令行：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/fstab</span><br></pre></td></tr></table></figure><p>在文件中写入以下内容，注意：内容中的NAME是你的磁盘驱动名称： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL=NAME none ntfs rw,auto,nobrowse</span><br></pre></td></tr></table></figure><p>保存，执行完成之后，你就会发现现在已经可以向磁盘中写入数据了！  </p><h3 id="驱动器位置"><a href="#驱动器位置" class="headerlink" title="驱动器位置"></a>驱动器位置</h3><p>在你推出了你的驱动器，再次插上之后会发现Finder左侧栏中不会出现你的驱动器了<br>有的人是推出再插上驱动器之后不再出现，有的是要关机重启之后才不再出现。<br>你需要找到你的驱动器,你的驱动器是挂在/Volumes上的：  </p><ul><li><p>在Finder->前往 选择：前往文件夹，输入 ：/Volumes  </p><p>  <img src="/2018/04/09/mac-打开MacOS-High-Sierra原生的读写NTFS功能/path.png" alt="驱动器位置">  </p></li><li><p>每次都要前往文件夹很麻烦，可以将这个文件夹固定在桌面中：输入如下命令(注意，volume_name是你的驱动器名称)：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /Volumes/volume_name /Desktop/volume_name</span><br></pre></td></tr></table></figure><h3 id="关于没有成功的情况"><a href="#关于没有成功的情况" class="headerlink" title="关于没有成功的情况"></a>关于没有成功的情况</h3><p>检查你的驱动器名称中是否有空格，如果有，使用“\040”进行转义  </p><p>以上内容是我参考的以下两篇文章:<br><a href="https://bbs.feng.com/read-htm-tid-9932031.html" target="_blank" rel="noopener">https://bbs.feng.com/read-htm-tid-9932031.html</a><br><a href="http://macdrug.com/write-ntfs-drive-macos-sierra/" target="_blank" rel="noopener">http://macdrug.com/write-ntfs-drive-macos-sierra/</a></p>]]></content>
      
      <categories>
          
          <category> mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
            <tag> NTFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo - GitHub Pages + Hexo 搭建个人网站</title>
      <link href="/2018/03/19/hexo-GitHub-Pages-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"/>
      <url>/2018/03/19/hexo-GitHub-Pages-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/</url>
      <content type="html"><![CDATA[<h3 id="搭建GitHub-Pages"><a href="#搭建GitHub-Pages" class="headerlink" title="搭建GitHub Pages"></a>搭建GitHub Pages</h3><p>Github Pages是用户托管在github上的静态网页，因为Github Pages可以给我们提供一个免费的域名，所以我们通常使用他来构建自己的博客<br>登录github,新建一个仓库，名称必须是：你的github名称.github.io</p><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br>hexo环境依赖：git、Node.js</p><h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><ul><li>Windows：下载并安装 git.</li><li>Mac：使用 Homebrew：brew install git<br>安装完成之后配置git与你的github的SSH连接</li></ul><h4 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h4><p>1）先安装nvm(Node Version Manager):之所以需要这个工具，是因为 Node.js 的各种特性都没有稳定下来，所以我们经常由于老项目或尝新的原因，需要切换各种版本。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.25.2/install.sh | bash</span><br></pre></td></tr></table></figure><p>2）6.9是我选择的版本 ,安装好之后可以用npm安装cnpm和nrm，使用淘宝镜像，因为默认的镜像是国外的，访问速度慢。安装完成之后，我们可以用cnpm代替npm安装其他东西</p><blockquote><p>cnpm支持npm除了publish之外的所有命令，所以说你可以放心的使用cnpm来代替npm使用，这样可能使用包管理的时候更加的方便，因为服务器就在国内。但是，有时候如果你的网络情况比较渣的话，用啥都一样。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install 6.9  </span><br><span class="line">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h4 id="配置Hexo"><a href="#配置Hexo" class="headerlink" title="配置Hexo"></a>配置Hexo</h4><p>安装：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>查看是否成功，成功后显示hexo版本  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo v</span><br></pre></td></tr></table></figure><p>新建一个目录，存放你的博客。（我建的文件夹是blog）<br>进入blog目录(注意：以下步骤都是在blog目录下完成的)：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br><span class="line">$ cnpm install</span><br></pre></td></tr></table></figure><p>安装完成之后，体验hexo    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g # 生成  </span><br><span class="line">$ hexo s # 启动服务预览（生成在本地）</span><br></pre></td></tr></table></figure><p>打开本地地址：localhost:4000</p><h4 id="部署Hexo到Github-Pages："><a href="#部署Hexo到Github-Pages：" class="headerlink" title="部署Hexo到Github Pages："></a>部署Hexo到Github Pages：</h4><ul><li>前提：将本地git连接到github上配置好</li><li>在Github上创建的仓库（github名称.github.io），可以通过地址<a href="http://github名称.github.io直接访问，访问的文件就是其中的html静态文件，" target="_blank" rel="noopener">http://github名称.github.io直接访问，访问的文件就是其中的html静态文件，</a></li><li>每次将写好的文章用hexo生成，然后用git提交到github上<br>进入blog目录，打开博客站点的配置文件_config.yml，在文件末尾修改：</li></ul><blockquote><p>deploy:<br>　type: git<br>　repo: <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:yashuning/yashuning.github.io.git<br>　branch: master</p></blockquote><p>注意，这种配置文件格式要求比较严格:<br>如果文件末尾已经有deploy、type等字段，删去，改为以上的内容;<br>type、repo、branch三个变量之前空两格，变量后的：之后空一格</p><p>安装git部署插件：    </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>分别输入以下三条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><ul><li>hexo clean：清除缓存 - 清楚本地的 hexo 下面的public文件夹及里面的文件</li><li>hexo g：生成静态文件 - 在 hexo 下生成public文件夹及里面的文件</li><li>hexo d：部署到 GitHub - 在 hexo 下生成.deploy_git文件夹，并将public里面的内容拷贝过来，git就是将这里面的一些静态文件部署到GitHub Page</li></ul><p>部署完成</p><h3 id="hexo主题"><a href="#hexo主题" class="headerlink" title="hexo主题"></a>hexo主题</h3><p>hexo提供了多款主题，我自己比较喜欢的是next主题<br>进入blog文件夹（自己选择存放博客的文件夹）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>下载完成后，在blog/themes下出现一个next文件夹，这就是你的next主题<br>在blog目录下，更改站点配置文件_config.yml</p><blockquote><p>#Extensions<br>##Plugins: <a href="https://hexo.io/plugins/" target="_blank" rel="noopener">https://hexo.io/plugins/</a><br>##Themes: <a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a><br>#theme: landscape<br>theme: next</p></blockquote><p>将主题改为next</p>]]></content>
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub Pages </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/03/14/hello-world/"/>
      <url>/2018/03/14/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">积分GV</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
