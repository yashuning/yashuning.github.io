<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>java - OCR tess4j识别图片文字</title>
      <link href="/2018/08/22/java-OCR-tess4j%E8%AF%86%E5%88%AB%E5%9B%BE%E7%89%87%E6%96%87%E5%AD%97/"/>
      <url>/2018/08/22/java-OCR-tess4j%E8%AF%86%E5%88%AB%E5%9B%BE%E7%89%87%E6%96%87%E5%AD%97/</url>
      <content type="html"><![CDATA[<h3 id="Tess4j是什么"><a href="#Tess4j是什么" class="headerlink" title="Tess4j是什么"></a>Tess4j是什么</h3><p>Tesseract-OCR支持中文识别，并且开源和提供全套的训练工具，是快速低成本开发的首选。</p><p>Tess4J是Tesseract-OCR提供的一组Java工具类，对Tesseract OCR API.的Java JNA 封装。使java能够通过调用Tess4J的API来使用Tesseract OCR</p><h3 id="使用Tess4j"><a href="#使用Tess4j" class="headerlink" title="使用Tess4j"></a>使用Tess4j</h3><h4 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h4><p>Tess4J运行时会访问系统本地库（如windows的dll库） </p><ul><li>windows环境，则可以直接进行下一步，因为tess4j中的两个jar包：tess4j.jar、lept4j.jar已经内嵌了windows 32和64位DLL库  </li><li>其他环境如mac，tess4j中没有提供相关的dll库，所以需要先安装Tesseract：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install tesseract</span><br></pre></td></tr></table></figure><blockquote><p>windows环境以外的平台，不安装安装Tesseract直接运行会报错：UnsatisfiedLinkError: Unable to load library ‘tesseract’<br>相关信息在github文档中给出了解释和解决办法：<a href="https://github.com/tesseract-ocr/tesseract/wiki" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tesseract/wiki</a></p></blockquote><h4 id="tess4j相关下载地址"><a href="#tess4j相关下载地址" class="headerlink" title="tess4j相关下载地址"></a>tess4j相关下载地址</h4><ul><li>官网地址：<a href="http://tess4j.sourceforge.net/usage.html" target="_blank" rel="noopener">http://tess4j.sourceforge.net/usage.html</a>  </li><li>api文档参考：<a href="http://tess4j.sourceforge.net/docs/docs-3.4/" target="_blank" rel="noopener">http://tess4j.sourceforge.net/docs/docs-3.4/</a></li><li>字库地址：<a href="https://github.com/tesseract-ocr/tessdata/tree/3.04.00" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tessdata/tree/3.04.00</a></li></ul><h4 id="准备项目环境"><a href="#准备项目环境" class="headerlink" title="准备项目环境"></a>准备项目环境</h4><h5 id="创建demo项目，在项目下创建文件夹lib"><a href="#创建demo项目，在项目下创建文件夹lib" class="headerlink" title="创建demo项目，在项目下创建文件夹lib"></a>创建demo项目，在项目下创建文件夹lib</h5><h5 id="jar包"><a href="#jar包" class="headerlink" title="jar包"></a>jar包</h5><p>解压下载好的zip：Tess4J-3.4.8-src.zip  </p><p>将dist目录和lib下的jar包全部拷贝到项目的lib中，build path</p><h5 id="准备语言库"><a href="#准备语言库" class="headerlink" title="准备语言库"></a>准备语言库</h5><p>如果是识别图片中的英文，不需要额外准备字库，如果需要识别中文或其他语言，则需要下载字库</p><p>在<a href="https://github.com/tesseract-ocr/tessdata/tree/3.04.00" target="_blank" rel="noopener">github</a>中找到所需要的字库（中文字库：chi_sim.traineddata）</p><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tess4jTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建识别的图片</span></span><br><span class="line">File imageFile = <span class="keyword">new</span> File(<span class="string">"/.../Downloads/eg.png"</span>);</span><br><span class="line">ITesseract instance = <span class="keyword">new</span> Tesseract();</span><br><span class="line"><span class="comment">//设置tessdata的路径，如果放在项目根目录下则不需要制定，如果不在则指定为tessdata目录的绝对路径</span></span><br><span class="line">instance.setDatapath(<span class="string">"/Users/xxx/.../OCR/Tess4J-3.4.8"</span>);</span><br><span class="line"><span class="comment">//如果是识别英文，不需要以下语句指定，如果识别英文以外的语言，则需要设置识别语言（中文是chi_sim）</span></span><br><span class="line">instance.setLanguage(<span class="string">"chi_sim"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String result = instance.doOCR(imageFile);  </span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125; <span class="keyword">catch</span> (TesseractException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> OCR </tag>
            
            <tag> tess4j </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo - Next 主题添加搜索功能</title>
      <link href="/2018/06/29/hexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/"/>
      <url>/2018/06/29/hexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<p>Next 主题要是 <code>5.1.0</code> 版本的</p><h3 id="使用-LocalSearch-搜索功能"><a href="#使用-LocalSearch-搜索功能" class="headerlink" title="使用 LocalSearch 搜索功能"></a>使用 LocalSearch 搜索功能</h3><h4 id="安装相关插件"><a href="#安装相关插件" class="headerlink" title="安装相关插件"></a>安装相关插件</h4><p>安装搜索插件： <code>hexo-generator-searchdb</code></p><p>在博客根目录下执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><h4 id="配置博客"><a href="#配置博客" class="headerlink" title="配置博客"></a>配置博客</h4><p>安装完成，编辑博客配置文件：<code>_config.yml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><h4 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h4><p>Next 主题自带搜索设置，编辑主题配置文件：<code>_config.yml</code></p><p>找到文件中 Local search 的相关配置，设为 <code>true</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line">local_search:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>hexo 重新部署</p>]]></content>
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Next-搜索 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo - Next 主题添加评论功能</title>
      <link href="/2018/06/29/hexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/"/>
      <url>/2018/06/29/hexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<p>Hexo 的 Next 主题继承了多种评论系统，我在这里介绍两种个人觉得不错的评论系统：Valine 和 gitment</p><h3 id="Valine-评论系统"><a href="#Valine-评论系统" class="headerlink" title="Valine 评论系统"></a>Valine 评论系统</h3><p>使用 Valine 评论系统，这款系统不需要登录便可以登录，没有后端，Next 主题最新已经支持安装</p><ul><li>基于 Leancloud 的系统</li><li>支持 MarkDown 语法</li><li>无后端实现，快速高效</li></ul><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><h5 id="注册-LeanCloud"><a href="#注册-LeanCloud" class="headerlink" title="注册 LeanCloud"></a>注册 LeanCloud</h5><p>因为 Valine 是基于 LeanCloud 系统的，所以先在 LeanCloud 中注册账号</p><p><a href="https://leancloud.cn/dashboard/login.html#/signin" target="_blank" rel="noopener">LeanCloud官网登录入口</a></p><p>注册登陆后，访问控制台，创建应用，选择开发版，创建好之后就生成了 <code>App ID</code> 和 <code>App Key</code></p><h5 id="设置-Next-主题"><a href="#设置-Next-主题" class="headerlink" title="设置 Next 主题"></a>设置 Next 主题</h5><p>在主题的配置文件中，修改关于 valine 的配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Valine.</span></span><br><span class="line"><span class="comment"># You can get your appid and appkey from https://leancloud.cn</span></span><br><span class="line"><span class="comment"># more info please open https://valine.js.org</span></span><br><span class="line">valine:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span> <span class="comment"># 是否开启</span></span><br><span class="line">  appid:   <span class="comment"># 上一步获取的 App ID</span></span><br><span class="line">  appkey:  <span class="comment"># 上一步获取的 App Key</span></span><br><span class="line">  notify: <span class="literal">false</span> <span class="comment"># 新留言是否需要通知 https://github.com/xCss/Valine/wiki</span></span><br><span class="line">  verify: <span class="literal">false</span> <span class="comment"># 是否需要验证，验证比较反人类建议false关闭</span></span><br><span class="line">  placeholder: 请在此输入您的留言 <span class="comment"># 默认留言框内的文字</span></span><br><span class="line">  avatar: mm <span class="comment"># 默认头像</span></span><br><span class="line">  guest_info: nick,mail <span class="comment"># 默认留言框的头部需要访问者输入的信息</span></span><br><span class="line">  pageSize: 10 <span class="comment"># pagination size #默认单页的留言条数</span></span><br></pre></td></tr></table></figure><p>重新部署</p><h4 id="评论管理"><a href="#评论管理" class="headerlink" title="评论管理"></a>评论管理</h4><p>如果想要管理评论，进入 leancloud 官网，找到 <code>控制台</code>-&gt;<code>存储</code>-&gt;<code>commet</code> 中进行管理</p><h3 id="Gitment-评论系统"><a href="#Gitment-评论系统" class="headerlink" title="Gitment 评论系统"></a>Gitment 评论系统</h3><p>gitment，它是基于 github 开发的，是依靠于 <code>GitHub Issues</code> 的评论系统，Next 主题最新已经支持安装</p><p>前提：更新 Next 主题（5.1.2 主题）</p><h4 id="注册OAuth-application"><a href="#注册OAuth-application" class="headerlink" title="注册OAuth application"></a>注册OAuth application</h4><ol><li><p>在 github 中进行注册，进入 <a href="https://github.com/settings/profile" target="_blank" rel="noopener">https://github.com/settings/profile</a></p></li><li><p>点击左侧 Developer settings</p></li><li><p>Register a new application</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Application name:#应用名称</span><br><span class="line">Homepage URL：  #网站URL(填自己的博客主页地址)</span><br><span class="line">Application description#描述</span><br><span class="line">Authorization callback URL:#网站URL(填自己的博客主页地址)</span><br></pre></td></tr></table></figure></li></ol><ol><li>注册完成之后，会得到：<code>Client ID</code> 和 <code>Client Secret</code></li></ol><h4 id="新建存放博客评论仓库"><a href="#新建存放博客评论仓库" class="headerlink" title="新建存放博客评论仓库"></a>新建存放博客评论仓库</h4><p>可以在 github 中建一个项目，专门用来存储你的博客评论</p><h4 id="配置-next-主题文件"><a href="#配置-next-主题文件" class="headerlink" title="配置 next 主题文件"></a>配置 next 主题文件</h4><p>编辑主题配置文件：themes\next\ _config.yml，找到有关 gitment 的设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gitment:   </span><br><span class="line">  <span class="built_in">enable</span>:  <span class="literal">true</span></span><br><span class="line">  mint: <span class="literal">true</span>  </span><br><span class="line">  count: <span class="literal">true</span> </span><br><span class="line">  lazy: <span class="literal">false</span>  <span class="comment">#评论懒加载，如果true，则默认不展示评论，点击按钮查看评论</span></span><br><span class="line">  cleanly: <span class="literal">false</span>  </span><br><span class="line">  language: </span><br><span class="line">  github_user: <span class="comment">#github名称</span></span><br><span class="line">  github_repo: BlogComments<span class="comment">#上一步新建存放评论的仓库名</span></span><br><span class="line">  client_id: b8bad0exxxx<span class="comment">#上面注册 OAuth Application 的 Client ID</span></span><br><span class="line">  client_secret: bcee560xxxxxx<span class="comment">#上面注册 OAuth Application 申请的 Client Secret</span></span><br><span class="line">  proxy_gateway: </span><br><span class="line">  redirect_protocol: <span class="comment"># Protocol of redirect_uri with force_redirect_protocol when mint</span></span><br></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>在设置完成之后，hexo 重新部署</p><p>每篇文章都要点击初始化评论按钮</p><h4 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h4><p>评论显示在新建存放评论的仓库中的 <code>issue</code> 中</p><h3 id="关闭某个页面的评论"><a href="#关闭某个页面的评论" class="headerlink" title="关闭某个页面的评论"></a>关闭某个页面的评论</h3><p>在页面的 <code>Front-matter</code> 中添加 <code>comments</code> 字段，设为 <code>false</code></p><p>比如标签页不想要评论，则在标签页面中做以下设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2015-12-16 17:05:24</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"tags"</span></span><br><span class="line">comments: <span class="literal">false</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> Next-评论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo - 分类或标签单词开头大写出现404</title>
      <link href="/2018/06/26/hexo-%E5%88%86%E7%B1%BB%E6%88%96%E6%A0%87%E7%AD%BE%E5%8D%95%E8%AF%8D%E5%BC%80%E5%A4%B4%E5%A4%A7%E5%86%99%E5%87%BA%E7%8E%B0404/"/>
      <url>/2018/06/26/hexo-%E5%88%86%E7%B1%BB%E6%88%96%E6%A0%87%E7%AD%BE%E5%8D%95%E8%AF%8D%E5%BC%80%E5%A4%B4%E5%A4%A7%E5%86%99%E5%87%BA%E7%8E%B0404/</url>
      <content type="html"><![CDATA[<h3 id="404"><a href="#404" class="headerlink" title="404"></a>404</h3><p>突然发现博客中，部分分类打不开，点击出现404，在标签中查看，也是小部分标签点击404，但是在所有文章中该分类下的文章都能打开，后来发现这些404的标签或分类名都是后来修改过的，原先的名称开头是大写名称</p><p>将大写字母改成小写，hexo 部署正确，但是博客上还是不正确出现404</p><p>网上查了许多资料，才发现，git中设置了大小写不敏感</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>修改 git 设置不忽略大小写</p><p>进入博客文件夹，进入 git 目录：.deploy_git ，修改 .git 文件中的配置文件 config，将ignorecase=true 改为 ignorecase=false</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim . deploy_git/.git/config</span><br><span class="line"><span class="comment"># ignorecase = true</span></span><br><span class="line">ignorecase = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>重写清空部署项目</p><p>如果还没有解决，清空部署到 github 上的文件，重新发布：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> .deploy_git</span><br><span class="line">git rm -rf *</span><br><span class="line">git commit -m <span class="string">'clean all file'</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>进入博客文件夹，用 hexo 重新生成部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 404 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习-面向对象11-内部类</title>
      <link href="/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A112-%E5%BD%A2%E5%8F%82%E5%AE%9E%E5%8F%82/"/>
      <url>/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A112-%E5%BD%A2%E5%8F%82%E5%AE%9E%E5%8F%82/</url>
      <content type="html"><![CDATA[<h2 id="形式参数"><a href="#形式参数" class="headerlink" title="形式参数"></a>形式参数</h2><h3 id="类作为形参"><a href="#类作为形参" class="headerlink" title="类作为形参"></a>类作为形参</h3><blockquote><p>在Java中，当对象作为参数传递时，究竟传递的是对象的值，还是对象的引用，这是一个饱受争议的话题。若传的是值，那么函数接收的只是实参的一个副本，函数对形参的操作并不会对实参产生影响；若传的是引用，那么此时对形参的操作则会影响到实参</p></blockquote><p>基本类型和引用类型作为参数传递有很大的区别：</p><h4 id="基本类型作为形参"><a href="#基本类型作为形参" class="headerlink" title="基本类型作为形参"></a>基本类型作为形参</h4><p>基本类型变量作为参数，传递的是实参变量的值的副本，在方法中对形参变量的操作仅仅会改变这个副本，并不会改变原本实参的变量值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">    System.out.println(<span class="string">"实参初始值i："</span>+i);</span><br><span class="line">    method(i);</span><br><span class="line">    System.out.println(<span class="string">"实参最终值i："</span>+i);&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    i = i+<span class="number">1</span>;</span><br><span class="line"> System.out.println(<span class="string">"形参i："</span>+i);</span><br><span class="line">    <span class="keyword">return</span> i;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">实参初始值i：100</span><br><span class="line">形参i：101</span><br><span class="line">实参最终值i：100</span><br></pre></td></tr></table></figure><p><img src="http://pkvv4hyzz.bkt.clouddn.com//image/java/javaSE/javaSE_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1__%E5%8F%82%E6%95%B0_%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BD%9C%E5%BD%A2%E5%8F%822-.png" alt="javaSE_面向对象__参数_基本数据类型作形参"></p><p>方法对形参的改变只能改变实参传递的值的副本，这个副本在栈中是一个新的存储单元，在方法调用完毕，这个存储单元即被销毁，而实参的值存储的单元地址仍在</p><h4 id="类（对象）作为形参"><a href="#类（对象）作为形参" class="headerlink" title="类（对象）作为形参"></a>类（对象）作为形参</h4><p>对象变量作为形参，传递的是对象的引用副本，而不是对象的值的副本，所以方法对形参的改变，直接改变的实参对象的引用副本指向的值，而无法改变实参引用指向的对象地址</p><h5 id="对象作为形参-修改实参对象参数"><a href="#对象作为形参-修改实参对象参数" class="headerlink" title="对象作为形参,修改实参对象参数"></a>对象作为形参,修改实参对象参数</h5><p>demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Student [age="</span> + age + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">StudentDemo sDemo = <span class="keyword">new</span> StudentDemo();</span><br><span class="line">Student student = <span class="keyword">new</span> Student(<span class="number">10</span>,<span class="string">"实参student"</span>);</span><br><span class="line">System.out.println(<span class="string">"实参student初始值："</span>+student);</span><br><span class="line">sDemo.test(student);</span><br><span class="line">System.out.println(<span class="string">"实参student最终值："</span>+student);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">test</span><span class="params">(Student s)</span> </span>&#123;</span><br><span class="line">s.setAge(<span class="number">20</span>);</span><br><span class="line">s.setName(<span class="string">"形参s"</span>);</span><br><span class="line">System.out.println(<span class="string">"形参s值："</span>+s);</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">实参student初始值：Student [age=10, name=实参student]</span><br><span class="line">形参s值：Student [age=20, name=形参s]</span><br><span class="line">实参student最终值：Student [age=20, name=形参s]</span><br></pre></td></tr></table></figure><p>在上面的例子中，实参student对象赋值在堆内存中开辟空间0x001，调用方法test，将student对象引用拷贝一个引用副本赋值给形参s，此时形参s和实参student都指向的是同一个内存空间对象地址0x001，在test方法中对s指向的对象做操作，所以最后实参student的参数值也改变，但是实参引用指向的地址没有改变，仍旧是0x001</p><p><img src="http://pkvv4hyzz.bkt.clouddn.com//image/java/javaSE/javaSE_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1__%E5%8F%82%E6%95%B0_%E5%AF%B9%E8%B1%A1%E4%BD%9C%E5%BD%A2%E5%8F%82.png" alt="javaSE_面向对象__参数_对象作形参"></p><h5 id="改变形参对象"><a href="#改变形参对象" class="headerlink" title="改变形参对象"></a>改变形参对象</h5><p>在方法中给形参指向新的对象，看看结果是否能改变实参</p><p>将添加test2方法调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">test2</span><span class="params">(Student s)</span> </span>&#123;</span><br><span class="line">s=<span class="keyword">null</span>;</span><br><span class="line">System.out.println(<span class="string">"形参s值："</span>+s);</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">实参student初始值：Student [age=10, name=实参student]</span><br><span class="line">形参s值：null</span><br><span class="line">实参student最终值：Student [age=10, name=实参student]</span><br></pre></td></tr></table></figure><p>结果是原本student对象，而不是test2方法中返回的null</p><p>在test2方法中，将引用的副本s置为null，是将引用的副本s指向从原本堆中的student对象0x001指向了null，并没有销毁原本的student对象空间，原本实参student的引用也一直存在，还是指向原先的堆内存对象地址0x001，所以输出的student还是最初的值</p><p><img src="http://pkvv4hyzz.bkt.clouddn.com//image/java/javaSE/javaSE_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1__%E5%8F%82%E6%95%B0_%E5%AF%B9%E8%B1%A1%E4%BD%9C%E5%BD%A2%E5%8F%82%28null%29.png" alt="javaSE_面向对象__参数_对象作形参null"></p><p>将添加test3方法调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">test3</span><span class="params">(Student s)</span> </span>&#123;</span><br><span class="line">s=<span class="keyword">new</span> Student(<span class="number">30</span>,<span class="string">"形参s值"</span>);</span><br><span class="line">System.out.println(<span class="string">"形参s值："</span>+s);</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">实参student初始值：Student [age=10, name=实参student]</span><br><span class="line">形参s值：Student [age=30, name=形参s值]</span><br><span class="line">实参student最终值：Student [age=10, name=实参student]</span><br></pre></td></tr></table></figure><p>上面两个test方法，都没有修改实参student值，因为在test方法中将形参原本指向student引用指向改变了，无论是指向为null还是指向了新的student对象，都跟原先的实参student无关，实参引用所指向地址以及地址中保存的值的参数也没有被改变</p><h5 id="形参交换"><a href="#形参交换" class="headerlink" title="形参交换"></a>形参交换</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Employee [name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Employee aemployee = <span class="keyword">new</span> Employee(<span class="string">"zs"</span>);</span><br><span class="line">Employee bemployee = <span class="keyword">new</span> Employee(<span class="string">"ls"</span>);</span><br><span class="line">swap(aemployee, bemployee);</span><br><span class="line">System.out.println(<span class="string">"aemployee:"</span>+aemployee);</span><br><span class="line">System.out.println(<span class="string">"bemployee:"</span>+bemployee);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Employee x,Employee y)</span> </span>&#123;</span><br><span class="line">Employee temp = x;</span><br><span class="line">x = y;</span><br><span class="line">y = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aemployee:Employee [name=zs]</span><br><span class="line">bemployee:Employee [name=ls]</span><br></pre></td></tr></table></figure><p>方法没有改变存储在实参变量 a 和 b 中的对象引用。 swap 方法的形参 x 和 y 初始化的值是实参 a 和 b 对象引用的拷贝， 所以这个方法最终交换的是这两个引用的拷贝</p><h4 id="包装类作为形参"><a href="#包装类作为形参" class="headerlink" title="包装类作为形参"></a>包装类作为形参</h4><p>Integer、String、Character等包装类呢，他们也是对象，那么是否跟对象作为形参一样呢</p><p>int是基本类型，那Integer是对象，是不是最终值就会被改变呢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Integer i = <span class="number">500</span>;</span><br><span class="line">System.out.println(<span class="string">"实参初始值i："</span>+i);</span><br><span class="line">method(i);</span><br><span class="line">System.out.println(<span class="string">"实参最终值i："</span>+i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">method</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">i = i+<span class="number">1</span>;</span><br><span class="line">System.out.println(<span class="string">"形参i："</span>+i);</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">实参初始值i：500</span><br><span class="line">形参i：501</span><br><span class="line">实参最终值i：500</span><br></pre></td></tr></table></figure><p>为什么Integer类型是对象，按理来说传递的是引用类型，修改对象的值后，最终输出结果应该是501，可是事实不是这样</p><p>原因：来看下Integer源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码中表明Integer的类变量类型被定义为 final ，所以无法被修改，如果对变量做操作，那么会重新生成一个对象指向形参i，最后main中实参i的值还是指向原本的对象，值不变</p><blockquote><p>在    Integer 中，int值在 -128 - 127 之间，会被放入Integer的Cache缓存中，只要访问 -128 - 127 之间的相同的数字，就会被指向同一片缓存空间</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This method will always cache values in the range -128 to 127,</span></span><br><span class="line"><span class="comment"> * inclusive, and may cache other values outside of this range</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://dailycast.github.io/Java-%E5%BD%A2%E5%8F%82%E4%B8%8E%E5%AE%9E%E5%8F%82/" target="_blank" rel="noopener">Integer拆箱装箱、做形参以及形参实参概念讲解</a></p><h3 id="接口作为参数"><a href="#接口作为参数" class="headerlink" title="接口作为参数"></a>接口作为参数</h3><p>接口作为形参，需要将接口实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Eat</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eatFish</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Eat</span></span>&#123;</span><br><span class="line"><span class="function">publi <span class="keyword">void</span> <span class="title">eatFish</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"去吃鱼"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EatDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">EatDemo eatDemo = <span class="keyword">new</span> EatDemo();</span><br><span class="line">Eat eat = <span class="keyword">new</span> Person();</span><br><span class="line">eatDemo.test(eat);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Eat e)</span></span>&#123;</span><br><span class="line">e.eatFish();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口作为形参，需要的是该接口的实现类对象</p><h3 id="参数总结"><a href="#参数总结" class="headerlink" title="参数总结"></a>参数总结</h3><p>方法参数使用：</p><ul><li>一个方法不能修改一个基本数据类型的参数（指实参）</li><li>一个方法可以改变一个对象参数状态（即对象在堆内存中存储的参数）</li><li>一个方法不能让对象参数引用一个新的对象（指实参）</li></ul><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><h3 id="类作为返回值"><a href="#类作为返回值" class="headerlink" title="类作为返回值"></a>类作为返回值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"我要去学习"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">getStudent</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Student();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">StudentDemo sd = <span class="keyword">new</span> StudentDemo();</span><br><span class="line">Student s = sd.getStudent();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类作为方法返回值，返回的是该类的对象</p><h3 id="接口作为返回值"><a href="#接口作为返回值" class="headerlink" title="接口作为返回值"></a>接口作为返回值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Eat</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eatFish</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Eat</span></span>&#123;</span><br><span class="line"><span class="function">publi <span class="keyword">void</span> <span class="title">eatFish</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"人去吃鱼"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EatDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">EatDemo eatDemo = <span class="keyword">new</span> EatDemo();</span><br><span class="line">Eat eat = eatDemo.goEat(); <span class="comment">//多态：Eat eat = new Person();</span></span><br><span class="line">eat.eatFish();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Eat <span class="title">goEat</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口作为返回值，返回的是接口的实现类对象</p>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 形参 </tag>
            
            <tag> 实参 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习-面向对象11-内部类</title>
      <link href="/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A111-%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A111-%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>将一个类定义在另一个类的内部，这个类就是内部类</p><p>内部类在外部类中的位置不同，使用也有所不同</p><p>位置：  </p><ol><li>成员内部类：在外部类的成员位置处，与成员变量、方法位置并列</li><li>局部内部类：在外部类的成员方法中定义，类似局部变量</li></ol><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><ul><li>成员内部类可以直接访问外部类的成员，包括私有成员</li><li>外部类访问成员内部类成员，必须创建成员内部类对象</li></ul><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num=<span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"num="</span>+num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Outer.Inner o = <span class="keyword">new</span> Outer().new Inner();</span><br><span class="line">o.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>一般的类是不能用 static 修饰的，但是内部类可以用 static 修饰，因为内部类可以看成是外部类的一个成员，而类的成员可以是静态成员</p><h5 id="静态内部类案例"><a href="#静态内部类案例" class="headerlink" title="静态内部类案例"></a>静态内部类案例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> numStatic=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//错误，静态内部类不能调用外部非静态成员，只能调用静态成员</span></span><br><span class="line"><span class="comment">//System.out.println("show() - num="+num);</span></span><br><span class="line">System.out.println(<span class="string">"show() - numStatic="</span>+numStatic);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"showStatic() - numStatic="</span>+numStatic);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Outer.Inner inner = <span class="keyword">new</span> Outer.Inner();</span><br><span class="line">inner.show();</span><br><span class="line">inner.showStatic();</span><br><span class="line"><span class="comment">//static 方法：showStatic() 的另一种调用方式，直接调用</span></span><br><span class="line">Outer.Inner.showStatic();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h4><h5 id="通过外部类调用成员内部类方法"><a href="#通过外部类调用成员内部类方法" class="headerlink" title="通过外部类调用成员内部类方法"></a>通过外部类调用成员内部类方法</h5><ul><li>非静态内部类：外部类.内部类 对象名 = new 外部类().new 内部类();</li><li>静态内部类<ul><li>调用静态方法：外部类.内部类.静态方法()；</li><li>调用非静态方法：外部类.内部类 对象名 = new 外部类.内部类(); 对象名.方法()；</li></ul></li></ul><h5 id="在内部类中访问变量"><a href="#在内部类中访问变量" class="headerlink" title="在内部类中访问变量"></a>在内部类中访问变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Outer.Inner inner = <span class="keyword">new</span> Outer().new Inner();</span><br><span class="line">inner.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> numStatic=<span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line">System.out.println(<span class="string">"调用内部类方法的局部变量："</span>+num);</span><br><span class="line">System.out.println(<span class="string">"调用内部类的成员变量："</span>+<span class="keyword">this</span>.num);</span><br><span class="line">System.out.println(<span class="string">"调用外部类的成员变量方式1："</span>+<span class="keyword">new</span> Outer().num);</span><br><span class="line">System.out.println(<span class="string">"调用外部类的成员变量方式2："</span>+Outer.<span class="keyword">this</span>.num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在这个例子中，访问外部类的成员变量方式2中，只有在内部类是非静态时才可以使用，如果是静态，则不能调用</p><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><ul><li>可以直接访问外部类的成员；</li><li>在局部方法内，创建内部类对象，用对象调用内部类的方法</li><li>局部内部类只能访问被 final 修饰的局部变量<ul><li>原因：因为局部变量是随着方法的调用而调用，调用完毕就销毁，而创建的内部类对象在堆内存中不会立即被销毁，此时还是要保留内部类的方法，所以方法调用的变量也要一直保存，所以需要使用关键字 final 使得变量成为常量，数值一直保留不被销毁</li></ul></li></ul><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类，就是一个类的简化写法</p><p>前提：存在一个类或接口，这个类可以是具体类或抽象类</p><p>格式：new 类名/接口名(){重写方法}</p><p>本质：匿名内部类，就是继承了已经存在的一个类或实现了已经存在的一个接口的匿名对象(new了一个没有名字的对象)，</p><h4 id="匿名内部类调用"><a href="#匿名内部类调用" class="headerlink" title="匿名内部类调用"></a>匿名内部类调用</h4><p>匿名方法实现的接口中单个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Inter() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"show 匿名内部类..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Outer o = <span class="keyword">new</span> Outer();</span><br><span class="line">o.method();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名方法实现的接口中有多个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Inter i = <span class="keyword">new</span> Inter() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"show 匿名内部类..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"show2 匿名内部类..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">i.show();</span><br><span class="line">i.show2();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Outer o = <span class="keyword">new</span> Outer();</span><br><span class="line">o.method();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类注意事项"><a href="#匿名内部类注意事项" class="headerlink" title="匿名内部类注意事项"></a>匿名内部类注意事项</h4><ul><li>匿名内部类不能有构造方法</li><li>匿名内部类不能定义任何静态成员、方法和类</li><li>只能创建匿名内部类的一个实例</li><li>匿名内部类也属于局部内部类</li></ul><h4 id="考题"><a href="#考题" class="headerlink" title="考题"></a>考题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span> </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Inter <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Inter() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Hello World!!!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Outer.method().show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 内部类 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习-面向对象10-抽象类与接口</title>
      <link href="/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A110-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/"/>
      <url>/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A110-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>java中，对象都是用类表示的，但是有的类却不能表示描述对象；比如，动物，这个本身不是一个具体的事物，猫是动物，狗也是动物，所以动物不是对象，他是抽象的，那动物在java中怎么表示，这时候就用到抽象类了</p><p>我们可以将动物定义为抽象的，将所有是动物的行为给一个声明，而不给出具体实现，这时动物类就可以被定义为一个抽象类</p><p>java中，将不是具体的对象定义为抽象类，不是具体功能的方法定义成抽象方法</p><h3 id="抽象类定义"><a href="#抽象类定义" class="headerlink" title="抽象类定义"></a>抽象类定义</h3><p>使用关键字 abstract 定义抽象类和抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">methodDemo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类是特殊的类，一般是为了被继承，只声明方法，不实现，方法的具体实现由子类实现</p><h3 id="抽象类特点"><a href="#抽象类特点" class="headerlink" title="抽象类特点"></a>抽象类特点</h3><ul><li>抽象类和抽象方法必须被 abstract 修饰</li><li>抽象类中可以有抽象方法和非抽象方法，但是如果一个类中有抽象方法，这个类必须定义为抽象类</li><li>自己不能被实例化，不能创建对象，但是可以通过多态方式用子类实例化</li><li>抽象类中有构造方法，但是不能用于实例化，是为了子类访问父类数据的初始化</li><li>抽象方法只声明，没有实现，没有方法体；只能由子类重写实现</li><li>抽象的子类<ul><li>如果不想重写抽象类的抽象方法，将子类定义为抽象类</li><li>子类是一个普通的类，必须重写抽象类的所有抽象方法</li></ul></li><li>抽象方法中的构造方法和 static 类方法不能声明为抽象方法</li></ul><p>抽象类的方法，抽象方法，是要求子类必须做的事情，非抽象方法，是提高代码复用性，子类可以使用也可以不使用</p><h3 id="抽象类的注意事项"><a href="#抽象类的注意事项" class="headerlink" title="抽象类的注意事项"></a>抽象类的注意事项</h3><p>abstract 不能和关键字 private、final、static组合</p><ul><li>被 private和final 修饰的方法，不能被子类重写，但是被 abstract 修饰的方法必须被子类重写，会冲突</li><li>被 static 修饰的方法，能被类直接调用，但是 abstract 修饰的方法只是声明，而没有实现，不能调用执行</li></ul><h3 id="抽象类例子"><a href="#抽象类例子" class="headerlink" title="抽象类例子"></a>抽象类例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Animal aDog = <span class="keyword">new</span> Dog(<span class="string">"狗狗"</span>,<span class="number">1</span>);</span><br><span class="line">aDog.eat();</span><br><span class="line">Animal aCat = <span class="keyword">new</span> Cat(<span class="string">"猫猫"</span>,<span class="number">1</span>);</span><br><span class="line">aCat.eat();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name,age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"狗吃骨头"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name,age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"猫吃鱼"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>抽象类，是将不是具体的事物定义为抽象类，但是有共有的特性，比如动物，都有吃，叫等行为，而后天形成的一些行为，有的动物有，有的动物没有，这时用到接口</p><p>接口是所有抽象方法的集合</p><h3 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h3><p>使用关键字 interface 定义，代替类关键字 class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceName</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>接口是抽象类的扩展但不是抽象类；从定义方式可以看出，接口没有关键字 class，说明接口并不是一个类</p><h4 id="接口的特点"><a href="#接口的特点" class="headerlink" title="接口的特点"></a>接口的特点</h4><ul><li>接口访问权限默认 public ，如果显示指为 private 或 protected</li><li>接口中的成员变量会被默认指定为 “public static final”，所以接口中的方法都是常量</li><li>接口中的所有方法都是抽象的，必须是声明，不能有实现的方法</li><li>接口不能被实例化，也没有构造方法</li><li>接口的实现类使用 implements 关键字实现接口，并且必须实现接口中的所有方法</li></ul><h4 id="类和接口的关系"><a href="#类和接口的关系" class="headerlink" title="类和接口的关系"></a>类和接口的关系</h4><p>类与类：单继承，多层继承<br>类与接口：类实现接口，可以多实现  (可以再一个类中实现多个)<br>接口和接口：可以单继承和多继承</p><h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><ol><li>成员区别<ul><li>抽象类<ul><li>成员变量：常量、变量</li><li>构造方法：有</li><li>成员方法：可以有抽象和非抽象成员方法实现</li></ul></li><li>接口<ul><li>成员变量：仅可以有常量</li><li>构造方法：无</li><li>成员方法：只能存在抽象方法，不能存在方法的实现</li></ul></li></ul></li><li>修饰符区别<ul><li>抽象类：成员方法可以有public、protected和default修饰符</li><li>接口：默认修饰符是public。不可以使用其它修饰符</li></ul></li><li>实现类区别<ul><li>抽象类：被继承 - 一个类只能继承一个抽象类</li><li>接口：被实现 - 一个类可以实现多个接口</li></ul></li><li>设计目的<ul><li>抽象类：被继承时是<code>is a</code>的关系，抽象类是对继承体系的共性功能，是对类根源的抽象；如：男人女人的抽象类 - 人，男人很女人都是人，只能单独继承人抽象类，而不可能继承机器人抽象类</li><li>接口：被实现时是<code>hive a</code>的关系，接口是对动作的抽象，是对某个具体的类扩展类功能</li></ul></li></ol>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 抽象类 </tag>
            
            <tag> 接口 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习-面向对象9-三大特性之-多态</title>
      <link href="/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A19-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B-%E5%A4%9A%E6%80%81/"/>
      <url>/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A19-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B-%E5%A4%9A%E6%80%81/</url>
      <content type="html"><![CDATA[<p>多态，是同一个对象，在不同时刻表现不同的行为</p><p>多态的前提：</p><ul><li>存在继承</li><li>子类重写父类方法</li><li>父类引用指向子类对象：父 f = new 子();（向上转型）</li></ul><h3 id="多态的使用"><a href="#多态的使用" class="headerlink" title="多态的使用"></a>多态的使用</h3><h4 id="多态实例"><a href="#多态实例" class="headerlink" title="多态实例"></a>多态实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"show Fu"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"static Fu"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fuMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"fu method"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> num2 = <span class="number">200</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"show zi"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ziMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"zi method"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"static zi"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Fu fu = <span class="keyword">new</span> Zi();</span><br><span class="line">System.out.println(fu.num);</span><br><span class="line"><span class="comment">//System.out.println(fu.num2);//编译不通过</span></span><br><span class="line"><span class="comment">//fu.ziMethod();//编译不通过，</span></span><br><span class="line">fu.fuMethod();</span><br><span class="line">fu.showMethod();</span><br><span class="line">fu.staticMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">fu method</span><br><span class="line">show zi</span><br><span class="line">static Fu</span><br></pre></td></tr></table></figure><p>在上面的程序中，使用多态，fu 加载变量num时，先查看父类中是否有这个变量，发现有 num ，则调用；调用子类特有变量 num2 和 ziMethod() 方法，因为 fu 是向上转型的，转到父类后查看没有变量 num2 和 ziMethod()，则编译不通过；加载父类特有的方法 fuMethod() 时，在子类中找不到，向上转型到父类中，查看有次方法，便调用父类的方法 fuMethod()；加载子类重写父类的方法时，在子类中找到重写后的方法 showMethod()，则直接调用</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>指向子类的父类引用变量，向上转型，所以只能调用父类中有的变量和方法，对于父类不存在子类中特有的方法，则不能访问调用；对于子类没有而父类中有的变量和方法，可以访问调用；如果子类中重写了父类中的方法，那么调用的是子类中重写后的方法</p><p>多态访问成员特点：</p><ul><li>构造方法：创建子类对象时访问父类构造方法，对父类数据进行初始化</li><li>成员变量：编译看左边，运行看左边</li><li>成员方法：编译看左边，运行看右边</li><li>静态方法：编译看左边，运行看左边</li></ul><h3 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h3><ul><li>提高了代码的维护性</li><li>提高了代码的扩展性</li></ul><h3 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h3><p>只能使用父类的成员，而不能使用子类的特有功能</p><p>解决：向下转型，将父类的引用强制转换为子类的引用</p><p>Fu fu = new Fu();<br>Zi zi = (Zi)fu;</p><h3 id="java-多态经典案例"><a href="#java-多态经典案例" class="headerlink" title="java 多态经典案例"></a>java 多态经典案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(D obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"A and D"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(A obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"A and A"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(B obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"B and B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(A obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"B and A"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a1 = <span class="keyword">new</span> A();</span><br><span class="line">        A a2 = <span class="keyword">new</span> B();</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        D d = <span class="keyword">new</span> D();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"1--"</span> + a1.show(b));</span><br><span class="line">        System.out.println(<span class="string">"2--"</span> + a1.show(c));</span><br><span class="line">        System.out.println(<span class="string">"3--"</span> + a1.show(d));</span><br><span class="line">        System.out.println(<span class="string">"4--"</span> + a2.show(b));</span><br><span class="line">        System.out.println(<span class="string">"5--"</span> + a2.show(c));</span><br><span class="line">        System.out.println(<span class="string">"6--"</span> + a2.show(d));</span><br><span class="line">        System.out.println(<span class="string">"7--"</span> + b.show(b));</span><br><span class="line">        System.out.println(<span class="string">"8--"</span> + b.show(c));</span><br><span class="line">        System.out.println(<span class="string">"9--"</span> + b.show(d));      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1--A and A</span><br><span class="line">2--A and A</span><br><span class="line">3--A and D</span><br><span class="line">4--B and A</span><br><span class="line">5--B and A</span><br><span class="line">6--A and D</span><br><span class="line">7--B and B</span><br><span class="line">8--B and B</span><br><span class="line">9--A and D</span><br></pre></td></tr></table></figure><p>在以上程序中，</p><h4 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h4><h5 id="4的结果分析："><a href="#4的结果分析：" class="headerlink" title="4的结果分析："></a>4的结果分析：</h5><p>很多人以为会输出的是 “B and B”，调用的是B中找show(B)方法！  </p><p>为什么没有直接在B中找show(B)方法调用呢，因为调用方法，首先看是谁调用的，a2的类型是A，而不是B，所以在查找方法时，先进入A类查找，而B中的方法 show(B)，是B类中特有的方法，所以不会调用</p><ol><li>a2是A的引用，但是指向的是B类型</li><li>a2调用方法 show(b)，方法参数是B类型</li><li>查看引用类型A是否有父类，没有父类，然后在引用类型A中看是否有此方法</li><li>A中没有参数为B类型的方法，然后找是否有参数为B的父类的方法</li><li>B有父类A，找到方法 show(A)</li><li>然后查看a2的指向类型B中是否重写过该方法</li><li>在B中找到重写A的方法show(A)，所以最后调用的是B中的方法，输出 “B and A ”</li></ol><h5 id="5的结果分析："><a href="#5的结果分析：" class="headerlink" title="5的结果分析："></a>5的结果分析：</h5><ol><li>a2是A的引用，但是指向的是B类型</li><li>a2调用方法 show(c)，方法参数是C类型；</li><li>查看引用类型A是否有父类，没有父类，然后在引用类型A中看是否有此方法</li><li>A中没有参数为C类型的方法，然后找是否有参数为C的父类的方法</li><li>C有父类B，没有参数为B类型的方法；B有父类A，有参数为A类型的方法</li><li>然后查看a2的指向类型B中是否重写过该方法</li><li>在B中找到重写A的方法show(A)，所以最后调用的是B中的方法，输出 “B and A ”</li></ol><h5 id="修改程序"><a href="#修改程序" class="headerlink" title="修改程序"></a>修改程序</h5><h6 id="修改1"><a href="#修改1" class="headerlink" title="修改1"></a>修改1</h6><p>如果在上面的程序中加上A的父类：Fu ，添加方法show(C obj)；其余不变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(C obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"Fu and C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，5的结果会跟之前有所不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5--Fu and C</span><br></pre></td></tr></table></figure><ol><li>a2 是 A 的引用，但是指向的是B类型</li><li>a2 调用方法 show(c)，方法参数是C类型；</li><li>在引用类型A中，查找方法 show(C) 是否存在；</li><li>找不到方法 show(C)，查看引用类型A是否有父类</li><li>有父类Fu，然后在用用类型A的父类Fu中看是否有此方法</li><li>Fu 中有参数为 C 的方法 show(C)</li><li>然后查看指向类型 B 中是否有重写后的方法</li><li>B中没有重写方法 show(C)，最终调用 Fu 类中的方法 show(C)：输出 “ Fu and C ”</li></ol><h6 id="修改2"><a href="#修改2" class="headerlink" title="修改2"></a>修改2</h6><p>如果在上面的程序中加上A的父类：Fu ，添加方法show(C obj)；其余不变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(C obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"Fu and C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(C obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"A and C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，5的结果会跟之前又有所不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5--A and C</span><br></pre></td></tr></table></figure><ol><li>a2 是 A 的引用，但是指向的是B类型</li><li>a2 调用方法 show(c)，方法参数是C类型；</li><li>在引用类型A中，查找方法 show(C) 是否存在；</li><li>找到方法 show(C)，然后查找A的子类：指向类型 B 中是否有重写 show(C) 的方法</li><li>B中没有重写方法 show(C)，调用 A 类中的方法 show(C)：输出 “ A and C ”</li></ol><h6 id="修改3"><a href="#修改3" class="headerlink" title="修改3"></a>修改3</h6><p>如果在B中重写方法 show(C)，那么结果又会不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(C obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">"B and C"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出 “ B and C ” ！！！</p><p>在之前的分析中，5中查看 B 中是否有重写后的方法，之前的程序中B中不存在重写方法，现在B中加上重写方法 show(C)，所以最终调用的是指向类型 B 的重写方法</p><h4 id="可以得出："><a href="#可以得出：" class="headerlink" title="可以得出："></a>可以得出：</h4><p>在多态中，父类对象作为引用变量，子类对象作为被引用对象类型时，引用变量调用的方法必须是父类（引用对象）中定义过的方法，不能调用父类中没有而子类中有的方法！！！</p><p>调用的情况有以下几种：</p><ul><li>被调用方法仅在父类中被定义，而子类中没有被定义，那么调用的方法是父类中的方法</li><li>被调用方法在父类中被定义，在子类中被重写，那么调用的是子类中重写后的方法</li></ul><h4 id="多态调用顺序"><a href="#多态调用顺序" class="headerlink" title="多态调用顺序"></a>多态调用顺序</h4><p>前提：</p><ul><li>被引用变量类型继承引用变量类型</li><li>先看引用变量类型和被引用对象类型（指向类型）</li><li>调用方法必须是引用变量类型对象中存在的方法</li></ul><p>调用顺序：</p><p>this-&gt;引用类型，zi-&gt;被引用类型</p><p>this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)</p><p>在查找方法时，按这四个顺序查找，当某个查找到之后，还要进入被引用类型 zi 中查看是否有重写方法</p><ol><li>进入 this 查找 show(O)<ul><li>有，进入被引用类型  zi 中，查找是否存在重写方法 show(O)<ul><li>有，调用 zi 的重写后的方法 show(O)，结束</li><li>没有，调用 this 中的方法  this.show(O)，结束</li></ul></li><li>没有，执行步骤2</li></ul></li><li>查找 this 是否有父类 super<ul><li>有，进入 super 中 查找是否存在方法 super.show(O)<ul><li>有，进入被引用类型 zi 中，查找是否存在重写方法 show(O)<ul><li>有，调用 zi 的重写后的方法 show(O)，结束</li><li>没有，调用 super 中的方法 super.show(O)，结束</li></ul></li><li>没有，执行步骤3</li></ul></li><li>没有，执行步骤3</li></ul></li><li>查找 this 中是否有 this.show((super)O)，（方法参数是调用方法参数的父类的方法）<ul><li>有，进入被引用类型  zi 中，查找是否存在重写方法 show((super)O)<ul><li>有，调用 zi 的重写后的方法 show((super)O)，结束</li><li>没有，调用 this 中的方法  this.show((super)O)，结束</li></ul></li><li>没有，执行步骤4，（如果是从2到3，那么不会出现这种情况）</li></ul></li><li>查找 this 中是否有 super.show((super)O)<ul><li>有，进入被引用类型  zi 中，查找是否存在重写方法 show((super)O)<ul><li>有，调用 zi 的重写后的方法 show((super)O)，结束</li><li>没有，调用 super 中的方法  super.show((super)O)，结束</li></ul></li></ul></li></ol>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 多态 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习-面向对象4-重写和重载</title>
      <link href="/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A14-%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD/"/>
      <url>/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A14-%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD/</url>
      <content type="html"><![CDATA[<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>重写，是子类有父类的情况下，用于子类对父类的方法进行重写</p><p>重写是子类对父类的非私有方法重新编写方法内容，方法的返回值和形参都与父类的方法相同</p><p>如果在重写过程中，还需要引用父类中的方法功能，可以使用 super 引用父类方法</p><h4 id="重写规则"><a href="#重写规则" class="headerlink" title="重写规则"></a>重写规则</h4><p>@override，重写，也就是覆盖</p><ul><li>重写方法的方法名和方法参数列表必须与被重写的方法完全相同</li><li>访问修饰符的访问权限必须大于被重写方法的访问修饰符权限，但是不能是 private</li><li>重写方法的返回值必须与被重写方法返回值相同</li><li>重写方法若是抛出异常，那么异常必须是与被重写方法抛出的异常一致或是异常的子类</li><li>声明为final的方法不能被重写；声明为static的方法不能被重写，但是能够被再次声明</li></ul><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>重载是指同一个类或子类对父类的都可以</p><p>重载，指两个方法的方法名称相同，但是方法参数列表不同</p><h4 id="重载规则"><a href="#重载规则" class="headerlink" title="重载规则"></a>重载规则</h4><p>overload，一般是用于同一个类中</p><ul><li>重载的方法的方法名称必须相同，而参数列表不能相同</li><li>不同的参数列表，可以是参数的个数不同，参数的类型不同，或参数的顺序不同</li><li>方法的返回值没有要求，可以相同，也可以不同</li><li>方法的访问修饰符可以不同，也可以相同</li><li>方法抛出的异常也可以不同</li></ul><h3 id="重写和重载的区别"><a href="#重写和重载的区别" class="headerlink" title="重写和重载的区别"></a>重写和重载的区别</h3><table><thead><tr><th>区别</th><th>重载</th><th>重写</th></tr></thead><tbody><tr><td>参数列表</td><td>必须不同</td><td>都可以</td></tr><tr><td>返回值</td><td>都可以</td><td>必须相同</td></tr><tr><td>异常</td><td>都可以</td><td>必须相同或是子类</td></tr><tr><td>访问修饰符</td><td>都可以</td><td>必须相同或是权限更大</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 重写 </tag>
            
            <tag> 重载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习-面向对象7-三大特性之-继承</title>
      <link href="/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A17-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B-%E7%BB%A7%E6%89%BF/"/>
      <url>/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A17-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B-%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>java 是面向对象的，对象与对象之间有时会有很多相同的行为以及部分不同的行为，如果两个不同的对象，要有相同的行为，写两个类会出现代码的复用，所以出现了继承</p><p>继承，是子与父的关系，子类继承父类，所以子类可以拥有父类下的成员和方法，具有跟父类相同的行为，而且子类还可以拥有属于自己独特的行为</p><p>继承可以实现代码的复用，使得子类将父类作为基础，在父类拥有的基础上添加新的功能</p><h4 id="继承格式"><a href="#继承格式" class="headerlink" title="继承格式"></a>继承格式</h4><p>使用 extends 关键字进行对类的继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 父类</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父类，又称基类或超类；子类，可以称为派生类</p><h4 id="使用继承的情况"><a href="#使用继承的情况" class="headerlink" title="使用继承的情况"></a>使用继承的情况</h4><p>继承并不是随意使用的，一般情况下，只有子类需要父类的所有方法，才进行继承</p><p>子类对父类是“是”的关系，需要继承，如果是“像”的关系，不需要继承；在父类中不需要考虑子类的特殊性，只需要写一些通用的方法</p><p>如：中国人是人，name中国人可以继承人；大卡车像汽车，都有轮胎，但是大卡车不是汽车，所以不能继承</p><p>对于继承，可以将多个类的共有方法和属性抽取出来，定义成父类，让这些类继承，然后再各自实现自己的新成员和独有行为方法</p><h4 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h4><ul><li>子类拥有父类除 private 之外的所有属性、方法；不能继承父类的构造方法，默认调用无参构造方法，或使用super显式调用</li><li>只能单继承：一个子类只能继承一个父类</li><li>可以多重继承：可以多个类同时继承一个父类</li><li>子类中可以用自己的独特方式实现父类的方法，并且实现自己的属性和方法，对父类进行扩展</li></ul><h3 id="继承的两种方式"><a href="#继承的两种方式" class="headerlink" title="继承的两种方式"></a>继承的两种方式</h3><p>子类继承父类，在子类中会有两种方式使得子类与分类不同</p><ol><li>子类中添加新的成员变量或成员方法</li><li>覆盖重写父类的方法</li></ol><h4 id="添加新的成员"><a href="#添加新的成员" class="headerlink" title="添加新的成员"></a>添加新的成员</h4><p>如果父类中没有子类需要的方法，那么子类中可以添加自己的成员变量或成员方法</p><h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h4><p>如果父类中方法的功能不能满足子类，那子类可以覆盖父类的方法，重写方法的功能，这也叫重写；</p><p>方法名称和方法参数必须相同，使用 @Override 注解；</p><p>如果在子类重写父类的方法中，还想要调用父类的这个方法，可以使用 super 调用</p><p>覆盖父类的方法，方法名、方法参数和父类中的方法必须一致</p><h4 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h4><p>在子类中调用方法：在子类中查找是否有该方法，有-直接执行子类方法；没有-进入父类查找方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodShow</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"methodShow father"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodFather</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"methodFather"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodShow</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"methodShow son"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodSon</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"methodSon"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        son.methodShow();</span><br><span class="line">        son.methodSon();</span><br><span class="line">        son.methodFather();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">methodShow son</span><br><span class="line">methodSon</span><br><span class="line">methodFather</span><br></pre></td></tr></table></figure><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>子类除了不能继承父类的 private 方法，还有构造器也不能继承，</p><p>虽然不能继承，但是子类必须调用父类的构造器：</p><ul><li>父类和子类中都没有构造器或者有无参构造器：子类会默认调用父类无参构造器，程序运行系统自动调用</li><li>父类中没有无参构造器，只有有参构造器：<ul><li>给父类添加无参构造方法</li><li>子类在构造器中用 super(参数) 显示调用父类有参构造器</li></ul></li></ul><h3 id="子类继承父类后初始化的顺序"><a href="#子类继承父类后初始化的顺序" class="headerlink" title="子类继承父类后初始化的顺序"></a>子类继承父类后初始化的顺序</h3><p>在子类继承父类后，在子类初始化之前，必须进行父类的初始化</p><p>类的初始化过程：静态代码块-&gt;构造代码块-&gt;构造方法</p><p>存在子类和父类：</p><p>父类static -&gt; 子类static -&gt; 父类构造代码块、成员变量 -&gt; 父类构造器 -&gt; 子类构造代码块、成员变量-&gt;子类构造器</p><ol><li>加载子类，发现子类继承父类</li><li>进入父类，初始化父类的 static 部分</li><li>然后进入子类，初始化子类的 static 部分</li><li>执行 new 子类时，会先 new 父类，初始化父类的成员变量，然后调用父类构造器</li><li>接着调用子类自身的构造器</li></ol><h4 id="eg1"><a href="#eg1" class="headerlink" title="eg1"></a>eg1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"fu 静态代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"fu 构造代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Fu</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"fu 构造器"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"zi 静态代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"zi 构造代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Zi</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"zi 构造器"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Zi();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fu 静态代码块</span><br><span class="line">zi 静态代码块</span><br><span class="line">fu 构造代码块</span><br><span class="line">fu 构造器</span><br><span class="line">zi 构造代码块</span><br><span class="line">zi 构造器</span><br></pre></td></tr></table></figure><ol><li>先进入 TestDemo，运行 main() </li><li>加载 Zi 类，Zi 类继承了 Fu 类，所以先初始化 Fu 类，初始化静态代码块；</li><li>加载子类，初始化静态代码块</li><li>进入子类构造器，默认先调用父类构造器，去 Fu 中初始化创建对象</li><li>进入 Fu 初始化构造代码，然后 new Fu，调用 Fu 构造器</li><li>回到子类，初始化子类 Zi 的构造代码块，然后执行 Zi 的构造器</li></ol><h4 id="eg2"><a href="#eg2" class="headerlink" title="eg2"></a>eg2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">Animal animalP = <span class="keyword">new</span> Animal(<span class="string">"person and animal"</span>);</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"person static"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"person constructor"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Student();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">Animal animalS = <span class="keyword">new</span> Animal(<span class="string">"cat"</span>);</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"student static1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"student constructor"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"student static2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"animal 构造代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"animal:"</span>+s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"animal static"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">person static</span><br><span class="line">student static1</span><br><span class="line">student static2</span><br><span class="line">animal static</span><br><span class="line">animal:person and animal</span><br><span class="line">person constructor</span><br><span class="line">animal:cat</span><br><span class="line">student 构造代码块</span><br><span class="line">student constructor</span><br></pre></td></tr></table></figure><p>在上面的程序中，初始化顺序是这样的：</p><ol><li><p>先加载 Person 类，初始化 Person 的 static 部分：“person static”</p></li><li><p>运行 main() 方法，运行子类 Student ，初始化 static 部分，按照static 在程序的先后顺序：“student static1，student static2”</p></li><li><p>进行 new Student()，但是有父类 Person 存在，所以默认先调用父类 Person 无参构造器：new Person()，在 new 之前，初始化 Person 的成员变量：animalP</p></li><li><p>初始化 animalP：进入 Animal 初始化 static：animal static；调用 new Animal(“person and animal”)：“animal:person and animal”</p></li><li><p>接着父类 Person 成员变量初始化完成后，调用父类无参构造器：person constructor</p></li><li><p>父类 new 完成，回到子类 Student：初始化子类成员变量：animalS，此时 Animal 已经加载过，所以 static 部分不再执行，然后直接调用 new Animal(“cat”)：“animal:cat”</p></li><li><p>Student 初始化完成，调用子类无参构造器：“student constructor”</p></li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>记住，</p><p>在调用之前，加载类时最先初始化父类、子类中的 static 代码块！！！</p><p>在子类中无论显式使用 super() 还是系统默认调用 super() 调用父类构造方法，都会先进入父类初始化父类的构造代码块和成员变量，然后再调用父类构造器！调用完成之后，在子类中同样是先初始化子类中的构造代码块和成员变量</p>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习-面向对象6-static-关键字</title>
      <link href="/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A16-static-%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A16-static-%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      <content type="html"><![CDATA[<p>static关键字是静态修饰符</p><h3 id="static-的含义"><a href="#static-的含义" class="headerlink" title="static 的含义"></a>static 的含义</h3><p>java中，jvm加载一个类，会动态的给类分配内存空间，根据变量、方法的特性决定内存空间的周期以及销毁时间等  </p><p>通常static表示静态，不是动态，所以在java中，一个类在程序进行编译时分配内存时，如果类中存在 static ，那么 jvm 会给 static 修饰的内容分配一块空间，这块内存空间会随着类一直存在，并且在程序运行期间，所有类的所有实例都可以访问这块内存空间，直到类运行结束，才会释放，</p><h3 id="static-用法"><a href="#static-用法" class="headerlink" title="static 用法"></a>static 用法</h3><p>在要修饰的成员变量或方法上直接使用 static 关键字进行修饰</p><p>被static吸烟室的成员，再累中可以直接通过类名进行访问：类名.成员</p><h4 id="static-变量"><a href="#static-变量" class="headerlink" title="static 变量"></a>static 变量</h4><p>static修饰变量叫做静态变量</p><p>一般类的普通变量，也叫实例变量，jvm 在编译类时，会根据实例来产生实例变量分配内存，如果一个类中有一个实例变量，但是这个类被实例化了两次，那么这两个实例使用类中的实例变量，jvm 会产生两个实例变量的内存空间；</p><p>一个静态变量，在 jvm 开始加载类时会进行初始化，这时会加载静态变量并为这个变量分配唯一一个内存空间，在类中的所有实例都共享这一个空间，使用时通过类名.访问；因为静态变量是唯一的内存空间，所以只要类的一个实例修改这个变量，那么以后其他实例访问这个静态变量，结果都是之前修改过的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChinaPerson</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String nation = <span class="string">"China"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">personInfo</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">System.out.println(name+<span class="string">" 是"</span>+ ChinaPerson.nation);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">ChinaPerson cp1 = <span class="keyword">new</span> ChinaPerson();</span><br><span class="line">cp1.personInfo(<span class="string">"张三"</span>);</span><br><span class="line">ChinaPerson cp2 = <span class="keyword">new</span> ChinaPerson();</span><br><span class="line">cp2.personInfo(<span class="string">"李四"</span>);</span><br><span class="line">cp2.nation = <span class="string">"英国"</span>;</span><br><span class="line">ChinaPerson cp3 = <span class="keyword">new</span> ChinaPerson();</span><br><span class="line">cp3.personInfo(<span class="string">"王五"</span>);</span><br><span class="line">ChinaPerson cp4 = <span class="keyword">new</span> ChinaPerson();</span><br><span class="line">cp4.personInfo(<span class="string">"孙悟空"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">张三 是China人</span><br><span class="line">李四 是China人</span><br><span class="line">王五 是英国人</span><br><span class="line">孙悟空 是英国人</span><br></pre></td></tr></table></figure><p>在以上程序中，nation 变量被 static 修饰，所以程序在编译时 jvm 会给 nation 变量分配一个内存空间  ChinaPerson 的所有的实例都共享这个变量的空间；cp2 在访问过 nation 变量后，修改值为“英国”，在之后 cp3 和 cp4 再进行访问 nation 时，还是同样的一个空间，但是值已经被修改，所以这两个实例拿到的变量值是“英国”</p><h4 id="static-方法"><a href="#static-方法" class="headerlink" title="static 方法"></a>static 方法</h4><p>static 修饰的方法，通过类名.调用，  </p><p>每一个类的实例都可以进行共享调用，不针对某个实例，所以静态方法中不能使用关键字this、super等；记住：this指得是对象，随着对象的创建而创建；static是随着类加载二加载，是唯一的</p><p>静态方法只能访问类的静态成员变量和静态成员方法；但是非静态方法能访问所有静态非静态的变量和方法  </p><p>比如，类的 main 方法，就不能直接通过类名访问静态的成员变量，因为 main() 是 static 的</p><h4 id="static-代码块"><a href="#static-代码块" class="headerlink" title="static 代码块"></a>static 代码块</h4><p>被static 修饰的一段{}包括起来的代码块，再类中独立存在，不能放在方法体内</p><p>jvm加载类的时候回首先加载执行这些独立的代码块，如果类中存在多个静态代码块，那么会按照代码块存在类中的先后顺序进行加载</p><h3 id="static-代码块和-static-方法的区别"><a href="#static-代码块和-static-方法的区别" class="headerlink" title="static 代码块和 static 方法的区别"></a>static 代码块和 static 方法的区别</h3><ul><li>static 代码块<ul><li>代码块在 jvm 加载类时便会初始化并且执行代码块语句</li></ul></li><li>static 方法<ul><li>方法时在 jvm 加载类时初始化加载，但是不执行，只有在被调用时才会执行语句；</li><li>调用不需要类实例化对象，可以直接使用类名进行调用</li></ul></li></ul><h3 id="static-变量和普通成员变量"><a href="#static-变量和普通成员变量" class="headerlink" title="static 变量和普通成员变量"></a>static 变量和普通成员变量</h3><ul><li>static 变量<ul><li>加载：类加载时初始化并创建内存空间，在类从创建到完成过程中只有一个内存空间</li><li>内存：类的所有实例都会共享一个static变量空间，他属于类、</li><li>生命周期：静态变量的生命周期跟类相同，随着类的创建而创建，随着类的销毁而销毁</li><li>调用：通过类名直接调用，也可以通过类的实例对象调用</li></ul></li><li>普通成员变量<ul><li>加载：类加载后，类的实例化对象调用时才会创建内存空间</li><li>内存：有几个类的实例调用变量，变量就会有几个内存空间，普通变量是被实例私有，是属于实例对象</li><li>生命周期：成员变量是随着对象创建而创建，随着对象的销毁而消失</li><li>调用：只能通过类的实例对象调用</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> static 关键字 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习-面向对象5-构造方法</title>
      <link href="/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A15-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
      <url>/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A15-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="什么是构造方法"><a href="#什么是构造方法" class="headerlink" title="什么是构造方法"></a>什么是构造方法</h3><p>构造方法：是类中的一个特殊方法  </p><ul><li>方法名与类名相同</li><li>没有返回值，void也没有</li><li>可以有访问修饰符，但是非访问修饰符不能修饰，如static、final等</li><li>构造方法不能被子类继承重写</li></ul><h3 id="构造方法的作用"><a href="#构造方法的作用" class="headerlink" title="构造方法的作用"></a>构造方法的作用</h3><h4 id="进行初始化"><a href="#进行初始化" class="headerlink" title="进行初始化"></a>进行初始化</h4><p>对对象进行初始化，实例化对象，给对象赋值  </p><p>通常我们要使用一个对象，就要将对象实例化：用new实例化对象，这个 new 就是在调用构造器来创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> studentId;</span><br><span class="line"><span class="comment">//无参构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age,<span class="keyword">int</span> studentId)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span> name = name;</span><br><span class="line"><span class="keyword">this</span> age = age;</span><br><span class="line"><span class="keyword">this</span> studentId = studentId;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><p>有时候会发现一个类中并没有写构造方法，但是可以进行对象的实例化，如：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Stirng[] args)</span></span>&#123;</span><br><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为如果类中没有指定构造方法，那么系统会默认给类添加无参的public修饰的构造方法，方法体为空，但是如果用户自己定义了构造方法，系统将不会再提供空构造方法</p><h3 id="构造器调用构造器"><a href="#构造器调用构造器" class="headerlink" title="构造器调用构造器"></a>构造器调用构造器</h3><p>在一个类中有多个构造方法时，可以进行构造方法调用其他构造方法，使用this关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> String s;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"this is s : "</span>+s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="string">"tom"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="string">"tom"</span>);</span><br><span class="line"><span class="keyword">this</span>();<span class="comment">//错误</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同一个构造方法中不能多次使用this调用构造方法，只允许调用一次，而且必须放在方法的第一行</p>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 构造方法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习-面向对象2-this、super关键字</title>
      <link href="/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12-this%E3%80%81super%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12-this%E3%80%81super%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      <content type="html"><![CDATA[<h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h3><p>this 关键字，代表当前对象，也就是指向对象本身的指针</p><h3 id="this-的用法"><a href="#this-的用法" class="headerlink" title="this 的用法"></a>this 的用法</h3><h4 id="区分成员变量和方法变量"><a href="#区分成员变量和方法变量" class="headerlink" title="区分成员变量和方法变量"></a>区分成员变量和方法变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 setName 中，方法变量 name 和成员变量name名称相同，为区分两个变量，使用 this 关键字引用成员变量；因为 this 关键字代表 Person 对象，修饰的变量 name（this.name）就是 Person 对象的成员变量 name ，另一个 name 采用方法的就近原则，指的是方法参数name  </p><h4 id="调用构造方法"><a href="#调用构造方法" class="headerlink" title="调用构造方法"></a>调用构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(<span class="string">"张三"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在同一个类中，无参构造方法中使用 this 调用另一个有参构造方法</p><h4 id="对类对象的引用"><a href="#对类对象的引用" class="headerlink" title="对类对象的引用"></a>对类对象的引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">psoDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 return this 代表返回当前对象 Person 类  </p><p>注意，如果在匿名内部类中使用，this 代表的是所在匿名类的对象，而不是外部调用类的实例  </p><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisClass</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">thisDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread()&#123;<span class="comment">//匿名类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Hello.<span class="keyword">this</span>.run();<span class="comment">//调用外部类的方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 this 指的是匿名对象，而不是 ThisClass 对象</p><h3 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h3><p>指向当前对象的父类，用super引用直接父类对象的成员；</p><p>super只能调用的是所在类的直接父类，在当前对象最近的父类；不能越过直接的父类调用父类以上的父类中的变量方法</p><h3 id="super用法"><a href="#super用法" class="headerlink" title="super用法"></a>super用法</h3><h4 id="子类构造方法调用父类的构造方法"><a href="#子类构造方法调用父类的构造方法" class="headerlink" title="子类构造方法调用父类的构造方法"></a>子类构造方法调用父类的构造方法</h4><p>super() 方法只能放在子类构造方法的第一行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.print(<span class="string">"This is father"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">(String act)</span></span>&#123;</span><br><span class="line">System.out.print(<span class="string">"father "</span>+ act);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">System.out.print(<span class="string">"This is son"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">(String act)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(act);</span><br><span class="line">System.out.print(<span class="string">"son "</span>+act);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">       Son son = <span class="keyword">new</span> Son(); </span><br><span class="line">       son = <span class="keyword">new</span> Son(<span class="string">"在打游戏..."</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用父类自身对象中同名变量、方法"><a href="#调用父类自身对象中同名变量、方法" class="headerlink" title="调用父类自身对象中同名变量、方法"></a>调用父类自身对象中同名变量、方法</h4><p>如果子类中有变量或者方法和父类的变量或方法重名，那么可以使用super调用父类的变量或方法  </p><p>但是访问父类的成员变量和方法时，注意不能访问父类的私有属性的变量方法！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"father 的age："</span><span class="keyword">super</span>.age);  <span class="comment">//正确</span></span><br><span class="line">        System.out.print(<span class="string">"father 的num："</span>+<span class="keyword">super</span>.num); <span class="comment">//错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序中，Son继承了Father类  </p><p>Son中有跟父类同名成员变量a，同名方法say()</p><ul><li>super.a：调用父类a变量，前提是父类的a变量是公有的  </li><li>super.num：是错误的！因为父类中的num是private，所有子类没有权限访问</li><li>super.say()：调用父类Father的say()方法，而不是子类的say()方法</li></ul><h4 id="调用父类的父类中的方法"><a href="#调用父类的父类中的方法" class="headerlink" title="调用父类的父类中的方法"></a>调用父类的父类中的方法</h4><p>super不能越过直接的父类调用父类以上的父类中的变量方法，但是如果想要访问父类的父类中的方法，在父类继承父类的父类中的成员方法后可以访问 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> numA = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sumNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">num = num+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumA</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>.<span class="keyword">super</span>.sumNum();<span class="comment">//错误</span></span><br><span class="line"><span class="keyword">super</span>.sumNum();<span class="comment">//正确</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="this-和-super-比较"><a href="#this-和-super-比较" class="headerlink" title="this 和 super 比较"></a>this 和 super 比较</h3><ul><li>this 指向当前对象，调用本类的成员变量和方法；super指向父类，调用父类的成员变量和方法</li><li>this和super语句都要放在构造方法中的第一行</li><li>每个子类继承父类之后，在子类的无参构造方法中第一条都会默认隐式调用super()方法调用父类无参构造方法</li><li>this相当于本身对象的一个指针，用来调用当前对象的成员；而super不是指针，只是一个关键字</li></ul>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> this关键字 </tag>
            
            <tag> super关键字 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习-面向对象3-三大特性之-封装</title>
      <link href="/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A13-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B-%E5%B0%81%E8%A3%85/"/>
      <url>/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A13-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B-%E5%B0%81%E8%A3%85/</url>
      <content type="html"><![CDATA[<h3 id="封装简介"><a href="#封装简介" class="headerlink" title="封装简介"></a>封装简介</h3><p>封装的好处：</p><ol><li>隐藏对象细节，提供公共访问方式</li><li>提高代码复用性，减少耦合</li><li>提高安全性，对对象成员更好地控制</li></ol><h4 id="封装格式"><a href="#封装格式" class="headerlink" title="封装格式"></a>封装格式</h4><p>封装属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> 属性类型 属性名;</span><br></pre></td></tr></table></figure><p>封装方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> 方法返回类型 方法名称（参数）;</span><br></pre></td></tr></table></figure><h4 id="封装例子"><a href="#封装例子" class="headerlink" title="封装例子"></a>封装例子</h4><p>封装把一个对象的属性私有化（private），提供一些公共的（public）方法让外界访问属性 </p><p>可以对设置属性入口做一些限制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(age&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      System.out.println(<span class="string">"设置年龄有误:"</span>+age+<span class="string">"岁不属于人类年龄..."</span>);</span><br><span class="line">      &#125; esle&#123;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">p.setName(<span class="string">"张三"</span>);</span><br><span class="line">p.setAge(-<span class="number">10</span>);</span><br><span class="line">p.setAge(<span class="number">20</span>);</span><br><span class="line">System.out.println(p.getName()+<span class="string">"现在"</span>+p. getAge()+<span class="string">"岁了"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p>设置年龄有误:-10岁不属于人类年龄…<br>张三已经20岁了</p><p>修改成员变量为private，提供 getters 和 setters 方法访问对象属性</p>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 封装 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习-面向对象1-java类、变量</title>
      <link href="/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A11-java%E7%B1%BB%E3%80%81%E5%8F%98%E9%87%8F/"/>
      <url>/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A11-java%E7%B1%BB%E3%80%81%E5%8F%98%E9%87%8F/</url>
      <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象概述"><a href="#面向对象概述" class="headerlink" title="面向对象概述"></a>面向对象概述</h3><p>面向对象程序设计（简称 OOP）是当今主流的程序设计范型</p><p>在OOP中， 不必关心对象的具体实现， 只需满足要求即可</p><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>类是对现实生活中事物的抽象，对事物的描述<br>对象，就是事物的一个实体，在系统中用来描述客观事物的一个实体</p><h4 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h4><p>同一个类实例化出来的的所有对象都存在相同的行为</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="构建对象"><a href="#构建对象" class="headerlink" title="构建对象"></a>构建对象</h4><p>使用构造器创建对象实例</p><p>Date date = new Date();</p><p><img src="https://i.imgur.com/stjDLcm.png" alt="javaSE_对象_创建对象"></p><h4 id="对象变量和对象"><a href="#对象变量和对象" class="headerlink" title="对象变量和对象"></a>对象变量和对象</h4><p>一个对象变量不是对象，也没有包含对象，而是引用一个对象，java中任何对象变量的值都是对其他地方的对象的引用</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>java是面向对象的语言，类和对象是核心思想  </p><p>声明类需要用关键字class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称</span>&#123;</span><br><span class="line"><span class="comment">//成员变量</span></span><br><span class="line"><span class="comment">//成员方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类中的变量"><a href="#类中的变量" class="headerlink" title="类中的变量"></a>类中的变量</h3><p>一个类的变量包括：成员变量，类变量，局部变量</p><ul><li>成员变量：定义在类中方法外，又称为实例变量</li><li>类变量：定义在类中方法外，必须为static类型</li><li>局部变量：在方法内部</li></ul><p>java中，一个类是体现一个事物的，而成员变量代表的是事物的属性，类的方法是描述事物的行为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> eyeCount;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">(String stdName)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中，学生是类Student，static 修饰的 eyeCount 变量是类变量，学生有姓名的年龄，所以成员变量是name、age，学生有学习的行为，所以对应的方法是study，方法内的变量 stdName 是局部变量</p><h4 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h4><p>类变量，用static关键字声明，所以也称静态变量，必须在类中方法外进行声明定义  </p><p>在创建对象的实例时类变量被创建，对象被销毁时变量被销毁</p><p>静态变量可以通过：ClassName.类变量名称 的方式访问，通常类变量命名为大写字母  </p><p>静态变量在类加载时初始化</p><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p>成员变量，又称为实例变量  </p><p>在创建对象实例时创建类的成员变量，当对象被销毁时被销毁。  </p><p>如果在创建对象实例时，未显式分配值的成员变量在声明期间程序会自动分配一个初始值，成员变量的初始化值取决于成员变量的类型。</p><table><thead><tr><th>元素类型</th><th>初始值</th></tr></thead><tbody><tr><td>byte</td><td>0</td></tr><tr><td>short</td><td>0</td></tr><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0</td></tr><tr><td>float</td><td>0.0</td></tr><tr><td>double</td><td>0.0</td></tr><tr><td>char</td><td>“\u0000”</td></tr><tr><td>boolean</td><td>false</td></tr><tr><td>对象引用</td><td>null</td></tr></tbody></table><p>静态变量，存储在静态存储区，经常与final关键字共同使用；</p><h4 id="方法变量"><a href="#方法变量" class="headerlink" title="方法变量"></a>方法变量</h4><p>方法变量必须在使用之前进行显示初始化，否则编译报错  </p><p>方法变量仅仅在方法的执行期间存在</p><h4 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h4><p>成员变量和局部变量的区别：</p><ul><li>类中的位置：<ul><li>成员变量：在类中，方法外，整个类都可以访问成员变量</li><li>局部变量：在局部范围，如在方法内，方法内的函数、语句等</li></ul></li><li>内存分配位置：<ul><li>成员变量：在堆内存中，类在编译.class文件时放在堆中的方法区</li><li>局部变量：在栈内存中</li></ul></li><li>生命周期：<ul><li>成员变量：随着对象的建立而产生，随着对象的消失而销毁</li><li>局部变量：方法被调用，创建变量；方法调用完毕，空间被销毁</li></ul></li><li>初始化<ul><li>成员变量：有默认初始化值</li><li>局部变量：没有默认初始化值；必须对变量进行定义赋值才能使用</li></ul></li></ul><p>在成员变量和局部变量名称相同时，在方法执行中采用就近原则</p><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p>java中定义类、方法、修饰符等通常会添加访问修饰符，通过访问修饰符来控制对类、变量、方法的访问权限  </p><p>java中支持4种访问修饰符</p><table><thead><tr><th>修饰符</th><th>当前类内部</th><th>同一包内</th><th>同包内、包外子类</th><th>所有类</th></tr></thead><tbody><tr><td>private</td><td>√</td><td></td><td></td><td></td></tr><tr><td>default</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><ul><li>private：只能被自己访问和修改</li><li>default（默认没有修饰符）：同一包中的类可以访问，声明时没有加修饰符，认为是friendly</li><li>protected：自身，子类及同一个包中类可以访问</li><li>public：可以被所有其他类所访问</li></ul>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 类/对象 </tag>
            
            <tag> 变量 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习-基础3-java内存分析</title>
      <link href="/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%803-java%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/"/>
      <url>/2018/06/25/javaSE%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%803-java%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h3 id="java内存分配"><a href="#java内存分配" class="headerlink" title="java内存分配"></a>java内存分配</h3><p>java程序是在jvm上运行的，所以java程序的内存分配是由jvm进行分配管理的</p><p>java程序在运行时会分配以下几个区域：</p><ul><li>程序计数器：又叫寄存器</li><li>栈：保存局部变量</li><li>堆：存放动态产生的数据，如new出来的对象</li><li>方法区：存储被jvm加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</li><li>常量池：存放常量；存在于方法区（在堆中）</li><li>代码段：存放源程序代码</li><li>数据段：存放static修饰的静态成员</li></ul><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>JVM支持多个线程同时运行，当每一个新线程被创建时，它都将得到它自己的PC寄存器（程序计数器）。  计数器是每个线程独有的一个内存区域  </p><p>线程执行java方法，PC寄存器的值将总是指向下一条将被执行的指令，如果方法是 native 的，程序计数器寄存器的值为空</p><h4 id="栈（stack）"><a href="#栈（stack）" class="headerlink" title="栈（stack）"></a>栈（stack）</h4><h5 id="栈的基本知识"><a href="#栈的基本知识" class="headerlink" title="栈的基本知识"></a>栈的基本知识</h5><p>方法被执行时，会创建一个栈帧。 </p><ul><li>存放内容：局部变量-基本类型的变量（byte、short、int、long、float、double）、对象的引用；操作数栈；帧数据区</li><li>特点：存取速度快；数据的生命周期是方法的运行期间</li><li>在执行方法时，方法所需的局部变量空间已经建立，方法中定义一个变量，java为变量分配内存空间；当变量的作用域消失，java自动释放掉为该变量分配的内存空间</li></ul><h5 id="栈的原理"><a href="#栈的原理" class="headerlink" title="栈的原理"></a>栈的原理</h5><p>栈是以帧为单位保存线程的状态</p><p>运行一个java程序，jvm创建一个线程，并且为这个线程分配一个栈，java程序的执行是对栈进行操作，程序中的方法在执行时会创建一个栈帧，每个方法的运行就是对栈进行入栈到出栈的操作；</p><p>java程序运行，此程序线程激活程序中的方法，jvm就会创建一个栈帧压入此线程的栈中，这个栈帧会存放当前激活方法的参数、方法局部变量等等</p><p><img src="http://pkvv4hyzz.bkt.clouddn.com//image/java/javaSE/jjavaSE_%E5%9F%BA%E7%A1%80_%E5%86%85%E5%AD%98_%E6%A0%88%E5%B8%A7.png" alt="javaSE_基础_内存_栈帧"></p><h5 id="栈的异常"><a href="#栈的异常" class="headerlink" title="栈的异常"></a>栈的异常</h5><p>创建栈帧时没有内存空间，JVM就会抛出StackOverflowError异常  </p><p>如果栈扩展时无法申请到足够的内存，将抛出OutOfMemoryError异常</p><h4 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h4><h5 id="栈的基本知识-1"><a href="#栈的基本知识-1" class="headerlink" title="栈的基本知识"></a>栈的基本知识</h5><p>堆内存：<br>jvm启动后便会创建一个堆；</p><ul><li>存放内容：java程序运行时创建的类实例和数组等对象实例</li><li>特点：可以在运行时动态的分配内存大小；存取速度慢</li><li>堆内存中出现不再指向的对象，java的垃圾回收器便会定时清理</li><li>堆内存因为空间满了而无法再进行扩展分配内存时，会抛出java.lang.OutOfMemoryError:Java heap space异常</li></ul><h5 id="堆原理"><a href="#堆原理" class="headerlink" title="堆原理"></a>堆原理</h5><p>堆是jvm管理所有内存中最重要的一块，所有线程共享的一块区域，在虚拟机jvm启动时创建  </p><p>堆中存放所有的对象实例，但是对象的引用存在在栈中；</p><h5 id="堆空间的释放"><a href="#堆空间的释放" class="headerlink" title="堆空间的释放"></a>堆空间的释放</h5><p>jvm对栈中存放的变量，当程序方法运行结束，jvm会自动释放这些变量的内存空间；而对于堆中创建的对象内存空间，在对象不再被使用时，jvm不会自动释放，而是由垃圾收集器进行回收</p><blockquote><p>java垃圾回收器：垃圾收集器基本上都是采用分代收集算法，所以java堆分为新生代和老生代</p></blockquote><p>堆是垃圾收集器主要管理的一部分区域，又称为GC堆</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区是被java所有线程共享的内存区域，用于存储已被jvm加载的类信息、常量、静态变量、即时编译器编译后的.class文件中的数据。</p><p>方法区无法申请到内存时，将抛出OutOfMemoryError异常</p><h5 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h5><p>常量池是方法区的一部分</p><p>jvm会为每一个编译后的类创建一个常量池；类编译class文件时，还会生成各种直接常量（基本类型变量、string）和其他类型、方法等符号引用，这部分数据会被存放在常量池中  </p><p>常量池具有动态性，编译时产生常量池，将.class文件的数据存放进去，在运行期间也可以将新常量放入，如string类的intern()方法可以做到；所以常量池又称为运行时常量池</p><h3 id="对象内存分析"><a href="#对象内存分析" class="headerlink" title="对象内存分析"></a>对象内存分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">String brand;</span><br><span class="line">String color;</span><br><span class="line"> <span class="keyword">int</span> price;</span><br><span class="line">Phone(String brand,String color,<span class="keyword">int</span> price)&#123;</span><br><span class="line"><span class="keyword">this</span>.brand = brand;</span><br><span class="line"><span class="keyword">this</span>.color = color;</span><br><span class="line"><span class="keyword">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String name)</span></span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String name)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneAct</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Phone p = <span class="keyword">new</span> Phone(<span class="string">"三星"</span>,<span class="string">"银色"</span>,<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line">p.call(<span class="string">"爸爸"</span>);</span><br><span class="line">p.sendMessage(<span class="string">"妈妈"</span>);</span><br><span class="line">Phone p2 = <span class="keyword">new</span> Phone(<span class="string">"苹果"</span>,<span class="string">"金色"</span>,<span class="number">6000</span>);  </span><br><span class="line">p.claa(“朋友”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是内存分析图</p><p><img src="http://pkvv4hyzz.bkt.clouddn.com//image/java/javaSE/javaSE_%E5%9F%BA%E7%A1%80_%E5%86%85%E5%AD%98_%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE.png" alt="javaSE_基础_内存_对象内存图"></p>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 基础 </tag>
            
            <tag> 内存分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习-基础4-数组</title>
      <link href="/2018/05/28/javaSE%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%804-%E6%95%B0%E7%BB%84/"/>
      <url>/2018/05/28/javaSE%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%804-%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<h2 id="数组介绍"><a href="#数组介绍" class="headerlink" title="数组介绍"></a>数组介绍</h2><p>数组是固定大小的存储同一种数据类型的多个元素的集合；  </p><p>可以存放基本数据类型，也可以存放引用数据类型</p><p>数组可以给数组中元素标识</p><h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><h4 id="数组声明"><a href="#数组声明" class="headerlink" title="数组声明"></a>数组声明</h4><ul><li>数据类型[] 数组名：int[] a;</li><li>数据类型 数组名[]：int a[];</li></ul><h4 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h4><h5 id="数组定义格式："><a href="#数组定义格式：" class="headerlink" title="数组定义格式："></a>数组定义格式：</h5><p>数据类型[] 数组名 = new 数据类型[数组长度];<br>或<br>数据类型[] 数组名 = {value1,value2,value3…};<br>数据类型[] 数组名 = new 数据类型[]{value1,value2,value3…};</p><p>用new操作符创建数组</p><p>可以先声明，后定义；也可以声明定义一起</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明并且定义</span></span><br><span class="line"><span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//先声明数组变量arr2，后创建数组赋值给声明的arr2</span></span><br><span class="line"><span class="keyword">double</span>[] arr2;</span><br><span class="line">arr2 = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>初始化：给系统开辟内存空间，并且给数组元素赋值</p><ul><li>动态初始化：必须指定数组长度，系统给数组分配初始值：new 数据类型[数组长度];</li><li>静态初始化：仅指定数组中的元素初始值，长度由系统定义：{value1,value2,value3…};</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态初始化</span></span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>；</span><br><span class="line"><span class="comment">//静态初始化（两种写法）</span></span><br><span class="line"><span class="keyword">int</span>[] b1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>&#125;；</span><br><span class="line"><span class="keyword">int</span>[] b2 = &#123;<span class="number">4</span>,<span class="number">5</span>&#125;；</span><br><span class="line"><span class="comment">//注意，不能动态和静态同时进行，如：</span></span><br><span class="line"><span class="comment">//int[] arr = new int[2]&#123;4,5&#125;；  写法错误！！！</span></span><br></pre></td></tr></table></figure><h3 id="获取数组元素"><a href="#获取数组元素" class="headerlink" title="获取数组元素"></a>获取数组元素</h3><p>访问数组元素是通过数组的索引访问的  </p><p>数组的每个元素有唯一的索引，从数组的第一个元素起，索引从0开始标识，一直到数组长度-1</p><p>数组长度：length方法获取数组的实际长度</p><p>访问数组方式：数组变量名[索引]（0&lt;数组索引&lt;数组长度-1）</p><p>注意，操作数组时，如果访问的数组索引不存在，超过了数组长度，则会报数组越界异常：<code>ArrayIndexOutOfBoundsException</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a = arr[<span class="number">3</span>];<span class="comment">//访问的数组索引不存在：ArrayIndexOutOfBoundsException`</span></span><br></pre></td></tr></table></figure><h2 id="数组内存分配"><a href="#数组内存分配" class="headerlink" title="数组内存分配"></a>数组内存分配</h2><h3 id="数组定义内存分析"><a href="#数组定义内存分析" class="headerlink" title="数组定义内存分析"></a>数组定义内存分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>new 数组内存分析如下： </p><p><img src="http://pkvv4hyzz.bkt.clouddn.com//image/java/javaSE/javaSE_%E5%9F%BA%E7%A1%80_%E6%95%B0%E7%BB%84_%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98.png" alt="javaSE_基础_数组_数组内存"> </p><p>对于分配内存：局部变量和变量名称放在栈中，new的对象放在堆中  </p><p>堆分配内存时，对每一个new出来的对象都有一个地址，对象都会有默认值，如int的默认值是0，引用类型的默认值是null</p><p>栈中的变量在使用完之后会立即销毁；堆中的对象在使用完成之后就会成为垃圾，在java的垃圾回收器空闲时进行回收</p><h3 id="数组之间赋值内存分析"><a href="#数组之间赋值内存分析" class="headerlink" title="数组之间赋值内存分析"></a>数组之间赋值内存分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">arr1[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">arr1[<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line">arr1[<span class="number">2</span>] = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">arr2[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">arr2[<span class="number">1</span>] = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">int</span>[] arr3 = arr1;</span><br><span class="line">arr3[<span class="number">0</span>] = <span class="number">101</span>;</span><br><span class="line">arr3[<span class="number">3</span>] = <span class="number">301</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  结果：arr1:[101，20，301]</span></span><br><span class="line"><span class="comment">  arr2:[100，200]</span></span><br><span class="line"><span class="comment">  arr3:[101，20，301]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>new 数组内存分析如下：</p><p><img src="http://pkvv4hyzz.bkt.clouddn.com//image/java/javaSE/javaSE_%E5%9F%BA%E7%A1%80_%E6%95%B0%E7%BB%84_%E6%95%B0%E7%BB%84%E8%B5%8B%E5%80%BC%E5%86%85%E5%AD%98.png" alt="javaSE_基础_数组_数组赋值内存"></p><p>分析：将数组arr1赋值给数组arr3，实际上是将arr1数组在堆中的对象地址赋值给arr3，所以arr3数组指向的地址是arr1的数组地址，于是arr3数组给数组元素赋值，改变的是堆中创建的0x001地址元素，所以最后arr3操作的是arr1创建的对象</p><h2 id="数组常见异常"><a href="#数组常见异常" class="headerlink" title="数组常见异常"></a>数组常见异常</h2><h3 id="越界异常"><a href="#越界异常" class="headerlink" title="越界异常"></a>越界异常</h3><p>数组下标越界异常：<code>java.lang.IndexOutOfBoundsException</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a = arr[<span class="number">3</span>];<span class="comment">//arr数组的索引为0-2（数组最大索引为：数组长度-1），索引3不存在，报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的程序中，编译不报错，但在运行时会报java.lang.IndexOutOfBoundsException异常  </p><p>原因：数组arr共有3个元素，元素下标分别为：0，1，2；但是变量a访问的是arr[3]，arr数组并没有下标为3的元素，超出了数组的范围，所以会报下标越界异常</p><h3 id="空指针异常"><a href="#空指针异常" class="headerlink" title="空指针异常"></a>空指针异常</h3><p>空指针异常：<code>java.lang.NullPointerException</code>  </p><p>调用了未经初始化的对象或者是不存在的对象 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">arr = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> a = arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序会发生 <code>java.lang.NullPointerException</code> </p><p>原因：在第二句中程序将数组arr赋值为null，原先数组指向堆内存的数组{1,2,3}，现在arr指向null了，此时再通过数组下标访问数组，会报错  </p><h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr=&#123;<span class="number">5</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">34</span>,<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="for循环遍历"><a href="#for循环遍历" class="headerlink" title="for循环遍历"></a>for循环遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历数组中所有元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">System.out.print(arr[i] + <span class="string">","</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for循环加强版遍历"><a href="#for循环加强版遍历" class="headerlink" title="for循环加强版遍历"></a>for循环加强版遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i:arr)&#123;</span><br><span class="line">System.out.print(i + <span class="string">","</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用Arrays工具类"><a href="#使用Arrays工具类" class="headerlink" title="使用Arrays工具类"></a>使用Arrays工具类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure><h3 id="求数组最值"><a href="#求数组最值" class="headerlink" title="求数组最值"></a>求数组最值</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>创建一个临时变量，存储比较出来的最大值</li><li>循环遍历数组，将数组每个元素与临时变量进行比较</li><li>比较后将较大值赋值给临时变量</li><li>比较完成，临时变量存储的就是数组最大值</li></ol><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxNum1</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="comment">//使用临时变量当做数组元素，获取数组最大值</span></span><br><span class="line"><span class="keyword">int</span> maxNum = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&gt;maxNum) maxNum = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxNum2</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="comment">//使用数组角标获取数组最大值</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&gt;arr[index]) index = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组排序算法"><a href="#数组排序算法" class="headerlink" title="数组排序算法"></a>数组排序算法</h3><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><h5 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h5><p>从待排序的一组数据中，选出最小的元素，按顺序放在数组的起始处或末尾处，直到所有的待排序数据都排完</p><p>如：给定元素数为n的数组arr</p><ol><li>第一次，选定arr[0]数组值，与其余待排序数据arr[1]-arr[n-1]进行排序，选出最小元素并与arr[0]交换；此时arr[0]处的值为数组中最小值；</li><li>第二次，选定arr[1]数组值，与其余待排序数据arr[2]-arr[n-1]进行排序，选出最小元素并与arr[1]交换；此时arr[0]、arr[1]处的值为排序好的数组中最小的值；</li><li>…</li><li>第i次，选定arr[i-1]数组值，与其余待排序数据arr[i]-arr[n-1]进行排序，选出最小元素并与arr[i]交换；此时arr[0]、arr[1]…arr[i]处的值为排序好的数组中最小的值；</li><li>第n-1次，选定arr[n-2]数组值，与待排序数据arr[n-1]进行排序，选出最小元素并与arr[i]交换；</li></ol><h5 id="选择排序代码实现"><a href="#选择排序代码实现" class="headerlink" title="选择排序代码实现"></a>选择排序代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; arr.length-<span class="number">1</span>; x++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = x+<span class="number">1</span>; y &lt; arr.length; y++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[x] &gt; arr[y]) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[x];</span><br><span class="line">arr[x] = arr[y];</span><br><span class="line">arr[y] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="选择排序图例"><a href="#选择排序图例" class="headerlink" title="选择排序图例"></a>选择排序图例</h5><p><img src="http://pkvv4hyzz.bkt.clouddn.com//image/java/javaSE/javaSE_%E5%9F%BA%E7%A1%80_%E6%95%B0%E7%BB%84_%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.png" alt="javaSE_基础_数组_选择排序"></p><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><h5 id="选择排序代码实现-1"><a href="#选择排序代码实现-1" class="headerlink" title="选择排序代码实现"></a>选择排序代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; arr.length-<span class="number">1</span>; x++) &#123;</span><br><span class="line"><span class="comment">//-x：前一次比较出的结果不再进行比较   -1：避免y+1角标越界</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; arr.length-x-<span class="number">1</span>; y++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[y] &gt; arr[y+<span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[y];</span><br><span class="line">arr[y] = arr[y+<span class="number">1</span>];</span><br><span class="line">arr[y+<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="冒泡排序图例"><a href="#冒泡排序图例" class="headerlink" title="冒泡排序图例"></a>冒泡排序图例</h5><p><img src="http://pkvv4hyzz.bkt.clouddn.com//image/java/javaSE/javaSE_%E5%9F%BA%E7%A1%80_%E6%95%B0%E7%BB%84_%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png" alt="javaSE_基础_数组_冒泡排序"></p><h4 id="数组逆序"><a href="#数组逆序" class="headerlink" title="数组逆序"></a>数组逆序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length/<span class="number">2</span>;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[i];</span><br><span class="line">arr[i] = arr[arr.length-<span class="number">1</span>-x];</span><br><span class="line">arr[arr.length-<span class="number">1</span>-x] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//升级版</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse02</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>,end = arr.length-<span class="number">1</span>;start&lt;=end;start++,end--)&#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[start];</span><br><span class="line">arr[start] = arr[end];</span><br><span class="line">arr[end] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组排序时间空间复杂度"><a href="#数组排序时间空间复杂度" class="headerlink" title="数组排序时间空间复杂度"></a>数组排序时间空间复杂度</h3><table><thead><tr><th style="text-align:center">排序法</th><th style="text-align:center">最差时间复杂度</th><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">稳定度</th><th style="text-align:center">空间复杂度</th></tr></thead><tbody><tr><td style="text-align:center">选择排序</td><td style="text-align:center">O(n2)</td><td style="text-align:center">O(n2)</td><td style="text-align:center">稳定</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">插入排序</td><td style="text-align:center">O(n2)</td><td style="text-align:center">O(n2)</td><td style="text-align:center">稳定</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">O(n2)</td><td style="text-align:center">O(n2)</td><td style="text-align:center">稳定</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center">O(n2)</td><td style="text-align:center">O(n*log2n)</td><td style="text-align:center">不稳定</td><td style="text-align:center">O(log2n)~O(n)</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center">O(n2)</td><td style="text-align:center">O(n*logn)</td><td style="text-align:center">稳定</td><td style="text-align:center">不一定</td></tr><tr><td style="text-align:center">希尔排序</td><td style="text-align:center">O(n*(logn)2)</td><td style="text-align:center">O(n*(logn)2)</td><td style="text-align:center">不稳定</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">O(n*log2n)</td><td style="text-align:center">O(n*log2n)</td><td style="text-align:center">不稳定</td><td style="text-align:center">O(1)</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 基础 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习-基础2-方法</title>
      <link href="/2018/05/28/javaSE%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%802-%E6%96%B9%E6%B3%95/"/>
      <url>/2018/05/28/javaSE%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%802-%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h3><h4 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h4><p>方法：完成特定功能的语句的集合</p><p>方法命名规则：名称第一个字母小写</p><h5 id="方法语法格式："><a href="#方法语法格式：" class="headerlink" title="方法语法格式："></a>方法语法格式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...)&#123;</span><br><span class="line">方法体语句;</span><br><span class="line">return 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修饰符：</li><li>返回值类型：这个方法执行完成返回的结果值的类型</li><li>方法名：</li><li>参数类型：方法被调用时，将值传给参数；参数可以有，也可没有</li><li>方法体：具体包含实现方法功能的语句</li><li>return：结束方法，将结果值返回</li></ul><h5 id="方法举例："><a href="#方法举例：" class="headerlink" title="方法举例："></a>方法举例：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c = a+b;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h4><p>方法执行特点：不调用，不执行  </p><p>方法的两种调用：根据方法是否有返回值</p><p>有返回值：调用方法返回什么类型的值，就用什么类型的数据接收<br>无返回值：可以直接调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionStudyDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">int</span> b = <span class="number">6</span>;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      有返回值调用，通过赋值方式调用</span></span><br><span class="line"><span class="comment">      sum方法结果</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">int</span> c = sum(a, b);</span><br><span class="line">      System.out.println(<span class="string">"Minimum Value = "</span> + c);</span><br><span class="line">      <span class="comment">//无返回值调用</span></span><br><span class="line">      maxNumFunction(a, b);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> a+b;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maxNumFunction</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(a&gt;b) System.out.println(<span class="string">"max number is "</span> + a);</span><br><span class="line">   <span class="keyword">else</span> System.out.println(<span class="string">"max number is "</span> + b);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><h4 id="什么是方法的重载"><a href="#什么是方法的重载" class="headerlink" title="什么是方法的重载"></a>什么是方法的重载</h4><p>方法的重载，是在同一个类中，定义的方法名称相同，但是参数不同，返回类型可以相同也可以不同  </p><p>每个重载的方法，参数类表必须不同，与返回值无关！  </p><p>重载是一种语言规则，在编译期间检查重载的正确性，通过判断参数列表的不同区别方法  </p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dmeo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"int int:"</span> + compareMethod(<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">System.out.println(<span class="string">"double double:"</span> + compareMethod(<span class="number">1.2</span>,<span class="number">1.2</span>));</span><br><span class="line">System.out.println(<span class="string">"byte byte:"</span> + compareMethod(<span class="number">2.1</span>,<span class="number">2.1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareMethod</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a==b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareMethod</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a==b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareMethod</span><span class="params">(<span class="keyword">byte</span> a, <span class="keyword">byte</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a==b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 基础 </tag>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习-历史与特性</title>
      <link href="/2018/05/28/javaSE%E5%AD%A6%E4%B9%A0-%E5%8E%86%E5%8F%B2%E4%B8%8E%E7%89%B9%E6%80%A7/"/>
      <url>/2018/05/28/javaSE%E5%AD%A6%E4%B9%A0-%E5%8E%86%E5%8F%B2%E4%B8%8E%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<h2 id="1-1-java历史与特点"><a href="#1-1-java历史与特点" class="headerlink" title="1.1 java历史与特点"></a>1.1 java历史与特点</h2><h3 id="java历史与发展"><a href="#java历史与发展" class="headerlink" title="java历史与发展"></a>java历史与发展</h3><p>java 由sun公司编写，后由Oracle公司收购</p><h4 id="java-发展"><a href="#java-发展" class="headerlink" title="java 发展"></a>java 发展</h4><p>分为三大平台：</p><ul><li>javaSE 标准版</li><li>javaEE 企业版</li><li>javaME 微型班</li></ul><p><img src="http://pkvv4hyzz.bkt.clouddn.com//image/java/javaSE/java%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2.png" alt="java发展历史"></p><table><thead><tr><th style="text-align:center">版本</th><th style="text-align:center">年份</th><th style="text-align:center">语言新特性</th></tr></thead><tbody><tr><td style="text-align:center">1.0</td><td style="text-align:center">1996</td><td style="text-align:center">语言本身</td></tr><tr><td style="text-align:center">1.1</td><td style="text-align:center">1997</td><td style="text-align:center">内部类</td></tr><tr><td style="text-align:center">1.2</td><td style="text-align:center">1998</td><td style="text-align:center">strictfp修饰符</td></tr><tr><td style="text-align:center">1.3</td><td style="text-align:center">2000</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">1.4</td><td style="text-align:center">2002</td><td style="text-align:center">断言</td></tr><tr><td style="text-align:center">5.0</td><td style="text-align:center">2004</td><td style="text-align:center">泛型类、for each循环、可变元参数、自动装箱、元数据、枚举、静态导入</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">2006</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">2011</td><td style="text-align:center">基于字符串的switch、二进制字面量、异常处理改进</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">2014</td><td style="text-align:center">lambda表达式，包含默认方法的接口、六合日期/时间库</td></tr></tbody></table><h3 id="java特点"><a href="#java特点" class="headerlink" title="java特点"></a>java特点</h3><ul><li>简单性</li><li>面向对象（OOP）</li><li>分布式</li><li>健壮性</li><li>体系结构中立</li><li>可移植性</li><li>解释型</li><li>高性能</li><li>多线程</li><li>动态性</li></ul><p>####</p><h4 id="java与C-区别："><a href="#java与C-区别：" class="headerlink" title="java与C++区别："></a>java与C++区别：</h4><ul><li>无指针操作</li><li>自动内存管理</li><li>数据类型长度固定</li><li>不用头文件</li><li>不包含结构和联合</li><li>不支持宏</li><li>不用多重继承</li><li>无类外全局变量</li><li>无goto</li></ul><h3 id="java运行机制"><a href="#java运行机制" class="headerlink" title="java运行机制"></a>java运行机制</h3><p>三中核心机制:</p><ul><li>java虚拟机（Java Virtual Machine）</li><li>代码安全性检测（Code Security）</li><li>垃圾回收机制（Garbage collection）</li></ul><h4 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h4><p>java运行环境JRE=JVM+API（Lib）</p><p>运行程序的三项功能：</p><ul><li>加载代码：class loader</li><li>校验代码：bytecode verifier</li><li>执行代码：runtime interpreter</li></ul><p>自动垃圾回收技术：</p><ul><li>系统级线程跟踪存储空间的分配情况</li><li>在JVM空闲时，检查并释放那些可被释放的存储器空间</li></ul><h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h4><p>JDK（java工具包=JRE+Tools）</p><p>JDK提供的工具：</p><ul><li>java编译器：javac.exe</li><li>java执行器：java.exe</li><li>java文档生成器：javadoc.exe</li><li>java打包器：jar.exe</li><li>java调试器：jdb.exe</li></ul><h2 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h2><p>类：具有共同属性和行为的对象集合</p><ul><li>属性：变量（字段field）</li><li>行为：函数（方法）</li></ul><p>类与对象的关系：类是对象的抽象（模板），对象是类的实例</p><h2 id="程序的编译与运行"><a href="#程序的编译与运行" class="headerlink" title="程序的编译与运行"></a>程序的编译与运行</h2><h3 id="JDK安装后的文件夹"><a href="#JDK安装后的文件夹" class="headerlink" title="JDK安装后的文件夹"></a>JDK安装后的文件夹</h3><ul><li>bin：工具文件</li><li>jre：java运行环境相关的文件</li><li>demo：实例</li><li>include：与c相关的头文件</li><li>lib：程序库</li><li>db：数据库相关</li></ul><h3 id="java的编译与运行"><a href="#java的编译与运行" class="headerlink" title="java的编译与运行"></a>java的编译与运行</h3><p>编译——转换字节码（bytecode）文件，扩展名.class</p><ul><li>.class文件中包含java虚拟机的指令</li><li>使用JDK工具：javac.exe，如：javac HelloWorld.java</li></ul><p>运行——执行.class文件中的指令，如java HelloWorld</p><h3 id="JDK工具"><a href="#JDK工具" class="headerlink" title="JDK工具"></a>JDK工具</h3><h4 id="jar打包"><a href="#jar打包" class="headerlink" title="jar打包"></a>jar打包</h4><ol><li>编译：javac A.java</li><li>打包：jar cvfm A.jar A.man A.class（c:create v:显示详情 f:指定文件名 m 清单文件）</li><li>运行：java -jar A.jar</li></ol><h4 id="javadoc生成文档"><a href="#javadoc生成文档" class="headerlink" title="javadoc生成文档"></a>javadoc生成文档</h4><p>javadoc -d 目录名 xxx.java</p><h4 id="javap"><a href="#javap" class="headerlink" title="javap"></a>javap</h4><p>使用javap查看类的信息 javap 类名</p><p>javap反汇编：javap -c 类名</p>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaSE学习-基础1-基本知识</title>
      <link href="/2018/05/28/javaSE%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%801-%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/05/28/javaSE%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%801-%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<h2 id="关键字、标识符、注释"><a href="#关键字、标识符、注释" class="headerlink" title="关键字、标识符、注释"></a>关键字、标识符、注释</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>关键字：被Java语言赋予了特殊含义的单词<br>特点：关键字中所有字母都为小写</p><table><thead><tr><th style="text-align:center">关键字类型</th><th style="text-align:center">关键字</th></tr></thead><tbody><tr><td style="text-align:center">访问控制</td><td style="text-align:center">private   protected   public</td></tr><tr><td style="text-align:center">类，方法和变量修饰符</td><td style="text-align:center">abstract    class extends final implements interface native</td></tr><tr><td style="text-align:center">程序控制</td><td style="text-align:center">break continue return do while if else for instanceof switch case default</td></tr><tr><td style="text-align:center">错误处理</td><td style="text-align:center">try    catch throw    throws finally</td></tr><tr><td style="text-align:center">包相关</td><td style="text-align:center">import    package</td></tr><tr><td style="text-align:center">基本数据类型</td><td style="text-align:center">boolean    byte char double float int long short nul true false</td></tr><tr><td style="text-align:center">变量引用</td><td style="text-align:center">super this void</td></tr><tr><td style="text-align:center">保留字</td><td style="text-align:center">goto const</td></tr></tbody></table><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>java程序中自定义的符号  </p><p>规则：</p><ul><li>由字母、数字、下划线、美元组成，但是不能包含特殊字符，不能以数字开头</li><li>不能使用关键字和保留字</li><li>严格区分大小写</li><li>尽量见名知意</li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li>单行注释：// 注释文字</li><li>多行注释：/<em> 注释文字 </em>/</li><li>文档注释：/*<em> 注释文字 </em>/</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是单行的注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 多行注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文档注释</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ol><li>单行注释、多行注释：这两种注释是一般注释，被注释的文字，不会被JVM解释执行</li><li>文档注释：java特有的注释，备注是的内容会被JDK工具javadoc接信息，生成网页文档</li></ol><h2 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量表示不能改变的数值</p><p>常量的分类:</p><ul><li>整数常量。所有整数</li><li>小数常量。所有小数 </li><li>布尔型常量。较为特有，只有两个数值。true false</li><li>字符常量。将一个数字字母或者符号用单引号( ‘ ‘ )标识</li><li>字符串常量。将一个或者多个字符用双引号标识</li><li>null常量。只有一个数值就是:null.</li></ul><p>整数:java有三种表现形式</p><ul><li>十进制:0-9 ，满10进1、</li><li>八进制:0-7 ，满8进1. 用0开头表示</li><li>十六进制:0-9，A-F，满16进1. 用0x开头表示</li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>内存中的一个存储区域</li><li>该区域有自己的名称(变量名)和类型(数据类型)</li><li>该区域的数据可以在同一类型范围内不断变化</li></ul><p>使用变量时注意两点：变量的作用域、变量初始化值</p><h4 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h4><p>数据类型 变量名 = 初始化值;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在同一行进行多个变量的定义和初始化，不建议</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>; <span class="keyword">int</span> b;<span class="keyword">int</span> c;</span><br><span class="line"><span class="comment">//一行定义一个变量</span></span><br><span class="line"><span class="keyword">int</span> a; <span class="comment">//声明</span></span><br><span class="line"><span class="keyword">int</span> b=<span class="number">0</span>;<span class="comment">//声明并初始化</span></span><br></pre></td></tr></table></figure><h4 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h4><p>java中变量必须用赋值语句对变量进行显式初始化 </p><p>可以在声明变量时进行赋值，也可以之后赋值，但是必须在使用之前，如果一个变量没有被赋值，那这个变量不能被使用  </p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型决定数据的存储方式和运算方式</p><p>java中的数据类型分为两大类</p><ul><li>基本数据类型：</li><li>引用数据类型：</li></ul><p><img src="http://pkvv4hyzz.bkt.clouddn.com//image/java/javaSE/javaSE_%E5%9F%BA%E7%A1%80_%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="javaSE_基础_数据类型"></p><font color="#FF0000">整数默认：int    小数默认：double</font><p>两种数据类型区别：</p><p><img src="http://pkvv4hyzz.bkt.clouddn.com//image/java/javaSE/javaSE_%E5%9F%BA%E7%A1%80_%E4%B8%A4%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%BA%E5%88%AB.png" alt="javaSE_基础_两种数据类型区别"></p><h3 id="基本数据类型：4类8种"><a href="#基本数据类型：4类8种" class="headerlink" title="基本数据类型：4类8种"></a>基本数据类型：4类8种</h3><p>java中，所有的数据类型所占的字节数量与平台无关 </p><table><br>    <tr><th>类型</th><th>种类</th><th>字节</th><th>范围</th></tr><br>    <tr><td rowspan="4">整型</td><td>byte</td><td>1</td><td>-128~127</td></tr><br>    <tr><td>short</td><td>2</td><td>-128~127</td></tr><br>    <tr><td>int</td><td>4</td><td>-128~127</td></tr><br>    <tr><td>long</td><td>8</td><td>-128~127</td></tr><br>    <tr><td rowspan="2">浮点型</td><td>float</td><td>4</td><td>有效位数6~7位</td></tr><br>    <tr><td>double</td><td>8</td><td>有效位数为15位</td></tr><br>    <tr><td rowspan="1">字符型</td><td>char</td><td>1</td><td>\u0000到\Uffff</td></tr><br>    <tr><td rowspan="1">布尔型</td><td>boolean</td><td>1</td><td></td></tr><br></table><h4 id="boolean-类型"><a href="#boolean-类型" class="headerlink" title="boolean 类型"></a>boolean 类型</h4><p>boolan类型适用于逻辑运算，一般用于程序流程控制</p><p>boolean类型只有两种值：true/false</p><ul><li>整型和布尔型之间不能相互转换，如：if(a=5) 是不允许的</li><li>不能用0或非0的整数代替true/false</li></ul><h4 id="char字符型"><a href="#char字符型" class="headerlink" title="char字符型"></a>char字符型</h4><p>char型数据表示通常意义上的‘字符’，字符常量是用单括号引起的单个字符：char=’A’;</p><p>java采用Unicode编码，一个字符占两个字节：char c1=’\u0061’;</p><p>java还允许使用转义字符’\’将后面的字符转变为其他含义，如:char c2=’\n’;</p><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>整型用于表示没有小数部分的数值</p><p>java整型常量三种表示形式：</p><ul><li>十进制</li><li>八进制：以0开头，如012</li><li>十六进制：以0x或0X开头</li><li>二进制：以0b或0B开头（java7以上）</li></ul><p>java7之后还可以为数字字面量加下划线，如用1_000_000，更易阅读，java编译器会去除这些下划线</p><p>java没有无符号形式的数据类型</p><p>注：长整型（long）后有后缀L或l；一般最好不用八进制，因为八进制有前缀0，容易混淆</p><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>double数值精度是float精度的两倍。不部分情况下使用double<br>float类型数值有后缀F或f，没有后缀的数值默认double，或在数值后加后缀D或d表示double类型</p><h5 id="三种特殊数值"><a href="#三种特殊数值" class="headerlink" title="三种特殊数值"></a>三种特殊数值</h5><p>浮点型数值溢出或出错的三种特殊数值：</p><ul><li>正无穷大:Double.POSITIVE_INTFINITY</li><li>负无穷大:Double.NEGATIVE_INTFINITY</li><li>NaN（不是一个数字）:Double.NaN</li></ul><p>例如，一个数值/0 结果是正无穷大；0/0 结果NaM</p><p>java中检测特定值是否为NaN：<br>不能使用相等方法检测：if(a == Double.NaN) ，这是错误的，因为所有废树脂的值都会被认为是不同的<br>想要检测，可以使用Double的isNaN(变量)方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不能使用相等方法检测</span></span><br><span class="line"><span class="keyword">if</span>(a == Double.NaN)<span class="comment">//错误</span></span><br><span class="line"><span class="comment">//使用 Double.isNaN() 方法</span></span><br><span class="line"><span class="keyword">if</span>(Double.isNaN(a))</span><br></pre></td></tr></table></figure><h4 id="浮点类型数值计算误差"><a href="#浮点类型数值计算误差" class="headerlink" title="浮点类型数值计算误差"></a>浮点类型数值计算误差</h4><p>浮点类型数计算有误差，不能用于不能接受舍入误差的金融计算当中，如：<code>System.out.println(2.0-1.1);</code> 将打印出0.899999999999，而不是想象中的0.9；这种误差，主要原因是浮点数值用二进制表示，而二进制无法精准表示1/10；想要精确计算，应该使用BigDecimal类</p><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="运算符介绍"><a href="#运算符介绍" class="headerlink" title="运算符介绍"></a>运算符介绍</h3><h4 id="运算符分类"><a href="#运算符分类" class="headerlink" title="运算符分类"></a>运算符分类</h4><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">符号</th></tr></thead><tbody><tr><td style="text-align:center">算术运算符</td><td style="text-align:center">+、-、*、/、%、++、–</td></tr><tr><td style="text-align:center">关系运算符</td><td style="text-align:center">==、!=、&gt;、&lt;、&gt;=、&lt;=</td></tr><tr><td style="text-align:center">逻辑运算符</td><td style="text-align:center">!、&amp;、</td><td>、^、&amp;&amp;、</td><td></td><td></td></tr><tr><td style="text-align:center">位运算符</td><td style="text-align:center">&amp;、</td><td>、^、~、&gt;&gt;、&lt;&lt;、&gt;&gt;&gt;</td></tr><tr><td style="text-align:center">三目运算符</td><td style="text-align:center">?:</td></tr></tbody></table><p>注意，整数除0会产生异常，而浮点数除0会得到无穷大或NaN结果</p><h4 id="运算符级别"><a href="#运算符级别" class="headerlink" title="运算符级别"></a>运算符级别</h4><p>运算符的优先级如下：</p><table><thead><tr><th style="text-align:center">运算符优先级</th><th style="text-align:center">运算符</th><th style="text-align:center">综合性</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">()[].</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">! +(正) -(负) ~ ++ –</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">* / %</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">+(加) -(减)</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">&lt;&lt; &gt;&gt; &gt;&gt;&gt;</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">&lt; &lt;= &gt; &gt;= instanceof</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">==   !=</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">&amp;(按位与)</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">^</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">\</td><td style="text-align:center"></td><td>从左到右</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">&amp;&amp;</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">\</td><td style="text-align:center">\</td><td></td><td>从左到右</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">?:</td><td style="text-align:center">从右到左</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">= += -= *= /= %= &amp;= \</td><td style="text-align:center">= ^=  ~=  &lt;&lt;= &gt;&gt;=   &gt;&gt;&gt;=</td><td>从右到左</td></tr></tbody></table><h4 id="运算符分类-1"><a href="#运算符分类-1" class="headerlink" title="运算符分类"></a>运算符分类</h4><h5 id="、–自增自减运算符："><a href="#、–自增自减运算符：" class="headerlink" title="++、–自增自减运算符："></a>++、–自增自减运算符：</h5><ul><li>i++：先进行表达式运算，再自增</li><li>++i：先自增再进行表达式运算</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>；</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> x = i++;</span><br><span class="line"><span class="keyword">int</span> y = ++j；</span><br><span class="line">System.out.println(<span class="string">"i = "</span>+i+<span class="string">"   j="</span>+j);<span class="comment">//i=2   j=2</span></span><br><span class="line">System.out.println(<span class="string">"x = "</span>+x+<span class="string">"   y="</span>+y);<span class="comment">//x=1   j=2</span></span><br></pre></td></tr></table></figure><p>上面的例子可以看出，无论是i++还是++j，对i和j本身的值无关，都是+1后的结果；但是符号的位置对赋值运算的结果会有影响，例子中x和y的值完全不同</p><p>单独进行自增、自减运算：运算符位置对进行自增自减运算的无区别  </p><p>参与表达式运算：</p><ul><li>在操作数之前，先进行自增运算，再参与其他表达式运算</li><li>在操作数之后，先进行其他表达式运算，再自增运算</li></ul><h5 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h5><p>==，!=，&gt;，&gt;=，&lt;，&lt;=</p><p>运算结果都为boolean</p><h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><h5 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h5><h5 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h5><p>格式：表达式?表达式1:表达式2  </p><p>表达式结果是boolean类型；表达式计算结果为true，执行表达式1返回结果；false执行表达式2返回结果；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> z = (x&gt;y)?x:y;</span><br><span class="line">System.out.println(<span class="string">"z="</span>+z);<span class="comment">//z=5</span></span><br></pre></td></tr></table></figure><h3 id="数值类型转换"><a href="#数值类型转换" class="headerlink" title="数值类型转换"></a>数值类型转换</h3><p>在计算时，参与计算的数据类型一般要一致，如果不一致，则要将数据进行类型的转换  </p><p>boolean不参与数据转换</p><p>数值类型的转换，分为默认转换和强制转换</p><h4 id="默认转换（自动类型提升）"><a href="#默认转换（自动类型提升）" class="headerlink" title="默认转换（自动类型提升）"></a>默认转换（自动类型提升）</h4><p>默认转换，前提是数据类型从小到大才会默认转换  </p><p>byte、short、char-&gt;int-&gt;long-&gt;float-&gt;double  </p><p>byte、short、char这三种类型之间不进行转换，在参与运算时之间转换为int类型</p><p><img src="http://pkvv4hyzz.bkt.clouddn.com//image/java/javaSE/javaSE_%E5%9F%BA%E7%A1%80_%E6%95%B0%E5%80%BC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%90%88%E6%B3%95%E8%BD%AC%E6%8D%A2.png" alt="javaSE_基础_数值之间的合法转换"></p><h4 id="强制类型转换（显示类型转换）"><a href="#强制类型转换（显示类型转换）" class="headerlink" title="强制类型转换（显示类型转换）"></a>强制类型转换（显示类型转换）</h4><p>将字节大的转换为字节小的数据类型，需要强制转换  </p><p>转换格式：目标数据类型 目标变量 = (目标数据类型)被转换数据;</p><p>注意: 如果将一个数值从一种字节大的类型强制转换为另一种字节小的类型，并且超出了目标类型的表示范围，目标结果就会被截断成一个完全不同的值。例如:int是300的值强制转换为byte后的实际值为44：(byte)300=44</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//byte c = a + b;这个语句在编译时会报错：损失精度，需要前置转换</span></span><br><span class="line"><span class="keyword">byte</span> c = (<span class="keyword">byte</span>)a + b;</span><br></pre></td></tr></table></figure><p>分析直接定义和强制转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f1 = (<span class="keyword">float</span>)<span class="number">1.2345</span>;</span><br><span class="line"><span class="keyword">float</span> f2 = <span class="number">1.2345F</span>;</span><br></pre></td></tr></table></figure><p>以上两个语句都正确，但是有区别：f1是通过double类型的数据强制转换来的；而f2变量定义的就是一个float类型  </p><p>分析运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1 = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">byte</span> b2 = <span class="number">4</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">byte类型做计算，会自动转换为int类型</span></span><br><span class="line"><span class="comment">需要强转，因为byte 3+byte 4 结果自动转换为int类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">byte</span> b3 = (<span class="keyword">byte</span>)b1 + b2;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3+4=7是一个常量</span></span><br><span class="line"><span class="comment">在运算时将3+4计算出来，然后看这个结果值常量是否在byte范围内，在则不报错，不在会报错</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">byte</span> b4 = <span class="number">3</span> + <span class="number">4</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mac-mac中Terminal或Iterm2 ssh连接服务器中文乱码</title>
      <link href="/2018/05/24/mac-mac%E4%B8%ADTerminal%E6%88%96Iterm2-ssh%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
      <url>/2018/05/24/mac-mac%E4%B8%ADTerminal%E6%88%96Iterm2-ssh%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
      <content type="html"><![CDATA[<h2 id="mac-mac中Terminal或Iterm2-ssh连接服务器中文乱码"><a href="#mac-mac中Terminal或Iterm2-ssh连接服务器中文乱码" class="headerlink" title="mac - mac中Terminal或Iterm2 ssh连接服务器中文乱码"></a>mac - mac中Terminal或Iterm2 ssh连接服务器中文乱码</h2><p>mac中Terminal或Iterm2 ssh连接服务器中文乱码，大多是由于本地终端编码和服务器编码不一致  </p><h3 id="本地终端中文不乱吗，ssh连接服务器中文乱码"><a href="#本地终端中文不乱吗，ssh连接服务器中文乱码" class="headerlink" title="本地终端中文不乱吗，ssh连接服务器中文乱码"></a>本地终端中文不乱吗，ssh连接服务器中文乱码</h3><p>修改文件：~/.vimrc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936</span><br><span class="line"><span class="built_in">set</span> termencoding=utf-8</span><br><span class="line"><span class="built_in">set</span> encoding=utf-8</span><br></pre></td></tr></table></figure><h3 id="服务器编码和ssh连接后的编码不一致"><a href="#服务器编码和ssh连接后的编码不一致" class="headerlink" title="服务器编码和ssh连接后的编码不一致"></a>服务器编码和ssh连接后的编码不一致</h3><p>mac 使用ssh命令会发送本地语言环境到目标服务器</p><p>解决办法：</p><p>修改配置文件：/etc/ssh/ssh_config（用root权限）</p><p>将内容：SendEnv LANG LC_* 注释</p>]]></content>
      
      <categories>
          
          <category> mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Centos7 - 安装Hadoop集群</title>
      <link href="/2018/05/24/Centos7-%E5%AE%89%E8%A3%85Hadoop%E9%9B%86%E7%BE%A4/"/>
      <url>/2018/05/24/Centos7-%E5%AE%89%E8%A3%85Hadoop%E9%9B%86%E7%BE%A4/</url>
      <content type="html"><![CDATA[<p>在Centos7系统上进行安装，采用hadoop2.7.1</p><h3 id="下载相关软件"><a href="#下载相关软件" class="headerlink" title="下载相关软件"></a>下载相关软件</h3><p>hadoop下载：<br><a href="http://hadoop.apache.org/releases.html" target="_blank" rel="noopener">http://hadoop.apache.org/releases.html</a><br>官网上提供的是hadoop源码包和32位安装包，我的centos7是64位，所以找了一个别人用源码在Centos7上编译好的安装包。也可以自己下载源码编译。</p><p>jdk1.8下载：<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="配置机器"><a href="#配置机器" class="headerlink" title="配置机器"></a>配置机器</h4><p>搭建三个机器为例：node-1、node-2、node-3  </p><ul><li>node-1:\&lt;NameNode>  [ResourceManager]</li><li>node-2:\&lt;DataNode>  \&lt;SecondaryNameNode>  [NodeManager]</li><li>node-3:\&lt;DataNode>  [NodeManager]</li></ul><h5 id="修改机器名称"><a href="#修改机器名称" class="headerlink" title="修改机器名称"></a>修改机器名称</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意，centos7以下版本是直接修改/etc/network文件</span></span><br><span class="line"><span class="comment"># hostnamectl set-hostname &lt;host-name&gt;</span></span><br><span class="line">hostnamectl <span class="built_in">set</span>-hostname node-1</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h5 id="设置主机名映射"><a href="#设置主机名映射" class="headerlink" title="设置主机名映射"></a>设置主机名映射</h5><p>将主机名和ip地址映射起来，在三台机器中都配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">172.16.199.129 node-1</span><br><span class="line">172.16.199.130 node-2</span><br><span class="line">172.16.199.131 node-3</span><br></pre></td></tr></table></figure><h5 id="配置三台机器ssh免密码登录"><a href="#配置三台机器ssh免密码登录" class="headerlink" title="配置三台机器ssh免密码登录"></a>配置三台机器ssh免密码登录</h5><ol><li>在node-1中生成密匙（私匙id_ras、公匙id_rsa.pub）:ssh-keygen -t rsa</li><li>将公匙id_rsa.pub拷贝到要进行ssh登录的机器上：ssh-copy-id -id &lt;机器名称&gt;</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在node-1中：</span></span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">ssh-copy-id node-2</span><br><span class="line">ssh-copy-id node-3</span><br></pre></td></tr></table></figure><h5 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --state<span class="comment">#查看防火墙状态</span></span><br><span class="line">firewall-cmd --reload<span class="comment">#重启firewall</span>systemctl stop firewalld.service<span class="comment">#停止firewall</span>systemctl <span class="built_in">disable</span> firewalld.service<span class="comment">#禁止firewall开机启动</span></span><br></pre></td></tr></table></figure><h4 id="安装jdk1-8"><a href="#安装jdk1-8" class="headerlink" title="安装jdk1.8"></a>安装jdk1.8</h4><p>hadoop是依赖于jdk环境的<br>在hadoop中可以看到有很多jar包，所以hadoop的启动必须有jdk环境<br>配置好jdk环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/program/java/jdk1.8.0_171</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br></pre></td></tr></table></figure><h3 id="安装hadoop"><a href="#安装hadoop" class="headerlink" title="安装hadoop"></a>安装hadoop</h3><p>下载hadoop64位安装包,我下载的是hadoop-2.7.1-cent0s7-64.tar.gz<br>放在三个服务器下，解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压后文件：hadoop-2.7.1</span></span><br><span class="line">tar -zxvf hadoop-2.7.1-cent0s7-64.tar.gz</span><br></pre></td></tr></table></figure><h3 id="hadoop相关配置"><a href="#hadoop相关配置" class="headerlink" title="hadoop相关配置"></a>hadoop相关配置</h3><p>在node-1机器上进行配置</p><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>进入hadoop-2.7.1的配置目录：hadoop-2.7.1/hadoop-2.7.1/etc/hadoop<br>hadoop的配置文件有两种，</p><ul><li>*-default.xml：配置了hadoop的默认配置</li><li>*-site.xml：配置用户自定义的配置选项</li></ul><p>如果用户想自定义一些属性变量配置，就进入*-site.xml配置，配置之后会覆盖默认配置文件的相应配置；如果没有配置其他的配置选项，则会启动*-default.xml的配置</p><h5 id="修改hadoop-env-sh"><a href="#修改hadoop-env-sh" class="headerlink" title="修改hadoop-env.sh"></a>修改hadoop-env.sh</h5><p>修改自己安装的的jdk路径,hadoop启动时加载jdk：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># export JAVA_HOME=$&#123;JAVA_HOME&#125;</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/program/java/jdk1.8.0_171</span><br></pre></td></tr></table></figure><h5 id="修改hadoop核心配置文件：core-site-xml"><a href="#修改hadoop核心配置文件：core-site-xml" class="headerlink" title="修改hadoop核心配置文件：core-site.xml"></a>修改hadoop核心配置文件：core-site.xml</h5><p>在core-site.xml文件的下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定hadoop运行时产生文件的存储目录,可以指定自己熟悉的目录，默认/tmp/hadoop-$&#123;user.name&#125; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/local/program/server/data/hddata<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Abase for other temporary directories.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定hadoop使用的文件系统，HDFS的老大NameNode的地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://node1:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="修改hdfs-site-xml"><a href="#修改hdfs-site-xml" class="headerlink" title="修改hdfs-site.xml"></a>修改hdfs-site.xml</h5><p>DFS namenode存放配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定HDFS副本数量，默认3 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>node-2:50090<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="修改mapred-site-xml"><a href="#修改mapred-site-xml" class="headerlink" title="修改mapred-site.xml"></a>修改mapred-site.xml</h5><p>mapreduce相关配置，job监控地址和端口等配置文件<br>修改文件名称</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv mapred-site.xml.template mapred-site.xml</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定mapred运行时的框架：yarn，默认local --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="修改yarn-site-xml"><a href="#修改yarn-site-xml" class="headerlink" title="修改yarn-site.xml"></a>修改yarn-site.xml</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定yarn（老大）的地址（ResourceManager） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>node-1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- nodemanager上运行的附属服务，指定mapreduce_shuffle才可以运行mapReduce默认 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="修改slaves"><a href="#修改slaves" class="headerlink" title="修改slaves"></a>修改slaves</h5><p>删除文件内容localhost，指定机器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node-1</span><br><span class="line">node-2</span><br><span class="line">node-3</span><br></pre></td></tr></table></figure><h4 id="配置hadoop环境变量"><a href="#配置hadoop环境变量" class="headerlink" title="配置hadoop环境变量"></a>配置hadoop环境变量</h4><p>将环境变量配置到/etc/profile文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HADOOP_HOME=/usr/<span class="built_in">local</span>/program/server/hadoop-2.7.1</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HADOOP_HOME</span>/bin:<span class="variable">$HADOOP_HOME</span>/sbin</span><br></pre></td></tr></table></figure><p>修改文件后重新加载文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h4 id="全部配置"><a href="#全部配置" class="headerlink" title="全部配置"></a>全部配置</h4><p>将以上所有修改发送到另外两台机器上（node-2,node-3）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scp -r /usr/<span class="built_in">local</span>/program/server/hadoop-2.7.1/ root@node-2:/usr/<span class="built_in">local</span>/program/server/</span><br><span class="line">scp -r /usr/<span class="built_in">local</span>/program/server/hadoop-2.7.1/ root@node-3:/usr/<span class="built_in">local</span>/program/server/</span><br><span class="line">scp -r /etc/profile root@node-2:/etc/</span><br><span class="line">scp -r /etc/profile root@node-3:/etc/</span><br></pre></td></tr></table></figure><p>在node-2,node-3两台机器上分别重新加载/etc/profile文件</p><h3 id="hadoop启动"><a href="#hadoop启动" class="headerlink" title="hadoop启动"></a>hadoop启动</h3><p>hadoop启动，必须要启动HDFS和YARN这两个集群<br>首次启动HDFS时，必须对他进行格式化</p><h4 id="dhfs格式化"><a href="#dhfs格式化" class="headerlink" title="dhfs格式化"></a>dhfs格式化</h4><p>在启动hadoop集群之前，首先必须要进行一个初始化操作  </p><p>格式化只能在初始启动之前启动一次，是对文件系统进行一些初始化操作，因为此时hdfs还不存在；在初始化完成之后，集群启动，之后不能再进行初始化  </p><p>格式化是在hdfs集群的namenode上，也就是node-1机器  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs namenode -format <span class="comment">#或 hadoop namenode -format</span></span><br></pre></td></tr></table></figure><p>格式化完成之后，查看格式化过程中的日志，  </p><p><img src="/2018/05/24/Centos7-安装Hadoop集群/hdfs格式化.png" alt="hdfs格式化">  </p><p>可以看到日志中创建了之前在core-site.xml配置中指定的文件目录<br>进入这个目录可以看到目录下生成的文件：(data/hddata/dfs/name/current/下)  </p><p><img src="/2018/05/24/Centos7-安装Hadoop集群/初始化产生的文件.png" width="410" height="175" alt="初始化产生的文件">   </p><p>在VERSION中有一个clusterID，这个值是每一次hdfs初始化时产生的一个值，一旦重新初始化，这个值就会改变</p><h4 id="启动hadoop集群"><a href="#启动hadoop集群" class="headerlink" title="启动hadoop集群"></a>启动hadoop集群</h4><p>在namenode机器上启动（node-1）</p><h5 id="方式一：共同启动所有节点"><a href="#方式一：共同启动所有节点" class="headerlink" title="方式一：共同启动所有节点"></a>方式一：共同启动所有节点</h5><p>使用脚本，分别启动hdfs和yarn<br>前提：配置了hadoop-2.7.1/etc/hadoop/slaves文件和设置集群中机器的ssh免密登录  </p><p>脚本在hadoop-2.7.1/sbin目录下</p><ul><li>hdfs：start-dfs.sh</li><li>yarn：start-yarn.sh</li></ul><h5 id="方式二：单节点启动"><a href="#方式二：单节点启动" class="headerlink" title="方式二：单节点启动"></a>方式二：单节点启动</h5><p>分节点启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hadoop-daemon.sh start namenode</span><br><span class="line">hadoop-daemon.sh start datanode</span><br><span class="line">yarn-daemon.sh start resourcemanager</span><br><span class="line">yarn-daemon.sh start nodemanager</span><br></pre></td></tr></table></figure><h4 id="使用jps查看启动节点"><a href="#使用jps查看启动节点" class="headerlink" title="使用jps查看启动节点"></a>使用jps查看启动节点</h4><p> <img src="/2018/05/24/Centos7-安装Hadoop集群/node-1jps.png" width="240" height="95" alt="node-1jps">  </p><p> <img src="/2018/05/24/Centos7-安装Hadoop集群/node-2jps.png" width="240" height="85" alt="cnode-2jps">  </p><p> <img src="/2018/05/24/Centos7-安装Hadoop集群/node-3jps.png" width="240" height="65" alt="node-3jps">  </p><h3 id="进入页面访问"><a href="#进入页面访问" class="headerlink" title="进入页面访问"></a>进入页面访问</h3><h4 id="NameNode页面"><a href="#NameNode页面" class="headerlink" title="NameNode页面"></a>NameNode页面</h4><p>访问NameNode页面配置，默认端口50070：</p><blockquote><p>http://【你的NameNode所在机器ip】:50070/  </p></blockquote><p><img src="/2018/05/24/Centos7-安装Hadoop集群/namenode页面访问.png" alt="namenode页面访问"></p><h5 id="测试dfs"><a href="#测试dfs" class="headerlink" title="测试dfs"></a>测试dfs</h5><p>在页面中查看文件系统    </p><p><img src="/2018/05/24/Centos7-安装Hadoop集群/页面查看文件系统.png" alt="页面查看文件系统">  </p><p><img src="/2018/05/24/Centos7-安装Hadoop集群/根目录.png" alt="根目录">  </p><p>进入服务器查看:hdfs dfs -ls /  </p><p>没有任何内容  </p><p>在根目录下创建一个文件夹：hello_hadoop  </p><p> <img src="/2018/05/24/Centos7-安装Hadoop集群/cmd创建文件夹.png" width="500" height="95" alt="cmd创建文件夹"> </p><p><img src="/2018/05/24/Centos7-安装Hadoop集群/页面显示文件夹.png" alt="页面显示文件夹">  </p><h4 id="ResourceManager页面"><a href="#ResourceManager页面" class="headerlink" title="ResourceManager页面"></a>ResourceManager页面</h4><p>访问ResourceManager页面配置，默认端口8088：</p><blockquote><p>http://【你的ResourceManager所在机器ip】:8088/  </p></blockquote><p><img src="/2018/05/24/Centos7-安装Hadoop集群/resourcemanager页面访问.png" alt="resourcemanager页面访问"></p><h5 id="用官方示例运行mapreduce程序"><a href="#用官方示例运行mapreduce程序" class="headerlink" title="用官方示例运行mapreduce程序"></a>用官方示例运行mapreduce程序</h5><p>在hadoop集群中任选一台机器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> hadoop-2.7.1/share/hadoop/mapreduce</span><br><span class="line">hadoop jar hadoop-mapreduce-examples-2.7.1.jar pi 20 50  <span class="comment"># 计算圆周率</span></span><br></pre></td></tr></table></figure><p><img src="/2018/05/24/Centos7-安装Hadoop集群/MapReduce运行示例界面.png" alt="MapReduce运行示例界面"></p>]]></content>
      
      <categories>
          
          <category> Centos7 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos7 </tag>
            
            <tag> Hadoop集群 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Centos7 - 修改系统语言</title>
      <link href="/2018/05/24/Centos7-%E4%BF%AE%E6%94%B9%E7%B3%BB%E7%BB%9F%E8%AF%AD%E8%A8%80/"/>
      <url>/2018/05/24/Centos7-%E4%BF%AE%E6%94%B9%E7%B3%BB%E7%BB%9F%E8%AF%AD%E8%A8%80/</url>
      <content type="html"><![CDATA[<h3 id="修改Centos7系统语言"><a href="#修改Centos7系统语言" class="headerlink" title="修改Centos7系统语言"></a>修改Centos7系统语言</h3><p>如：将系统语言改为中文格式</p><h4 id="使用locale命令"><a href="#使用locale命令" class="headerlink" title="使用locale命令"></a>使用locale命令</h4><p>查看当前系统默认采用的字符集：locale 或 echo $LANG</p><h4 id="修改语言"><a href="#修改语言" class="headerlink" title="修改语言"></a>修改语言</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.查看系统中已经有的语言包（查找中文语言包：zh_CN开头的包）</span></span><br><span class="line">locale -a</span><br><span class="line"><span class="comment"># 2.如果没有，则安装中文语言包</span></span><br><span class="line">yum groupinstall Chinese-support</span><br><span class="line"><span class="comment"># 3.安装后再用命令查看安装好中文包，复制语言包名称</span></span><br><span class="line">locale -a</span><br><span class="line"><span class="comment"># 4.修改系统语言，LANG的值是你上一步找到的包名称</span></span><br><span class="line"><span class="comment"># 方式一</span></span><br><span class="line">vim /etc/locale.conf</span><br><span class="line">LANG=zh_CN.*</span><br><span class="line"><span class="comment"># 方式二（Centos新增命令方式）</span></span><br><span class="line">localectl  <span class="built_in">set</span>-locale LANG=zh_CN.*</span><br></pre></td></tr></table></figure><p>注意，在查看中文语言安装包时，必须复制包名称，否则在修改配置文件或执行命令时名称不一致会造成修改失败，网上给的方式中，名称有可能与你的系统中包名称不一致</p><p>英文：以en_US开头的</p><h3 id="Centos6修改方式"><a href="#Centos6修改方式" class="headerlink" title="Centos6修改方式"></a>Centos6修改方式</h3><p>Centos6中是修改配置文件：/etc/sysconfig/i18n</p><h3 id="用iterm2-ssh连接服务器编码不一致"><a href="#用iterm2-ssh连接服务器编码不一致" class="headerlink" title="用iterm2 ssh连接服务器编码不一致"></a>用iterm2 ssh连接服务器编码不一致</h3><p>我遇到一个问题，在虚拟机中Centos7系统是英文状态，但是用iterm2远程ssh连接，用locale查看，变成了中文状态  </p><p>原因：mac 使用ssh命令会发送本地语言环境到目标服务器</p><h4 id="修改服务器端"><a href="#修改服务器端" class="headerlink" title="修改服务器端"></a>修改服务器端</h4><p>解决：在服务器端，修改文件： vim ~/.bashrc，文件末尾加一行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LANG=<span class="string">'en_US.utf8'</span></span><br></pre></td></tr></table></figure><p>但是这种办法不通用，没连接一个服务器都要设置</p><h4 id="修改本地"><a href="#修改本地" class="headerlink" title="修改本地"></a>修改本地</h4><p>修改配置文件：/etc/ssh/ssh_config（用root权限）</p><p>将内容：SendEnv LANG LC_* 注释</p>]]></content>
      
      <categories>
          
          <category> Centos7 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos7 </tag>
            
            <tag> 系统语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Centos7 - 安装jdk8</title>
      <link href="/2018/05/17/Centos7-%E5%AE%89%E8%A3%85jdk8/"/>
      <url>/2018/05/17/Centos7-%E5%AE%89%E8%A3%85jdk8/</url>
      <content type="html"><![CDATA[<h3 id="查看本机jdk"><a href="#查看本机jdk" class="headerlink" title="查看本机jdk"></a>查看本机jdk</h3><p>先查看系统有没有自带的jdk  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep java <span class="comment">#查看内置的JDK</span></span><br><span class="line">rpm -e --nodeps jdk相关名称 <span class="comment">#如果有，进行卸载</span></span><br><span class="line">rpm -qa | grep java <span class="comment">#查看是否卸载干净</span></span><br></pre></td></tr></table></figure><h3 id="下载安装包安装方式"><a href="#下载安装包安装方式" class="headerlink" title="下载安装包安装方式"></a>下载安装包安装方式</h3><h4 id="下载jdk8"><a href="#下载jdk8" class="headerlink" title="下载jdk8"></a>下载jdk8</h4><p>官网下载jdk8<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p><h4 id="放在系统中，解压"><a href="#放在系统中，解压" class="headerlink" title="放在系统中，解压"></a>放在系统中，解压</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压生成的文件夹jdk1.8.0_171</span></span><br><span class="line">tar -zxvf jdk-8u171-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改配置文件</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL下添加</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/program/java/jdk1.8.0_171</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使配置文件生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h4 id="查看是否安装成功"><a href="#查看是否安装成功" class="headerlink" title="查看是否安装成功"></a>查看是否安装成功</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br><span class="line">java</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Centos7 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos7 </tag>
            
            <tag> jdk8 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mac-使用scp或iTerm2+rz、sz上传下载文件</title>
      <link href="/2018/05/16/mac-%E4%BD%BF%E7%94%A8scp%E6%88%96iTerm2-rz%E3%80%81sz%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/"/>
      <url>/2018/05/16/mac-%E4%BD%BF%E7%94%A8scp%E6%88%96iTerm2-rz%E3%80%81sz%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在Windows下可以使用上传下载工具sz与rz，但是mac下一般都是通过scp命令来完成的<br>在有些时候不能使用scp，比如目前公司登录服务器需要经过跳板机，所以可以使用iTerm安装rz、sz进行上传下载</p><h3 id="使用iterm2使用scp命令"><a href="#使用iterm2使用scp命令" class="headerlink" title="使用iterm2使用scp命令"></a>使用iterm2使用scp命令</h3><h4 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h4><h5 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h5><p>scp 【本地文件路径】 【服务器用户名】@【服务器ip】：【服务器文件存放路径】</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp local_folder remote_username@remote_ip:remote_folder</span><br></pre></td></tr></table></figure><h5 id="上传文件夹"><a href="#上传文件夹" class="headerlink" title="上传文件夹"></a>上传文件夹</h5><p>加-r参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r local_folder remote_username@remote_ip:remote_folder</span><br></pre></td></tr></table></figure><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><h5 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h5><p>scp 【服务器用户名】@【服务器地址】：【服务器上存放文件的路径】【本地文件的路径】</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r remote_username@remote_ip:remote_folder local_folder</span><br></pre></td></tr></table></figure><h4 id="scp参数"><a href="#scp参数" class="headerlink" title="scp参数"></a>scp参数</h4><ul><li>-v 详细显示输出,显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题</li><li>-r 递归处理，递归复制整个目录</li><li>-C 使能压缩选项</li><li>-p 保留原文件的修改时间，访问时间和访问权限。</li><li>-P port 选择传输端口</li><li>-4 强行使用 IPV4 地址 .</li><li>-6 强行使用 IPV6 地址 .</li></ul><h3 id="在iterm2中使用rz、sz"><a href="#在iterm2中使用rz、sz" class="headerlink" title="在iterm2中使用rz、sz"></a>在iterm2中使用rz、sz</h3><h4 id="安装brew-install-lrzsz"><a href="#安装brew-install-lrzsz" class="headerlink" title="安装brew install lrzsz"></a>安装brew install lrzsz</h4><h4 id="下载iterm2相关脚本"><a href="#下载iterm2相关脚本" class="headerlink" title="下载iterm2相关脚本"></a>下载iterm2相关脚本</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p>使用wget命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/bin</span><br><span class="line">sudo wget https://raw.github.com/mmastrac/iterm2-zmodem/master/iterm2-send-zmodem.sh</span><br><span class="line">sudo wget https://raw.github.com/mmastrac/iterm2-zmodem/master/iterm2-recv-zmodem.sh</span><br></pre></td></tr></table></figure><h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><p>直接下载脚本，放在/usr/local/bin目录下<br><a href="https://github.com/mmastrac/iterm2-zmodem" target="_blank" rel="noopener">https://github.com/mmastrac/iterm2-zmodem</a>中的两个脚本文件</p><h4 id="给脚本权限"><a href="#给脚本权限" class="headerlink" title="给脚本权限"></a>给脚本权限</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 /usr/<span class="built_in">local</span>/bin/iterm2-*</span><br></pre></td></tr></table></figure><h4 id="配置iTerm2"><a href="#配置iTerm2" class="headerlink" title="配置iTerm2"></a>配置iTerm2</h4><p>如图：<br><img src="http://pkvv4hyzz.bkt.clouddn.com//image/mac/mac_rzsz_iTerm%E9%85%8D%E7%BD%AE.png" alt="mac_rzsz_iTerm配置"></p><table><br>    <tr><br>        <th>Regular Expression</th><br>        <th>Action</th><br>        <th>Parameters</th><br>        <th>Instant</th><br>    </tr><br>    <tr><br>        <td>rz waiting to receive.**B0100</td><br>        <td>Run Silent Coprocess</td><br>        <td>/usr/local/bin/iterm2-send-zmodem.sh</td><br>        <td>选中</td><br>    </tr><br>    <tr><br>        <td>**B00000000000000</td><br>        <td>Run Silent Coprocess</td><br>        <td>/usr/local/bin/iterm2-recv-zmodem.sh</td><br>        <td>选中</td><br>    </tr><br></table><h3 id="服务器安装lrzsz工具"><a href="#服务器安装lrzsz工具" class="headerlink" title="服务器安装lrzsz工具"></a>服务器安装lrzsz工具</h3><h3 id="使用rz、sz"><a href="#使用rz、sz" class="headerlink" title="使用rz、sz"></a>使用rz、sz</h3><p>在服务器上，<br>输入命令rz,出现选择本地文件窗口，选择文件后开始上传  </p>]]></content>
      
      <categories>
          
          <category> mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
            <tag> iTerm </tag>
            
            <tag> sz/rz </tag>
            
            <tag> scp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mac - VMware Fusion虚拟机对centos7设置网络</title>
      <link href="/2018/05/16/mac-VMware-Fusion%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9centos7%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C/"/>
      <url>/2018/05/16/mac-VMware-Fusion%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9centos7%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C/</url>
      <content type="html"><![CDATA[<h3 id="虚拟机设置网络模式"><a href="#虚拟机设置网络模式" class="headerlink" title="虚拟机设置网络模式"></a>虚拟机设置网络模式</h3><p>虚拟机采用NAT模式<br><img src="http://pkvv4hyzz.bkt.clouddn.com//image/mac/mac_VM_NAT%E6%A8%A1%E5%BC%8F.png" width="453" height="300" alt="NAT模式">  </p><h3 id="设置Centos7的网络配置"><a href="#设置Centos7的网络配置" class="headerlink" title="设置Centos7的网络配置"></a>设置Centos7的网络配置</h3><h4 id="查看mac中vmnet8的gateway"><a href="#查看mac中vmnet8的gateway" class="headerlink" title="查看mac中vmnet8的gateway"></a>查看mac中vmnet8的gateway</h4><p>在mac终端中，查看配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /Library/Preferences/VMware Fusion/vmnet8/nat.conf</span><br></pre></td></tr></table></figure><p><img src="http://pkvv4hyzz.bkt.clouddn.com//image/mac/mac_VM_gateway%E5%9C%B0%E5%9D%80.png" width="355" height="120" alt="gateway地址"> </p><h4 id="查看虚拟机可分配地址"><a href="#查看虚拟机可分配地址" class="headerlink" title="查看虚拟机可分配地址"></a>查看虚拟机可分配地址</h4><p>在win10中虚拟机的静态ip可以自己直接设置想用的ip，但是在mac的vmware fusion中不可以，vmware fusion会分配一个ip范围让虚拟机使用，你给Centos设置的静态ip必须在这个范围之内  </p><p>进入mac终端查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /Library/Preferences/VMware\ Fusion/vmnet8/dhcpd.conf</span><br></pre></td></tr></table></figure><p><img src="http://pkvv4hyzz.bkt.clouddn.com//image/mac/mac_VM_Vmware_ip%E8%8C%83%E5%9B%B4.png" width="461" height="219" alt="Vmware_ip范围"> </p><h4 id="修改Centos7的配置文件"><a href="#修改Centos7的配置文件" class="headerlink" title="修改Centos7的配置文件"></a>修改Centos7的配置文件</h4><p>修改文件：/etc/sysconfig/network-scripts/ifcfg-ens33  </p><p>配置参数如下，文件中有的变量则修改值，没有变量就进行添加：</p><ul><li>BOOTPROTO=static</li><li>IPADDR=上面mac中找到的ip范围中设置一个（我的是172.16.199.129）</li><li>GATEWAY=设置上面mac中看到的gatway地址（172.16.199.2）</li><li>NETMASK=255.255.255.0</li><li>ONBOOT=yes</li><li>DNS1=8.8.8.8（可以在mac中查看网络-&gt;高级中的DNS地址）</li></ul><p><img src="http://pkvv4hyzz.bkt.clouddn.com//image/mac/mac_VM_centos%E8%AE%BE%E7%BD%AEip.png" width="411" height="319" alt="centos设置ip"></p><h4 id="重启网卡"><a href="#重启网卡" class="headerlink" title="重启网卡"></a>重启网卡</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在centos中ping主机和百度<br>在mac主机中ping虚拟机<br>都ping通就说明成功了</p>]]></content>
      
      <categories>
          
          <category> Centos7 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos7 </tag>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mac-iterm2+sshpass+shuttle实现ssh部分功能</title>
      <link href="/2018/05/15/mac-iterm2-sshpass-shuttle%E5%AE%9E%E7%8E%B0ssh%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD/"/>
      <url>/2018/05/15/mac-iterm2-sshpass-shuttle%E5%AE%9E%E7%8E%B0ssh%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<h4 id="安装iterm2"><a href="#安装iterm2" class="headerlink" title="安装iterm2"></a>安装iterm2</h4><h4 id="安装sshpass"><a href="#安装sshpass" class="headerlink" title="安装sshpass"></a>安装sshpass</h4><ol><li>下载sshpass源码</li><li>解压，tar -zxvf sshpass-1.06.tar.gz</li><li>进入解压目录，cd sshpass-1.06</li><li>检测当前环境，编译安装：<br>./configure<br>sudo make<br>sudo make install</li><li>检测是否安装成功：sshpass -h</li></ol><h4 id="安装shuttle"><a href="#安装shuttle" class="headerlink" title="安装shuttle"></a>安装shuttle</h4><h5 id="下载shuttle"><a href="#下载shuttle" class="headerlink" title="下载shuttle"></a>下载shuttle</h5><p>下载地址：<a href="https://fitztrev.github.io/shuttle/" target="_blank" rel="noopener">https://fitztrev.github.io/shuttle/</a>  </p><h5 id="配置shuttle"><a href="#配置shuttle" class="headerlink" title="配置shuttle"></a>配置shuttle</h5><p>点开设置-&gt;编辑，会打开.shuttle.json文件  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_comments"</span>: [</span><br><span class="line">    <span class="string">"Valid terminals include: 'Terminal.app' or 'iTerm'"</span>,</span><br><span class="line">    <span class="string">"In the editor value change 'default' to 'nano', 'vi', or another terminal based editor."</span>,</span><br><span class="line">    <span class="string">"Hosts will also be read from your ~/.ssh/config or /etc/ssh_config file, if available"</span>,</span><br><span class="line">    <span class="string">"For more information on how to configure, please see http://fitztrev.github.io/shuttle/"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"editor"</span>: <span class="string">"default"</span>,</span><br><span class="line">  <span class="attr">"launch_at_login"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"terminal"</span>: <span class="string">"iTerm"</span>,</span><br><span class="line">  <span class="attr">"iTerm_version"</span>: <span class="string">"nightly"</span>,</span><br><span class="line">  <span class="attr">"default_theme"</span>: <span class="string">"Homebrew"</span>,</span><br><span class="line">  <span class="attr">"open_in"</span>: <span class="string">"new"</span>,  </span><br><span class="line">  <span class="attr">"show_ssh_config_hosts"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"ssh_config_ignore_hosts"</span>: [  ],</span><br><span class="line">  <span class="attr">"ssh_config_ignore_keywords"</span>: [  ],</span><br><span class="line">  <span class="attr">"hosts"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"cmd"</span>: <span class="string">"cd ~"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"my iterm"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"Company_Project"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"cmd"</span>: <span class="string">"sshpass -p ceshi123 ssh -o StrictHostKeyChecking=no root@127.0.0.1"</span>,</span><br><span class="line">          <span class="attr">"name"</span>: <span class="string">"测试"</span>,</span><br><span class="line">          <span class="attr">"inTerminal"</span>: <span class="string">"tab"</span>,</span><br><span class="line">          <span class="attr">"theme"</span>: <span class="string">"Homebrew"</span>,</span><br><span class="line">          <span class="attr">"title"</span>: <span class="string">"测试"</span></span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"cmd"</span>: <span class="string">"sshpass -p ceshi123 ssh -o StrictHostKeyChecking=no root@127.0.0.1"</span>,</span><br><span class="line">          <span class="attr">"name"</span>: <span class="string">"测试"</span>,</span><br><span class="line">          <span class="attr">"inTerminal"</span>: <span class="string">"tab"</span>,</span><br><span class="line">          <span class="attr">"theme"</span>: <span class="string">"Homebrew"</span>,</span><br><span class="line">          <span class="attr">"title"</span>: <span class="string">"测试"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象中字段含义</p><ul><li>cmd: 需要执行的命令</li><li>name: 菜单名</li><li>inTerminal: 命令执行窗口模式（可选值：new, tab, current）</li><li>theme: 终端主题</li><li>title: 终端显示标题(缺失时使用name作为标题)</li></ul><h5 id="shuttle效果"><a href="#shuttle效果" class="headerlink" title="shuttle效果"></a>shuttle效果</h5><p>以下是效果图   </p><p><img src="http://pkvv4hyzz.bkt.clouddn.com//image/mac/mac_iterm2_shuttle_%E9%85%8D%E7%BD%AE%E6%95%88%E6%9E%9C.png" width="315" height="155" alt="配置效果"> </p><p>你可以配置你经常登录的服务器，这样可以免去每次登陆输入地址用户名密码了<br>缺点是服务器的用户名密码能被看到  </p>]]></content>
      
      <categories>
          
          <category> mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
            <tag> ssh </tag>
            
            <tag> shuttle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IntelliJ IDEA技巧-添加类注释和方法注释</title>
      <link href="/2018/04/28/IntelliJ-IDEA%E6%8A%80%E5%B7%A7-%E6%B7%BB%E5%8A%A0%E7%B1%BB%E6%B3%A8%E9%87%8A%E5%92%8C%E6%96%B9%E6%B3%95%E6%B3%A8%E9%87%8A/"/>
      <url>/2018/04/28/IntelliJ-IDEA%E6%8A%80%E5%B7%A7-%E6%B7%BB%E5%8A%A0%E7%B1%BB%E6%B3%A8%E9%87%8A%E5%92%8C%E6%96%B9%E6%B3%95%E6%B3%A8%E9%87%8A/</url>
      <content type="html"><![CDATA[<h3 id="添加文件头注释"><a href="#添加文件头注释" class="headerlink" title="添加文件头注释"></a>添加文件头注释</h3><p>打开设置：<br>Editor-&gt;Filr and Code Templates-&gt;Includes-&gt;File Header</p><p><img src="/2018/04/28/IntelliJ-IDEA技巧-添加类注释和方法注释/IntelliJ-IDEA注释_设置头注释.png" alt="设置头注释"></p><p>这个注释只是你在生成类文件时在类上方的注释<br>右下角是idea中模板中支持的变量</p><p>我的注释模板 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @program: $&#123;PROJECT_NAME&#125;</span><br><span class="line">* @Package $&#123;PACKAGE_NAME&#125;</span><br><span class="line">* @Description: TODO</span><br><span class="line">* @author Miss.Ning</span><br><span class="line">* @date $&#123;DATE&#125; $&#123;TIME&#125;</span><br><span class="line">* @version V1.0</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="添加方法注释"><a href="#添加方法注释" class="headerlink" title="添加方法注释"></a>添加方法注释</h3><p>Editor-&gt;Live Templates<br>可以自己新建一个自己的注释模板   </p><h4 id="新建模板组"><a href="#新建模板组" class="headerlink" title="新建模板组"></a>新建模板组</h4><p>右上角+号，选择Template Group，建一个属于自己的模板组，我的名字是MyComment<br>模板组可以方许多你自己新建的模板 </p><p><img src="/2018/04/28/IntelliJ-IDEA技巧-添加类注释和方法注释/IntelliJ-IDEA注释_新建注释模板组.png" alt="新建注释模板组"></p><h4 id="新建模板"><a href="#新建模板" class="headerlink" title="新建模板"></a>新建模板</h4><p>选中刚刚新建的组（我的是MyComment），点击右上角+号，选择Live Template  </p><p><img src="/2018/04/28/IntelliJ-IDEA技巧-添加类注释和方法注释/IntelliJ-IDEA注释_新建注释模板.png" alt="新建注释模板"></p><ol><li>Abbreviation：这里可以起一个名字，相当于生成注释的提示，可以是一个符号，或是一个字母  </li><li>description：描述，可写可不写</li><li>Template：放你的模板 </li><li>点击define，选择EveryWhere</li><li>点击右边的Edit variables</li><li>右边的Expand可以选择你生成注释的快捷键，默认tab键</li></ol><p>生成注释：你设置的Abbreviation快捷键 + Expand设置的快捷键</p><h5 id="填写基本设置"><a href="#填写基本设置" class="headerlink" title="填写基本设置"></a>填写基本设置</h5><p><img src="/2018/04/28/IntelliJ-IDEA技巧-添加类注释和方法注释/IntelliJ-IDEA注释_新建方法模板.png" alt="新建方法模板"></p><p><img src="/2018/04/28/IntelliJ-IDEA技巧-添加类注释和方法注释/define.png" width="315" height="385" alt="define"> </p><p>在Edit variables中，设置你在注释模板中的参数：</p><p><img src="/2018/04/28/IntelliJ-IDEA技巧-添加类注释和方法注释/变量设置.png" width="415" height="155" alt="变量设置">  </p><h5 id="自定义注释参数显示"><a href="#自定义注释参数显示" class="headerlink" title="自定义注释参数显示"></a>自定义注释参数显示</h5><p>但是idea中的param参数显示的是一个数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> [param1,param2...]</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 测试生成方法注释的参数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Miss.Ning</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2018/04/28 15:50</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodTest</span><span class="params">(<span class="keyword">int</span> param1, String param2...)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用groovyScript脚本写一个生成参数，将多个参数分行显示<br>如果采用以上的自定义参数模板，那么注释模板也要改变  </p><p><img src="/2018/04/28/IntelliJ-IDEA技巧-添加类注释和方法注释/自定义param.png" width="410" height="155" alt="自定义param">  </p><p>将以下内容写到param的expression中即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groovyScript(&quot;def result=&apos;&apos;; def params=\&quot;$&#123;_1&#125;\&quot;.replaceAll(&apos;[\\\\[|\\\\]|\\\\s]&apos;, &apos;&apos;).split(&apos;,&apos;).toList(); for(i = 0; i &lt; params.size(); i++) &#123;result+=&apos; * @param &apos; + params[i] + &apos;\\t&apos; + ((i &lt; params.size() - 1) ? &apos;\\n&apos; : &apos;&apos;)&#125;; return result&quot;, methodParameters())</span><br></pre></td></tr></table></figure><h5 id="生成注释方式以及注释模板"><a href="#生成注释方式以及注释模板" class="headerlink" title="生成注释方式以及注释模板"></a>生成注释方式以及注释模板</h5><p>Abbreviation是你生成注释打的一个提示，如果你写的是a，那么你在写注释时只用打一个a，按tab键即可生成</p><p>1.普通模板（在你的参数设置使用系统自带的返回参数方法时可用），生成方式：你设置的Abbreviation + tab键</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: $description$ </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Param</span>: $params$ </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: $returns$ </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Miss.Ning </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: $date$ $time$ </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>2.设置我在上面提供的自定义参数，生成方式：你设置的Abbreviation + tab键</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * @Description: $description$ </span><br><span class="line">$params$ </span><br><span class="line"> * @return: $returns$ </span><br><span class="line"> * @Author: Miss.Ning</span><br><span class="line"> * @Date: $date$ $time$ </span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>3.我的习惯设置  生成方式：/* + tab键</p><p>我的模板比较特殊，因为我在生成方法注释时习惯先打/*出现注释，所以我将Abbreviation设为<em>，然后生成注释时先打一个/\</em>，按一下tab快捷键，就生成注释了  </p><p>以下是我的注释模板，注意前后空格哦 （注意哈，我的模板开头少了/*，因为我在生成注释时已经打了一个/*了） </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* </span><br><span class="line"> * @Description: $description$ </span><br><span class="line">$params$ </span><br><span class="line"> * @return: $returns$ </span><br><span class="line"> * @Author: Miss.Ning </span><br><span class="line"> * @Date: $date$ $time$ </span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>以下就是我生成的注释，在方法上输入：/* + tab键生成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 测试生成方法注释的参数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>: param1</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>: param2</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>:</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: Miss.Ning</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Date</span>: 2018/04/28 15:50</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodTest</span><span class="params">(<span class="keyword">int</span> param1, String param2...)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> IntelliJ IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IntelliJ IDEA </tag>
            
            <tag> 添加注释 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mac-打开MacOS-High-Sierra原生的读写NTFS功能</title>
      <link href="/2018/04/09/mac-%E6%89%93%E5%BC%80MacOS-High-Sierra%E5%8E%9F%E7%94%9F%E7%9A%84%E8%AF%BB%E5%86%99NTFS%E5%8A%9F%E8%83%BD/"/>
      <url>/2018/04/09/mac-%E6%89%93%E5%BC%80MacOS-High-Sierra%E5%8E%9F%E7%94%9F%E7%9A%84%E8%AF%BB%E5%86%99NTFS%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<h3 id="mac-NTFS功能"><a href="#mac-NTFS功能" class="headerlink" title="mac NTFS功能"></a>mac NTFS功能</h3><p>mac下不能直接写入的NTFS格式的磁盘，只支持读，一般我们想要写入数据到移动硬盘，要借助专业的NTFS工具，大多数人使用的是Paragon NTFS for MAC，但是这个工具是收费的，破解版都不能使用，而且有人说这个工具有可能会丢失数据<br>如果你想要节省时间愿意为他付费，可以使用Paragon NTFS for MAC来读写，我试用过，但是感觉不太符合我的习惯  </p><p>有人说这个ntfs限制原先是没有的，  </p><blockquote><p>其实最早在OSX 10.5的时候，OSX其实原生就支持直接写入NTFS的盘的，后来由于微软的限制，把这个功能给屏蔽了，我们可以通过命令行手动打开这个选项。  </p></blockquote><p>网上很多大神分享的方法是通过终端使用命令打开，试过之后发现真的可以  </p><p><strong>注意：执行以下过程之前必须插入你的NTFS驱动器。</strong></p><h3 id="确定你的驱动器名称"><a href="#确定你的驱动器名称" class="headerlink" title="确定你的驱动器名称"></a>确定你的驱动器名称</h3><p>方式一：在Finder中查看你的驱动器名称  </p><p><img src="http://pkvv4hyzz.bkt.clouddn.com//image/mac/mac_NTFS_Finder_name.png" alt="驱动器名称mac_NTFS_Finder_name"></p><p>方式二：使用命令行，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diskutil list</span><br></pre></td></tr></table></figure><p><img src="http://pkvv4hyzz.bkt.clouddn.com//image/mac/mac_NTFS_volume_name.png" width="420" height="215" alt="命令行驱动器名称mac_NTFS_volume_name">    </p><p>我的名称是nys<br>注意：驱动器名称最好不要有空格    </p><h3 id="使用命令打开NTFS读写权限"><a href="#使用命令打开NTFS读写权限" class="headerlink" title="使用命令打开NTFS读写权限"></a>使用命令打开NTFS读写权限</h3><p>启动终端，执行如下命令行：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/fstab</span><br></pre></td></tr></table></figure><p>在文件中写入以下内容，注意：内容中的NAME是你的磁盘驱动名称： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL=NAME none ntfs rw,auto,nobrowse</span><br></pre></td></tr></table></figure><p>保存，执行完成之后，你就会发现现在已经可以向磁盘中写入数据了！  </p><h3 id="驱动器位置"><a href="#驱动器位置" class="headerlink" title="驱动器位置"></a>驱动器位置</h3><p>在你推出了你的驱动器，再次插上之后会发现Finder左侧栏中不会出现你的驱动器了<br>有的人是推出再插上驱动器之后不再出现，有的是要关机重启之后才不再出现。<br>你需要找到你的驱动器,你的驱动器是挂在/Volumes上的：  </p><ul><li><p>在Finder->前往 选择：前往文件夹，输入 ：/Volumes  </p><p>  <img src="http://pkvv4hyzz.bkt.clouddn.com//image/mac/mac_NTFS_path.png" alt="驱动器位置mac_NTFS_path">  </p></li><li><p>每次都要前往文件夹很麻烦，可以将这个文件夹固定在桌面中：输入如下命令(注意，volume_name是你的驱动器名称)：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /Volumes/volume_name /Desktop/volume_name</span><br></pre></td></tr></table></figure><h3 id="关于没有成功的情况"><a href="#关于没有成功的情况" class="headerlink" title="关于没有成功的情况"></a>关于没有成功的情况</h3><p>检查你的驱动器名称中是否有空格，如果有，使用“\040”进行转义  </p><p>以上内容是我参考的以下两篇文章:<br><a href="https://bbs.feng.com/read-htm-tid-9932031.html" target="_blank" rel="noopener">https://bbs.feng.com/read-htm-tid-9932031.html</a><br><a href="http://macdrug.com/write-ntfs-drive-macos-sierra/" target="_blank" rel="noopener">http://macdrug.com/write-ntfs-drive-macos-sierra/</a></p>]]></content>
      
      <categories>
          
          <category> mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
            <tag> NTFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo - GitHub Pages + Hexo 搭建个人网站</title>
      <link href="/2018/03/19/hexo-GitHub-Pages-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"/>
      <url>/2018/03/19/hexo-GitHub-Pages-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/</url>
      <content type="html"><![CDATA[<h3 id="搭建GitHub-Pages"><a href="#搭建GitHub-Pages" class="headerlink" title="搭建GitHub Pages"></a>搭建GitHub Pages</h3><p>Github Pages是用户托管在github上的静态网页，因为Github Pages可以给我们提供一个免费的域名，所以我们通常使用他来构建自己的博客<br>登录github,新建一个仓库，名称必须是：你的github名称.github.io</p><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br>hexo环境依赖：git、Node.js</p><h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><ul><li>Windows：下载并安装 git.</li><li>Mac：使用 Homebrew：brew install git<br>安装完成之后配置git与你的github的SSH连接</li></ul><h4 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h4><p>1）先安装nvm(Node Version Manager):之所以需要这个工具，是因为 Node.js 的各种特性都没有稳定下来，所以我们经常由于老项目或尝新的原因，需要切换各种版本。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.25.2/install.sh | bash</span><br></pre></td></tr></table></figure><p>2）6.9是我选择的版本 ,安装好之后可以用npm安装cnpm和nrm，使用淘宝镜像，因为默认的镜像是国外的，访问速度慢。安装完成之后，我们可以用cnpm代替npm安装其他东西</p><blockquote><p>cnpm支持npm除了publish之外的所有命令，所以说你可以放心的使用cnpm来代替npm使用，这样可能使用包管理的时候更加的方便，因为服务器就在国内。但是，有时候如果你的网络情况比较渣的话，用啥都一样。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install 6.9  </span><br><span class="line">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h4 id="配置Hexo"><a href="#配置Hexo" class="headerlink" title="配置Hexo"></a>配置Hexo</h4><p>安装：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>查看是否成功，成功后显示hexo版本  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo v</span><br></pre></td></tr></table></figure><p>新建一个目录，存放你的博客。（我建的文件夹是blog）<br>进入blog目录(注意：以下步骤都是在blog目录下完成的)：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br><span class="line">$ cnpm install</span><br></pre></td></tr></table></figure><p>安装完成之后，体验hexo    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g # 生成  </span><br><span class="line">$ hexo s # 启动服务预览（生成在本地）</span><br></pre></td></tr></table></figure><p>打开本地地址：localhost:4000</p><h4 id="部署Hexo到Github-Pages："><a href="#部署Hexo到Github-Pages：" class="headerlink" title="部署Hexo到Github Pages："></a>部署Hexo到Github Pages：</h4><ul><li>前提：将本地git连接到github上配置好</li><li>在Github上创建的仓库（github名称.github.io），可以通过地址<a href="http://github名称.github.io直接访问，访问的文件就是其中的html静态文件，" target="_blank" rel="noopener">http://github名称.github.io直接访问，访问的文件就是其中的html静态文件，</a></li><li>每次将写好的文章用hexo生成，然后用git提交到github上<br>进入blog目录，打开博客站点的配置文件_config.yml，在文件末尾修改：</li></ul><blockquote><p>deploy:<br>　type: git<br>　repo: <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:yashuning/yashuning.github.io.git<br>　branch: master</p></blockquote><p>注意，这种配置文件格式要求比较严格:<br>如果文件末尾已经有deploy、type等字段，删去，改为以上的内容;<br>type、repo、branch三个变量之前空两格，变量后的：之后空一格</p><p>安装git部署插件：    </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>分别输入以下三条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><ul><li>hexo clean：清除缓存 - 清楚本地的 hexo 下面的public文件夹及里面的文件</li><li>hexo g：生成静态文件 - 在 hexo 下生成public文件夹及里面的文件</li><li>hexo d：部署到 GitHub - 在 hexo 下生成.deploy_git文件夹，并将public里面的内容拷贝过来，git就是将这里面的一些静态文件部署到GitHub Page</li></ul><p>部署完成</p><h3 id="hexo主题"><a href="#hexo主题" class="headerlink" title="hexo主题"></a>hexo主题</h3><p>hexo提供了多款主题，我自己比较喜欢的是next主题<br>进入blog文件夹（自己选择存放博客的文件夹）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>下载完成后，在blog/themes下出现一个next文件夹，这就是你的next主题<br>在blog目录下，更改站点配置文件_config.yml</p><blockquote><p>#Extensions<br>##Plugins: <a href="https://hexo.io/plugins/" target="_blank" rel="noopener">https://hexo.io/plugins/</a><br>##Themes: <a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a><br>#theme: landscape<br>theme: next</p></blockquote><p>将主题改为next</p>]]></content>
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> GitHub Pages </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/03/14/hello-world/"/>
      <url>/2018/03/14/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">积分GV</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
